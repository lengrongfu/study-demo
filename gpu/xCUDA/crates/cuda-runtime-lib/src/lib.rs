#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use api;
use code_genearte::cuda_runtime_bindings_11_08::{cudaChannelFormatDesc, cudaError_t, cudaLimit};
use futures::executor::block_on;
use std::borrow::BorrowMut;
use std::sync::{Mutex, Once};
use tarpc::{client, context, tokio_serde::formats::Json};
use tokio::runtime;

pub type CUresult = ::std::os::raw::c_uint;
pub type CUdeviceptr_v2 = ::std::os::raw::c_ulonglong;
pub type CUdeviceptr = CUdeviceptr_v2;
pub type CUdevice_v1 = ::std::os::raw::c_int;
pub type CUdevice = CUdevice_v1;

static mut CUDA_CLIENT: Option<Mutex<api::cuda_runtime_api::CudaRuntimeClient>> = None;
static mut RPC_RUNTIME: Option<Mutex<runtime::Runtime>> = None;
static CUDA_INIT: Once = Once::new();
static RPC_INIT: Once = Once::new();

fn cudaRuntimeClient<'a>() -> &'a Mutex<api::cuda_runtime_api::CudaRuntimeClient> {
    CUDA_INIT.call_once(|| {
        // Since this access is inside a call_once, before any other accesses, it is safe
        unsafe {
            let transport = block_on(tarpc::serde_transport::tcp::connect(
                "10.20.2.102:50051",
                Json::default,
            ))
            .unwrap();
            // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
            // config and any Transport as input.
            let client =
                api::cuda_runtime_api::CudaRuntimeClient::new(client::Config::default(), transport)
                    .spawn();
            *CUDA_CLIENT.borrow_mut() = Some(Mutex::new(client));
        }
    });

    // As long as this function is the only place with access to the static variable,
    // giving out a read-only borrow here is safe because it is guaranteed no more mutable
    // references will exist at this point or in the future.
    unsafe { CUDA_CLIENT.as_ref().unwrap() }
}

fn buildRuntime<'a>() -> &'a Mutex<runtime::Runtime> {
    RPC_INIT.call_once(|| {
        unsafe {
            // let rt = runtime::Runtime::new().unwrap();
            let rt = tokio::runtime::Builder::new_multi_thread()
                .worker_threads(8) // 8个工作线程
                .enable_io() // 可在runtime中使用异步IO
                .enable_time() // 可在runtime中使用异步计时器(timer)
                .build() // 创建runtime
                .unwrap();
            *RPC_RUNTIME.borrow_mut() = Some(Mutex::new(rt));
        }
    });
    unsafe { RPC_RUNTIME.as_ref().unwrap() }
}

#[no_mangle]
pub extern "C" fn cudaDeviceReset() -> cudaError_t {
    println!("this is libcudart.so, call cudaDeviceReset");
    buildRuntime().lock().unwrap().block_on(async {
        let ret = block_on(
            cudaRuntimeClient()
                .lock()
                .unwrap()
                .cudaDeviceReset(context::current()),
        )
        .unwrap();
        ret
    })
}

#[no_mangle]
pub extern "C" fn cudaDeviceSynchronize() -> cudaError_t {
    println!("this is libcudart.so, call cudaDeviceSynchronize");
    buildRuntime().lock().unwrap().block_on(async {
        let ret = block_on(
            cudaRuntimeClient()
                .lock()
                .unwrap()
                .cudaDeviceSynchronize(context::current()),
        )
        .unwrap();
        ret
    })
}

#[no_mangle]
pub extern "C" fn cudaDeviceSetLimit(limit: cudaLimit, value: usize) -> cudaError_t {
    println!("this is libcudart.so, call cudaDeviceSetLimit");
    buildRuntime().lock().unwrap().block_on(async {
        let ret = block_on(cudaRuntimeClient().lock().unwrap().cudaDeviceSetLimit(
            context::current(),
            limit,
            value,
        ))
        .unwrap();
        ret
    })
}

#[no_mangle]
pub unsafe extern "C" fn cudaDeviceGetLimit(pValue: *mut usize, limit: cudaLimit) -> cudaError_t {
    println!("this is libcudart.so, call cudaDeviceGetLimit");
    buildRuntime().lock().unwrap().block_on(async {
        let (pValuePtr, ret) = block_on(
            cudaRuntimeClient()
                .lock()
                .unwrap()
                .cudaDeviceGetLimit(context::current(), limit),
        )
        .unwrap();
        *pValue = pValuePtr;
        ret
    })
}

#[no_mangle]
pub unsafe extern "C" fn cudaDeviceGetTexture1DLinearMaxWidth(
    maxWidthInElements: *mut usize,
    fmtDesc: *const cudaChannelFormatDesc,
    device: ::std::os::raw::c_int,
) -> cudaError_t {
    println!("this is libcudart.so, call cudaDeviceGetTexture1DLinearMaxWidth");
    buildRuntime().lock().unwrap().block_on(async {
        let (maxWidthInElementsPtr, ret) = block_on(
            cudaRuntimeClient()
                .lock()
                .unwrap()
                .cudaDeviceGetTexture1DLinearMaxWidth(context::current(), fmtDesc, device),
        )
        .unwrap();
        *maxWidthInElements = maxWidthInElementsPtr;
        ret
    })
}
