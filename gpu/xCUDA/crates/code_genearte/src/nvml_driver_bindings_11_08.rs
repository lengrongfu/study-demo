/* automatically generated by rust-bindgen 0.69.1 */

pub const NVML_API_VERSION: u32 = 11;
pub const NVML_API_VERSION_STR: &[u8; 3] = b"11\0";
pub const NVML_VALUE_NOT_AVAILABLE: i32 = -1;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE: u32 = 32;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE: u32 = 16;
pub const NVML_DEVICE_PCI_BUS_ID_LEGACY_FMT: &[u8; 17] = b"%04X:%02X:%02X.0\0";
pub const NVML_DEVICE_PCI_BUS_ID_FMT: &[u8; 17] = b"%08X:%02X:%02X.0\0";
pub const NVML_NVLINK_MAX_LINKS: u32 = 18;
pub const NVML_MAX_PHYSICAL_BRIDGE: u32 = 128;
pub const NVML_MAX_THERMAL_SENSORS_PER_GPU: u32 = 3;
pub const nvmlFlagDefault: u32 = 0;
pub const nvmlFlagForce: u32 = 1;
pub const MAX_CLK_DOMAINS: u32 = 32;
pub const NVML_MAX_GPU_PERF_PSTATES: u32 = 16;
pub const NVML_GRID_LICENSE_EXPIRY_NOT_AVAILABLE: u32 = 0;
pub const NVML_GRID_LICENSE_EXPIRY_INVALID: u32 = 1;
pub const NVML_GRID_LICENSE_EXPIRY_VALID: u32 = 2;
pub const NVML_GRID_LICENSE_EXPIRY_NOT_APPLICABLE: u32 = 3;
pub const NVML_GRID_LICENSE_EXPIRY_PERMANENT: u32 = 4;
pub const NVML_GRID_LICENSE_BUFFER_SIZE: u32 = 128;
pub const NVML_VGPU_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_GRID_LICENSE_FEATURE_MAX_COUNT: u32 = 3;
pub const INVALID_GPU_INSTANCE_PROFILE_ID: u32 = 4294967295;
pub const INVALID_GPU_INSTANCE_ID: u32 = 4294967295;
pub const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_GRID_LICENSE_STATE_UNKNOWN: u32 = 0;
pub const NVML_GRID_LICENSE_STATE_UNINITIALIZED: u32 = 1;
pub const NVML_GRID_LICENSE_STATE_UNLICENSED_UNRESTRICTED: u32 = 2;
pub const NVML_GRID_LICENSE_STATE_UNLICENSED_RESTRICTED: u32 = 3;
pub const NVML_GRID_LICENSE_STATE_UNLICENSED: u32 = 4;
pub const NVML_GRID_LICENSE_STATE_LICENSED: u32 = 5;
pub const NVML_GSP_FIRMWARE_VERSION_BUF_SIZE: u32 = 64;
pub const NVML_DEVICE_ARCH_KEPLER: u32 = 2;
pub const NVML_DEVICE_ARCH_MAXWELL: u32 = 3;
pub const NVML_DEVICE_ARCH_PASCAL: u32 = 4;
pub const NVML_DEVICE_ARCH_VOLTA: u32 = 5;
pub const NVML_DEVICE_ARCH_TURING: u32 = 6;
pub const NVML_DEVICE_ARCH_AMPERE: u32 = 7;
pub const NVML_DEVICE_ARCH_ADA: u32 = 8;
pub const NVML_DEVICE_ARCH_HOPPER: u32 = 9;
pub const NVML_DEVICE_ARCH_UNKNOWN: u32 = 4294967295;
pub const NVML_BUS_TYPE_UNKNOWN: u32 = 0;
pub const NVML_BUS_TYPE_PCI: u32 = 1;
pub const NVML_BUS_TYPE_PCIE: u32 = 2;
pub const NVML_BUS_TYPE_FPCI: u32 = 3;
pub const NVML_BUS_TYPE_AGP: u32 = 4;
pub const NVML_POWER_MODE_ID_BALANCED: u32 = 0;
pub const NVML_POWER_MODE_ID_MAX: u32 = 1;
pub const NVML_POWER_SOURCE_AC: u32 = 0;
pub const NVML_POWER_SOURCE_BATTERY: u32 = 1;
pub const NVML_PCIE_LINK_MAX_SPEED_INVALID: u32 = 0;
pub const NVML_PCIE_LINK_MAX_SPEED_2500MBPS: u32 = 1;
pub const NVML_PCIE_LINK_MAX_SPEED_5000MBPS: u32 = 2;
pub const NVML_PCIE_LINK_MAX_SPEED_8000MBPS: u32 = 3;
pub const NVML_PCIE_LINK_MAX_SPEED_16000MBPS: u32 = 4;
pub const NVML_PCIE_LINK_MAX_SPEED_32000MBPS: u32 = 5;
pub const NVML_ADAPTIVE_CLOCKING_INFO_STATUS_DISABLED: u32 = 0;
pub const NVML_ADAPTIVE_CLOCKING_INFO_STATUS_ENABLED: u32 = 1;
pub const NVML_MAX_GPU_UTILIZATIONS: u32 = 8;
pub const NVML_FI_DEV_ECC_CURRENT: u32 = 1;
pub const NVML_FI_DEV_ECC_PENDING: u32 = 2;
pub const NVML_FI_DEV_ECC_SBE_VOL_TOTAL: u32 = 3;
pub const NVML_FI_DEV_ECC_DBE_VOL_TOTAL: u32 = 4;
pub const NVML_FI_DEV_ECC_SBE_AGG_TOTAL: u32 = 5;
pub const NVML_FI_DEV_ECC_DBE_AGG_TOTAL: u32 = 6;
pub const NVML_FI_DEV_ECC_SBE_VOL_L1: u32 = 7;
pub const NVML_FI_DEV_ECC_DBE_VOL_L1: u32 = 8;
pub const NVML_FI_DEV_ECC_SBE_VOL_L2: u32 = 9;
pub const NVML_FI_DEV_ECC_DBE_VOL_L2: u32 = 10;
pub const NVML_FI_DEV_ECC_SBE_VOL_DEV: u32 = 11;
pub const NVML_FI_DEV_ECC_DBE_VOL_DEV: u32 = 12;
pub const NVML_FI_DEV_ECC_SBE_VOL_REG: u32 = 13;
pub const NVML_FI_DEV_ECC_DBE_VOL_REG: u32 = 14;
pub const NVML_FI_DEV_ECC_SBE_VOL_TEX: u32 = 15;
pub const NVML_FI_DEV_ECC_DBE_VOL_TEX: u32 = 16;
pub const NVML_FI_DEV_ECC_DBE_VOL_CBU: u32 = 17;
pub const NVML_FI_DEV_ECC_SBE_AGG_L1: u32 = 18;
pub const NVML_FI_DEV_ECC_DBE_AGG_L1: u32 = 19;
pub const NVML_FI_DEV_ECC_SBE_AGG_L2: u32 = 20;
pub const NVML_FI_DEV_ECC_DBE_AGG_L2: u32 = 21;
pub const NVML_FI_DEV_ECC_SBE_AGG_DEV: u32 = 22;
pub const NVML_FI_DEV_ECC_DBE_AGG_DEV: u32 = 23;
pub const NVML_FI_DEV_ECC_SBE_AGG_REG: u32 = 24;
pub const NVML_FI_DEV_ECC_DBE_AGG_REG: u32 = 25;
pub const NVML_FI_DEV_ECC_SBE_AGG_TEX: u32 = 26;
pub const NVML_FI_DEV_ECC_DBE_AGG_TEX: u32 = 27;
pub const NVML_FI_DEV_ECC_DBE_AGG_CBU: u32 = 28;
pub const NVML_FI_DEV_RETIRED_SBE: u32 = 29;
pub const NVML_FI_DEV_RETIRED_DBE: u32 = 30;
pub const NVML_FI_DEV_RETIRED_PENDING: u32 = 31;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L0: u32 = 32;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L1: u32 = 33;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L2: u32 = 34;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L3: u32 = 35;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L4: u32 = 36;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L5: u32 = 37;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL: u32 = 38;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L0: u32 = 39;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L1: u32 = 40;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L2: u32 = 41;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L3: u32 = 42;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L4: u32 = 43;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L5: u32 = 44;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL: u32 = 45;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L0: u32 = 46;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L1: u32 = 47;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L2: u32 = 48;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L3: u32 = 49;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L4: u32 = 50;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L5: u32 = 51;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL: u32 = 52;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L0: u32 = 53;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L1: u32 = 54;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L2: u32 = 55;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L3: u32 = 56;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L4: u32 = 57;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L5: u32 = 58;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL: u32 = 59;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L0: u32 = 60;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L1: u32 = 61;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L2: u32 = 62;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L3: u32 = 63;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L4: u32 = 64;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L5: u32 = 65;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_TOTAL: u32 = 66;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L0: u32 = 67;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L1: u32 = 68;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L2: u32 = 69;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L3: u32 = 70;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L4: u32 = 71;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L5: u32 = 72;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_TOTAL: u32 = 73;
pub const NVML_FI_DEV_PERF_POLICY_POWER: u32 = 74;
pub const NVML_FI_DEV_PERF_POLICY_THERMAL: u32 = 75;
pub const NVML_FI_DEV_PERF_POLICY_SYNC_BOOST: u32 = 76;
pub const NVML_FI_DEV_PERF_POLICY_BOARD_LIMIT: u32 = 77;
pub const NVML_FI_DEV_PERF_POLICY_LOW_UTILIZATION: u32 = 78;
pub const NVML_FI_DEV_PERF_POLICY_RELIABILITY: u32 = 79;
pub const NVML_FI_DEV_PERF_POLICY_TOTAL_APP_CLOCKS: u32 = 80;
pub const NVML_FI_DEV_PERF_POLICY_TOTAL_BASE_CLOCKS: u32 = 81;
pub const NVML_FI_DEV_MEMORY_TEMP: u32 = 82;
pub const NVML_FI_DEV_TOTAL_ENERGY_CONSUMPTION: u32 = 83;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L0: u32 = 84;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L1: u32 = 85;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L2: u32 = 86;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L3: u32 = 87;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L4: u32 = 88;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L5: u32 = 89;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_COMMON: u32 = 90;
pub const NVML_FI_DEV_NVLINK_LINK_COUNT: u32 = 91;
pub const NVML_FI_DEV_RETIRED_PENDING_SBE: u32 = 92;
pub const NVML_FI_DEV_RETIRED_PENDING_DBE: u32 = 93;
pub const NVML_FI_DEV_PCIE_REPLAY_COUNTER: u32 = 94;
pub const NVML_FI_DEV_PCIE_REPLAY_ROLLOVER_COUNTER: u32 = 95;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L6: u32 = 96;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L7: u32 = 97;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L8: u32 = 98;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L9: u32 = 99;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L10: u32 = 100;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L11: u32 = 101;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L6: u32 = 102;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L7: u32 = 103;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L8: u32 = 104;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L9: u32 = 105;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L10: u32 = 106;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L11: u32 = 107;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L6: u32 = 108;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L7: u32 = 109;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L8: u32 = 110;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L9: u32 = 111;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L10: u32 = 112;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L11: u32 = 113;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L6: u32 = 114;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L7: u32 = 115;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L8: u32 = 116;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L9: u32 = 117;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L10: u32 = 118;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L11: u32 = 119;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L6: u32 = 120;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L7: u32 = 121;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L8: u32 = 122;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L9: u32 = 123;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L10: u32 = 124;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L11: u32 = 125;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L6: u32 = 126;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L7: u32 = 127;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L8: u32 = 128;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L9: u32 = 129;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L10: u32 = 130;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L11: u32 = 131;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L6: u32 = 132;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L7: u32 = 133;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L8: u32 = 134;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L9: u32 = 135;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L10: u32 = 136;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L11: u32 = 137;
pub const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_TX: u32 = 138;
pub const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_RX: u32 = 139;
pub const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_TX: u32 = 140;
pub const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_RX: u32 = 141;
pub const NVML_FI_DEV_REMAPPED_COR: u32 = 142;
pub const NVML_FI_DEV_REMAPPED_UNC: u32 = 143;
pub const NVML_FI_DEV_REMAPPED_PENDING: u32 = 144;
pub const NVML_FI_DEV_REMAPPED_FAILURE: u32 = 145;
pub const NVML_FI_DEV_NVLINK_REMOTE_NVLINK_ID: u32 = 146;
pub const NVML_FI_DEV_NVSWITCH_CONNECTED_LINK_COUNT: u32 = 147;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L0: u32 = 148;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L1: u32 = 149;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L2: u32 = 150;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L3: u32 = 151;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L4: u32 = 152;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L5: u32 = 153;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L6: u32 = 154;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L7: u32 = 155;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L8: u32 = 156;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L9: u32 = 157;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L10: u32 = 158;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L11: u32 = 159;
pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_TOTAL: u32 = 160;
pub const NVML_FI_DEV_NVLINK_ERROR_DL_REPLAY: u32 = 161;
pub const NVML_FI_DEV_NVLINK_ERROR_DL_RECOVERY: u32 = 162;
pub const NVML_FI_DEV_NVLINK_ERROR_DL_CRC: u32 = 163;
pub const NVML_FI_DEV_NVLINK_GET_SPEED: u32 = 164;
pub const NVML_FI_DEV_NVLINK_GET_STATE: u32 = 165;
pub const NVML_FI_DEV_NVLINK_GET_VERSION: u32 = 166;
pub const NVML_FI_MAX: u32 = 167;
pub const nvmlEventTypeSingleBitEccError: u32 = 1;
pub const nvmlEventTypeDoubleBitEccError: u32 = 2;
pub const nvmlEventTypePState: u32 = 4;
pub const nvmlEventTypeXidCriticalError: u32 = 8;
pub const nvmlEventTypeClock: u32 = 16;
pub const nvmlEventTypePowerSourceChange: u32 = 128;
pub const nvmlEventMigConfigChange: u32 = 256;
pub const nvmlEventTypeNone: u32 = 0;
pub const nvmlEventTypeAll: u32 = 415;
pub const nvmlClocksThrottleReasonGpuIdle: u32 = 1;
pub const nvmlClocksThrottleReasonApplicationsClocksSetting: u32 = 2;
pub const nvmlClocksThrottleReasonUserDefinedClocks: u32 = 2;
pub const nvmlClocksThrottleReasonSwPowerCap: u32 = 4;
pub const nvmlClocksThrottleReasonHwSlowdown: u32 = 8;
pub const nvmlClocksThrottleReasonSyncBoost: u32 = 16;
pub const nvmlClocksThrottleReasonSwThermalSlowdown: u32 = 32;
pub const nvmlClocksThrottleReasonHwThermalSlowdown: u32 = 64;
pub const nvmlClocksThrottleReasonHwPowerBrakeSlowdown: u32 = 128;
pub const nvmlClocksThrottleReasonDisplayClockSetting: u32 = 256;
pub const nvmlClocksThrottleReasonNone: u32 = 0;
pub const NVML_NVFBC_SESSION_FLAG_DIFFMAP_ENABLED: u32 = 1;
pub const NVML_NVFBC_SESSION_FLAG_CLASSIFICATIONMAP_ENABLED: u32 = 2;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_NO_WAIT: u32 = 4;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_INFINITE: u32 = 8;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_TIMEOUT: u32 = 16;
pub const NVML_INIT_FLAG_NO_GPUS: u32 = 1;
pub const NVML_INIT_FLAG_NO_ATTACH: u32 = 2;
pub const NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE: u32 = 16;
pub const NVML_DEVICE_UUID_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_UUID_V2_BUFFER_SIZE: u32 = 96;
pub const NVML_DEVICE_PART_NUMBER_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_DEVICE_NAME_V2_BUFFER_SIZE: u32 = 96;
pub const NVML_DEVICE_SERIAL_BUFFER_SIZE: u32 = 30;
pub const NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE: u32 = 32;
pub const NVML_AFFINITY_SCOPE_NODE: u32 = 0;
pub const NVML_AFFINITY_SCOPE_SOCKET: u32 = 1;
pub const NVML_DEVICE_MIG_DISABLE: u32 = 0;
pub const NVML_DEVICE_MIG_ENABLE: u32 = 1;
pub const NVML_GPU_INSTANCE_PROFILE_1_SLICE: u32 = 0;
pub const NVML_GPU_INSTANCE_PROFILE_2_SLICE: u32 = 1;
pub const NVML_GPU_INSTANCE_PROFILE_3_SLICE: u32 = 2;
pub const NVML_GPU_INSTANCE_PROFILE_4_SLICE: u32 = 3;
pub const NVML_GPU_INSTANCE_PROFILE_7_SLICE: u32 = 4;
pub const NVML_GPU_INSTANCE_PROFILE_8_SLICE: u32 = 5;
pub const NVML_GPU_INSTANCE_PROFILE_6_SLICE: u32 = 6;
pub const NVML_GPU_INSTANCE_PROFILE_1_SLICE_REV1: u32 = 7;
pub const NVML_GPU_INSTANCE_PROFILE_COUNT: u32 = 8;
pub const NVML_COMPUTE_INSTANCE_PROFILE_1_SLICE: u32 = 0;
pub const NVML_COMPUTE_INSTANCE_PROFILE_2_SLICE: u32 = 1;
pub const NVML_COMPUTE_INSTANCE_PROFILE_3_SLICE: u32 = 2;
pub const NVML_COMPUTE_INSTANCE_PROFILE_4_SLICE: u32 = 3;
pub const NVML_COMPUTE_INSTANCE_PROFILE_7_SLICE: u32 = 4;
pub const NVML_COMPUTE_INSTANCE_PROFILE_8_SLICE: u32 = 5;
pub const NVML_COMPUTE_INSTANCE_PROFILE_6_SLICE: u32 = 6;
pub const NVML_COMPUTE_INSTANCE_PROFILE_COUNT: u32 = 7;
pub const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_SHARED: u32 = 0;
pub const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_COUNT: u32 = 1;
pub const NVML_GPM_METRICS_GET_VERSION: u32 = 1;
pub const NVML_GPM_SUPPORT_VERSION: u32 = 1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlDevice_st {
    _unused: [u8; 0],
}
pub type nvmlDevice_t = *mut nvmlDevice_st;
#[doc = " PCI information about a GPU device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlPciInfo_st {
    #[doc = "!< The legacy tuple domain:bus:device.function PCI identifier (&amp; NULL terminator)"]
    pub busIdLegacy: [::std::os::raw::c_char; 16usize],
    #[doc = "!< The PCI domain on which the device's bus resides, 0 to 0xffffffff"]
    pub domain: ::std::os::raw::c_uint,
    #[doc = "!< The bus on which the device resides, 0 to 0xff"]
    pub bus: ::std::os::raw::c_uint,
    #[doc = "!< The device's id on the bus, 0 to 31"]
    pub device: ::std::os::raw::c_uint,
    #[doc = "!< The combined 16-bit device id and 16-bit vendor id"]
    pub pciDeviceId: ::std::os::raw::c_uint,
    #[doc = "!< The 32-bit Sub System Device ID"]
    pub pciSubSystemId: ::std::os::raw::c_uint,
    #[doc = "!< The tuple domain:bus:device.function PCI identifier (&amp; NULL terminator)"]
    pub busId: [::std::os::raw::c_char; 32usize],
}
#[doc = " PCI information about a GPU device."]
pub type nvmlPciInfo_t = nvmlPciInfo_st;
#[doc = " Detailed ECC error counts for a device.\n\n @deprecated  Different GPU families can have different memory error counters\n              See \\ref nvmlDeviceGetMemoryErrorCounter"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlEccErrorCounts_st {
    #[doc = "!< L1 cache errors"]
    pub l1Cache: ::std::os::raw::c_ulonglong,
    #[doc = "!< L2 cache errors"]
    pub l2Cache: ::std::os::raw::c_ulonglong,
    #[doc = "!< Device memory errors"]
    pub deviceMemory: ::std::os::raw::c_ulonglong,
    #[doc = "!< Register file errors"]
    pub registerFile: ::std::os::raw::c_ulonglong,
}
#[doc = " Detailed ECC error counts for a device.\n\n @deprecated  Different GPU families can have different memory error counters\n              See \\ref nvmlDeviceGetMemoryErrorCounter"]
pub type nvmlEccErrorCounts_t = nvmlEccErrorCounts_st;
#[doc = " Utilization information for a device.\n Each sample period may be between 1 second and 1/6 second, depending on the product being queried."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlUtilization_st {
    #[doc = "!< Percent of time over the past sample period during which one or more kernels was executing on the GPU"]
    pub gpu: ::std::os::raw::c_uint,
    #[doc = "!< Percent of time over the past sample period during which global (device) memory was being read or written"]
    pub memory: ::std::os::raw::c_uint,
}
#[doc = " Utilization information for a device.\n Each sample period may be between 1 second and 1/6 second, depending on the product being queried."]
pub type nvmlUtilization_t = nvmlUtilization_st;
#[doc = " Memory allocation information for a device (v1).\n The total amount is equal to the sum of the amounts of free and used memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlMemory_st {
    #[doc = "!< Total physical device memory (in bytes)"]
    pub total: ::std::os::raw::c_ulonglong,
    #[doc = "!< Unallocated device memory (in bytes)"]
    pub free: ::std::os::raw::c_ulonglong,
    #[doc = "!< Sum of Reserved and Allocated device memory (in bytes).\n!< Note that the driver/GPU always sets aside a small amount of memory for bookkeeping"]
    pub used: ::std::os::raw::c_ulonglong,
}
#[doc = " Memory allocation information for a device (v1).\n The total amount is equal to the sum of the amounts of free and used memory."]
pub type nvmlMemory_t = nvmlMemory_st;
#[doc = " Memory allocation information for a device (v2).\n\n Version 2 adds versioning for the struct and the amount of system-reserved memory as an output.\n @note The \\ref nvmlMemory_v2_t.used amount also includes the \\ref nvmlMemory_v2_t.reserved amount."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlMemory_v2_st {
    #[doc = "!< Structure format version (must be 2)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Total physical device memory (in bytes)"]
    pub total: ::std::os::raw::c_ulonglong,
    #[doc = "!< Device memory (in bytes) reserved for system use (driver or firmware)"]
    pub reserved: ::std::os::raw::c_ulonglong,
    #[doc = "!< Unallocated device memory (in bytes)"]
    pub free: ::std::os::raw::c_ulonglong,
    #[doc = "!< Allocated device memory (in bytes). Note that the driver/GPU always sets aside a small amount of memory for bookkeeping"]
    pub used: ::std::os::raw::c_ulonglong,
}
#[doc = " Memory allocation information for a device (v2).\n\n Version 2 adds versioning for the struct and the amount of system-reserved memory as an output.\n @note The \\ref nvmlMemory_v2_t.used amount also includes the \\ref nvmlMemory_v2_t.reserved amount."]
pub type nvmlMemory_v2_t = nvmlMemory_v2_st;
#[doc = " BAR1 Memory allocation Information for a device"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlBAR1Memory_st {
    #[doc = "!< Total BAR1 Memory (in bytes)"]
    pub bar1Total: ::std::os::raw::c_ulonglong,
    #[doc = "!< Unallocated BAR1 Memory (in bytes)"]
    pub bar1Free: ::std::os::raw::c_ulonglong,
    #[doc = "!< Allocated Used Memory (in bytes)"]
    pub bar1Used: ::std::os::raw::c_ulonglong,
}
#[doc = " BAR1 Memory allocation Information for a device"]
pub type nvmlBAR1Memory_t = nvmlBAR1Memory_st;
#[doc = " Information about running compute processes on the GPU, legacy version\n for older versions of the API."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlProcessInfo_v1_st {
    #[doc = "!< Process ID"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Amount of used GPU memory in bytes."]
    pub usedGpuMemory: ::std::os::raw::c_ulonglong,
}
#[doc = " Information about running compute processes on the GPU, legacy version\n for older versions of the API."]
pub type nvmlProcessInfo_v1_t = nvmlProcessInfo_v1_st;
#[doc = " Information about running compute processes on the GPU"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlProcessInfo_v2_st {
    #[doc = "!< Process ID"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Amount of used GPU memory in bytes."]
    pub usedGpuMemory: ::std::os::raw::c_ulonglong,
    #[doc = "!< If MIG is enabled, stores a valid GPU instance ID. gpuInstanceId is set to"]
    pub gpuInstanceId: ::std::os::raw::c_uint,
    #[doc = "!< If MIG is enabled, stores a valid compute instance ID. computeInstanceId is set to"]
    pub computeInstanceId: ::std::os::raw::c_uint,
}
#[doc = " Information about running compute processes on the GPU"]
pub type nvmlProcessInfo_v2_t = nvmlProcessInfo_v2_st;
#[doc = " Information about running compute processes on the GPU\n Version 2 adds versioning for the struct and the conf compute protected memory in output."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlProcessInfo_st {
    #[doc = "!< Process ID"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Amount of used GPU memory in bytes."]
    pub usedGpuMemory: ::std::os::raw::c_ulonglong,
    #[doc = "!< If MIG is enabled, stores a valid GPU instance ID. gpuInstanceId is set to"]
    pub gpuInstanceId: ::std::os::raw::c_uint,
    #[doc = "!< If MIG is enabled, stores a valid compute instance ID. computeInstanceId is set to"]
    pub computeInstanceId: ::std::os::raw::c_uint,
}
#[doc = " Information about running compute processes on the GPU\n Version 2 adds versioning for the struct and the conf compute protected memory in output."]
pub type nvmlProcessInfo_t = nvmlProcessInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlDeviceAttributes_st {
    #[doc = "!< Streaming Multiprocessor count"]
    pub multiprocessorCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Copy Engine count"]
    pub sharedCopyEngineCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Decoder Engine count"]
    pub sharedDecoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Encoder Engine count"]
    pub sharedEncoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared JPEG Engine count"]
    pub sharedJpegCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared OFA Engine count"]
    pub sharedOfaCount: ::std::os::raw::c_uint,
    #[doc = "!< GPU instance slice count"]
    pub gpuInstanceSliceCount: ::std::os::raw::c_uint,
    #[doc = "!< Compute instance slice count"]
    pub computeInstanceSliceCount: ::std::os::raw::c_uint,
    #[doc = "!< Device memory size (in MiB)"]
    pub memorySizeMB: ::std::os::raw::c_ulonglong,
}
pub type nvmlDeviceAttributes_t = nvmlDeviceAttributes_st;
#[doc = " Possible values that classify the remap availability for each bank. The max\n field will contain the number of banks that have maximum remap availability\n (all reserved rows are available). None means that there are no reserved\n rows available."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlRowRemapperHistogramValues_st {
    pub max: ::std::os::raw::c_uint,
    pub high: ::std::os::raw::c_uint,
    pub partial: ::std::os::raw::c_uint,
    pub low: ::std::os::raw::c_uint,
    pub none: ::std::os::raw::c_uint,
}
#[doc = " Possible values that classify the remap availability for each bank. The max\n field will contain the number of banks that have maximum remap availability\n (all reserved rows are available). None means that there are no reserved\n rows available."]
pub type nvmlRowRemapperHistogramValues_t = nvmlRowRemapperHistogramValues_st;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_PLX: nvmlBridgeChipType_enum = 0;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_BRO4: nvmlBridgeChipType_enum = 1;
#[doc = " Enum to represent type of bridge chip"]
pub type nvmlBridgeChipType_enum = ::std::os::raw::c_uint;
#[doc = " Enum to represent type of bridge chip"]
pub use self::nvmlBridgeChipType_enum as nvmlBridgeChipType_t;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_CYCLES:
    nvmlNvLinkUtilizationCountUnits_enum = 0;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_PACKETS:
    nvmlNvLinkUtilizationCountUnits_enum = 1;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_BYTES:
    nvmlNvLinkUtilizationCountUnits_enum = 2;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_RESERVED:
    nvmlNvLinkUtilizationCountUnits_enum = 3;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_COUNT:
    nvmlNvLinkUtilizationCountUnits_enum = 4;
#[doc = " Enum to represent the NvLink utilization counter packet units"]
pub type nvmlNvLinkUtilizationCountUnits_enum = ::std::os::raw::c_uint;
#[doc = " Enum to represent the NvLink utilization counter packet units"]
pub use self::nvmlNvLinkUtilizationCountUnits_enum as nvmlNvLinkUtilizationCountUnits_t;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NOP:
    nvmlNvLinkUtilizationCountPktTypes_enum = 1;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_READ:
    nvmlNvLinkUtilizationCountPktTypes_enum = 2;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_WRITE:
    nvmlNvLinkUtilizationCountPktTypes_enum = 4;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RATOM:
    nvmlNvLinkUtilizationCountPktTypes_enum = 8;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NRATOM:
    nvmlNvLinkUtilizationCountPktTypes_enum = 16;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_FLUSH:
    nvmlNvLinkUtilizationCountPktTypes_enum = 32;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA:
    nvmlNvLinkUtilizationCountPktTypes_enum = 64;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA:
    nvmlNvLinkUtilizationCountPktTypes_enum = 128;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_ALL:
    nvmlNvLinkUtilizationCountPktTypes_enum = 255;
#[doc = " Enum to represent the NvLink utilization counter packet types to count\n  ** this is ONLY applicable with the units as packets or bytes\n  ** as specified in \\a nvmlNvLinkUtilizationCountUnits_t\n  ** all packet filter descriptions are target GPU centric\n  ** these can be \"OR'd\" together"]
pub type nvmlNvLinkUtilizationCountPktTypes_enum = ::std::os::raw::c_uint;
#[doc = " Enum to represent the NvLink utilization counter packet types to count\n  ** this is ONLY applicable with the units as packets or bytes\n  ** as specified in \\a nvmlNvLinkUtilizationCountUnits_t\n  ** all packet filter descriptions are target GPU centric\n  ** these can be \"OR'd\" together"]
pub use self::nvmlNvLinkUtilizationCountPktTypes_enum as nvmlNvLinkUtilizationCountPktTypes_t;
#[doc = " Struct to define the NVLINK counter controls"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlNvLinkUtilizationControl_st {
    pub units: nvmlNvLinkUtilizationCountUnits_t,
    pub pktfilter: nvmlNvLinkUtilizationCountPktTypes_t,
}
#[doc = " Struct to define the NVLINK counter controls"]
pub type nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_SUPPORTED: nvmlNvLinkCapability_enum = 0;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ACCESS: nvmlNvLinkCapability_enum = 1;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_ATOMICS: nvmlNvLinkCapability_enum = 2;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ATOMICS: nvmlNvLinkCapability_enum = 3;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SLI_BRIDGE: nvmlNvLinkCapability_enum = 4;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_VALID: nvmlNvLinkCapability_enum = 5;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_COUNT: nvmlNvLinkCapability_enum = 6;
#[doc = " Enum to represent NvLink queryable capabilities"]
pub type nvmlNvLinkCapability_enum = ::std::os::raw::c_uint;
#[doc = " Enum to represent NvLink queryable capabilities"]
pub use self::nvmlNvLinkCapability_enum as nvmlNvLinkCapability_t;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_REPLAY: nvmlNvLinkErrorCounter_enum = 0;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_RECOVERY: nvmlNvLinkErrorCounter_enum =
    1;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_FLIT: nvmlNvLinkErrorCounter_enum =
    2;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_DATA: nvmlNvLinkErrorCounter_enum =
    3;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_ECC_DATA: nvmlNvLinkErrorCounter_enum =
    4;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_COUNT: nvmlNvLinkErrorCounter_enum = 5;
#[doc = " Enum to represent NvLink queryable error counters"]
pub type nvmlNvLinkErrorCounter_enum = ::std::os::raw::c_uint;
#[doc = " Enum to represent NvLink queryable error counters"]
pub use self::nvmlNvLinkErrorCounter_enum as nvmlNvLinkErrorCounter_t;
pub const nvmlIntNvLinkDeviceType_enum_NVML_NVLINK_DEVICE_TYPE_GPU: nvmlIntNvLinkDeviceType_enum =
    0;
pub const nvmlIntNvLinkDeviceType_enum_NVML_NVLINK_DEVICE_TYPE_IBMNPU:
    nvmlIntNvLinkDeviceType_enum = 1;
pub const nvmlIntNvLinkDeviceType_enum_NVML_NVLINK_DEVICE_TYPE_SWITCH:
    nvmlIntNvLinkDeviceType_enum = 2;
pub const nvmlIntNvLinkDeviceType_enum_NVML_NVLINK_DEVICE_TYPE_UNKNOWN:
    nvmlIntNvLinkDeviceType_enum = 255;
#[doc = " Enum to represent NvLink's remote device type"]
pub type nvmlIntNvLinkDeviceType_enum = ::std::os::raw::c_uint;
#[doc = " Enum to represent NvLink's remote device type"]
pub use self::nvmlIntNvLinkDeviceType_enum as nvmlIntNvLinkDeviceType_t;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_INTERNAL: nvmlGpuLevel_enum = 0;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SINGLE: nvmlGpuLevel_enum = 10;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_MULTIPLE: nvmlGpuLevel_enum = 20;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_HOSTBRIDGE: nvmlGpuLevel_enum = 30;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_NODE: nvmlGpuLevel_enum = 40;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SYSTEM: nvmlGpuLevel_enum = 50;
#[doc = " Represents level relationships within a system between two GPUs\n The enums are spaced to allow for future relationships"]
pub type nvmlGpuLevel_enum = ::std::os::raw::c_uint;
#[doc = " Represents level relationships within a system between two GPUs\n The enums are spaced to allow for future relationships"]
pub use self::nvmlGpuLevel_enum as nvmlGpuTopologyLevel_t;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_OK: nvmlGpuP2PStatus_enum = 0;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED: nvmlGpuP2PStatus_enum = 1;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_GPU_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 2;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED: nvmlGpuP2PStatus_enum =
    3;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_DISABLED_BY_REGKEY: nvmlGpuP2PStatus_enum = 4;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 5;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_UNKNOWN: nvmlGpuP2PStatus_enum = 6;
pub type nvmlGpuP2PStatus_enum = ::std::os::raw::c_uint;
pub use self::nvmlGpuP2PStatus_enum as nvmlGpuP2PStatus_t;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_READ: nvmlGpuP2PCapsIndex_enum = 0;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_WRITE: nvmlGpuP2PCapsIndex_enum = 1;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_NVLINK: nvmlGpuP2PCapsIndex_enum = 2;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_ATOMICS: nvmlGpuP2PCapsIndex_enum = 3;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_PROP: nvmlGpuP2PCapsIndex_enum = 4;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_UNKNOWN: nvmlGpuP2PCapsIndex_enum = 5;
pub type nvmlGpuP2PCapsIndex_enum = ::std::os::raw::c_uint;
pub use self::nvmlGpuP2PCapsIndex_enum as nvmlGpuP2PCapsIndex_t;
#[doc = " Information about the Bridge Chip Firmware"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlBridgeChipInfo_st {
    #[doc = "!< Type of Bridge Chip"]
    pub type_: nvmlBridgeChipType_t,
    #[doc = "!< Firmware Version. 0=Version is unavailable"]
    pub fwVersion: ::std::os::raw::c_uint,
}
#[doc = " Information about the Bridge Chip Firmware"]
pub type nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st;
#[doc = " This structure stores the complete Hierarchy of the Bridge Chip within the board. The immediate\n bridge is stored at index 0 of bridgeInfoList, parent to immediate bridge is at index 1 and so forth."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlBridgeChipHierarchy_st {
    #[doc = "!< Number of Bridge Chips on the Board"]
    pub bridgeCount: ::std::os::raw::c_uchar,
    #[doc = "!< Hierarchy of Bridge Chips on the board"]
    pub bridgeChipInfo: [nvmlBridgeChipInfo_t; 128usize],
}
#[doc = " This structure stores the complete Hierarchy of the Bridge Chip within the board. The immediate\n bridge is stored at index 0 of bridgeInfoList, parent to immediate bridge is at index 1 and so forth."]
pub type nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st;
#[doc = "!< To represent total power drawn by GPU"]
pub const nvmlSamplingType_enum_NVML_TOTAL_POWER_SAMPLES: nvmlSamplingType_enum = 0;
#[doc = "!< To represent percent of time during which one or more kernels was executing on the GPU"]
pub const nvmlSamplingType_enum_NVML_GPU_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 1;
#[doc = "!< To represent percent of time during which global (device) memory was being read or written"]
pub const nvmlSamplingType_enum_NVML_MEMORY_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 2;
#[doc = "!< To represent percent of time during which NVENC remains busy"]
pub const nvmlSamplingType_enum_NVML_ENC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 3;
#[doc = "!< To represent percent of time during which NVDEC remains busy"]
pub const nvmlSamplingType_enum_NVML_DEC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 4;
#[doc = "!< To represent processor clock samples"]
pub const nvmlSamplingType_enum_NVML_PROCESSOR_CLK_SAMPLES: nvmlSamplingType_enum = 5;
#[doc = "!< To represent memory clock samples"]
pub const nvmlSamplingType_enum_NVML_MEMORY_CLK_SAMPLES: nvmlSamplingType_enum = 6;
pub const nvmlSamplingType_enum_NVML_SAMPLINGTYPE_COUNT: nvmlSamplingType_enum = 7;
#[doc = "  Represents Type of Sampling Event"]
pub type nvmlSamplingType_enum = ::std::os::raw::c_uint;
#[doc = "  Represents Type of Sampling Event"]
pub use self::nvmlSamplingType_enum as nvmlSamplingType_t;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_TX_BYTES: nvmlPcieUtilCounter_enum = 0;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_RX_BYTES: nvmlPcieUtilCounter_enum = 1;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_COUNT: nvmlPcieUtilCounter_enum = 2;
#[doc = " Represents the queryable PCIe utilization counters"]
pub type nvmlPcieUtilCounter_enum = ::std::os::raw::c_uint;
#[doc = " Represents the queryable PCIe utilization counters"]
pub use self::nvmlPcieUtilCounter_enum as nvmlPcieUtilCounter_t;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_DOUBLE: nvmlValueType_enum = 0;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_INT: nvmlValueType_enum = 1;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG: nvmlValueType_enum = 2;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG_LONG: nvmlValueType_enum = 3;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_SIGNED_LONG_LONG: nvmlValueType_enum = 4;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_COUNT: nvmlValueType_enum = 5;
#[doc = " Represents the type for sample value returned"]
pub type nvmlValueType_enum = ::std::os::raw::c_uint;
#[doc = " Represents the type for sample value returned"]
pub use self::nvmlValueType_enum as nvmlValueType_t;
#[doc = " Union to represent different types of Value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlValue_st {
    #[doc = "!< If the value is double"]
    pub dVal: f64,
    #[doc = "!< If the value is unsigned int"]
    pub uiVal: ::std::os::raw::c_uint,
    #[doc = "!< If the value is unsigned long"]
    pub ulVal: ::std::os::raw::c_ulong,
    #[doc = "!< If the value is unsigned long long"]
    pub ullVal: ::std::os::raw::c_ulonglong,
    #[doc = "!< If the value is signed long long"]
    pub sllVal: ::std::os::raw::c_longlong,
}
#[doc = " Union to represent different types of Value"]
pub type nvmlValue_t = nvmlValue_st;
#[doc = " Information for Sample"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlSample_st {
    #[doc = "!< CPU Timestamp in microseconds"]
    pub timeStamp: ::std::os::raw::c_ulonglong,
    #[doc = "!< Sample Value"]
    pub sampleValue: nvmlValue_t,
}
#[doc = " Information for Sample"]
pub type nvmlSample_t = nvmlSample_st;
#[doc = "!< How long did power violations cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_POWER: nvmlPerfPolicyType_enum = 0;
#[doc = "!< How long did thermal violations cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_THERMAL: nvmlPerfPolicyType_enum = 1;
#[doc = "!< How long did sync boost cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_SYNC_BOOST: nvmlPerfPolicyType_enum = 2;
#[doc = "!< How long did the board limit cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_BOARD_LIMIT: nvmlPerfPolicyType_enum = 3;
#[doc = "!< How long did low utilization cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_LOW_UTILIZATION: nvmlPerfPolicyType_enum = 4;
#[doc = "!< How long did the board reliability limit cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_RELIABILITY: nvmlPerfPolicyType_enum = 5;
#[doc = "!< Total time the GPU was held below application clocks by any limiter (0 - 5 above)"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_APP_CLOCKS: nvmlPerfPolicyType_enum = 10;
#[doc = "!< Total time the GPU was held below base clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_BASE_CLOCKS: nvmlPerfPolicyType_enum = 11;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_COUNT: nvmlPerfPolicyType_enum = 12;
#[doc = " Represents type of perf policy for which violation times can be queried"]
pub type nvmlPerfPolicyType_enum = ::std::os::raw::c_uint;
#[doc = " Represents type of perf policy for which violation times can be queried"]
pub use self::nvmlPerfPolicyType_enum as nvmlPerfPolicyType_t;
#[doc = " Struct to hold perf policy violation status data"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlViolationTime_st {
    #[doc = "!< referenceTime represents CPU timestamp in microseconds"]
    pub referenceTime: ::std::os::raw::c_ulonglong,
    #[doc = "!< violationTime in Nanoseconds"]
    pub violationTime: ::std::os::raw::c_ulonglong,
}
#[doc = " Struct to hold perf policy violation status data"]
pub type nvmlViolationTime_t = nvmlViolationTime_st;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_NONE: nvmlThermalTarget_t = 0;
#[doc = "!< GPU core temperature requires NvPhysicalGpuHandle"]
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_GPU: nvmlThermalTarget_t = 1;
#[doc = "!< GPU memory temperature requires NvPhysicalGpuHandle"]
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_MEMORY: nvmlThermalTarget_t = 2;
#[doc = "!< GPU power supply temperature requires NvPhysicalGpuHandle"]
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_POWER_SUPPLY: nvmlThermalTarget_t = 4;
#[doc = "!< GPU board ambient temperature requires NvPhysicalGpuHandle"]
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_BOARD: nvmlThermalTarget_t = 8;
#[doc = "!< Visual Computing Device Board temperature requires NvVisualComputingDeviceHandle"]
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_VCD_BOARD: nvmlThermalTarget_t = 9;
#[doc = "!< Visual Computing Device Inlet temperature requires NvVisualComputingDeviceHandle"]
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_VCD_INLET: nvmlThermalTarget_t = 10;
#[doc = "!< Visual Computing Device Outlet temperature requires NvVisualComputingDeviceHandle"]
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_VCD_OUTLET: nvmlThermalTarget_t = 11;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_ALL: nvmlThermalTarget_t = 15;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_UNKNOWN: nvmlThermalTarget_t = -1;
pub type nvmlThermalTarget_t = ::std::os::raw::c_int;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_NONE: nvmlThermalController_t = 0;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_GPU_INTERNAL: nvmlThermalController_t = 1;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_ADM1032: nvmlThermalController_t = 2;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_ADT7461: nvmlThermalController_t = 3;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_MAX6649: nvmlThermalController_t = 4;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_MAX1617: nvmlThermalController_t = 5;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_LM99: nvmlThermalController_t = 6;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_LM89: nvmlThermalController_t = 7;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_LM64: nvmlThermalController_t = 8;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_G781: nvmlThermalController_t = 9;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_ADT7473: nvmlThermalController_t = 10;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_SBMAX6649: nvmlThermalController_t = 11;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_VBIOSEVT: nvmlThermalController_t = 12;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_OS: nvmlThermalController_t = 13;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_NVSYSCON_CANOAS: nvmlThermalController_t =
    14;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_NVSYSCON_E551: nvmlThermalController_t =
    15;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_MAX6649R: nvmlThermalController_t = 16;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_ADT7473S: nvmlThermalController_t = 17;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_UNKNOWN: nvmlThermalController_t = -1;
pub type nvmlThermalController_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGpuThermalSettings_t {
    pub count: ::std::os::raw::c_uint,
    pub sensor: [nvmlGpuThermalSettings_t__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGpuThermalSettings_t__bindgen_ty_1 {
    pub controller: nvmlThermalController_t,
    pub defaultMinTemp: ::std::os::raw::c_int,
    pub defaultMaxTemp: ::std::os::raw::c_int,
    pub currentTemp: ::std::os::raw::c_int,
    pub target: nvmlThermalTarget_t,
}
#[doc = "!< Feature disabled"]
pub const nvmlEnableState_enum_NVML_FEATURE_DISABLED: nvmlEnableState_enum = 0;
#[doc = "!< Feature enabled"]
pub const nvmlEnableState_enum_NVML_FEATURE_ENABLED: nvmlEnableState_enum = 1;
#[doc = " Generic enable/disable enum."]
pub type nvmlEnableState_enum = ::std::os::raw::c_uint;
#[doc = " Generic enable/disable enum."]
pub use self::nvmlEnableState_enum as nvmlEnableState_t;
pub const nvmlBrandType_enum_NVML_BRAND_UNKNOWN: nvmlBrandType_enum = 0;
pub const nvmlBrandType_enum_NVML_BRAND_QUADRO: nvmlBrandType_enum = 1;
pub const nvmlBrandType_enum_NVML_BRAND_TESLA: nvmlBrandType_enum = 2;
pub const nvmlBrandType_enum_NVML_BRAND_NVS: nvmlBrandType_enum = 3;
pub const nvmlBrandType_enum_NVML_BRAND_GRID: nvmlBrandType_enum = 4;
pub const nvmlBrandType_enum_NVML_BRAND_GEFORCE: nvmlBrandType_enum = 5;
pub const nvmlBrandType_enum_NVML_BRAND_TITAN: nvmlBrandType_enum = 6;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_VAPPS: nvmlBrandType_enum = 7;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_VPC: nvmlBrandType_enum = 8;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_VCS: nvmlBrandType_enum = 9;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_VWS: nvmlBrandType_enum = 10;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_CLOUD_GAMING: nvmlBrandType_enum = 11;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_VGAMING: nvmlBrandType_enum = 11;
pub const nvmlBrandType_enum_NVML_BRAND_QUADRO_RTX: nvmlBrandType_enum = 12;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_RTX: nvmlBrandType_enum = 13;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA: nvmlBrandType_enum = 14;
pub const nvmlBrandType_enum_NVML_BRAND_GEFORCE_RTX: nvmlBrandType_enum = 15;
pub const nvmlBrandType_enum_NVML_BRAND_TITAN_RTX: nvmlBrandType_enum = 16;
pub const nvmlBrandType_enum_NVML_BRAND_COUNT: nvmlBrandType_enum = 17;
#[doc = "  * The Brand of the GPU"]
pub type nvmlBrandType_enum = ::std::os::raw::c_uint;
#[doc = "  * The Brand of the GPU"]
pub use self::nvmlBrandType_enum as nvmlBrandType_t;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SHUTDOWN:
    nvmlTemperatureThresholds_enum = 0;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SLOWDOWN:
    nvmlTemperatureThresholds_enum = 1;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_MEM_MAX:
    nvmlTemperatureThresholds_enum = 2;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_GPU_MAX:
    nvmlTemperatureThresholds_enum = 3;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_MIN:
    nvmlTemperatureThresholds_enum = 4;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_CURR:
    nvmlTemperatureThresholds_enum = 5;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_MAX:
    nvmlTemperatureThresholds_enum = 6;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_COUNT:
    nvmlTemperatureThresholds_enum = 7;
#[doc = " Temperature thresholds."]
pub type nvmlTemperatureThresholds_enum = ::std::os::raw::c_uint;
#[doc = " Temperature thresholds."]
pub use self::nvmlTemperatureThresholds_enum as nvmlTemperatureThresholds_t;
#[doc = "!< Temperature sensor for the GPU die"]
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_GPU: nvmlTemperatureSensors_enum = 0;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_COUNT: nvmlTemperatureSensors_enum = 1;
#[doc = " Temperature sensors."]
pub type nvmlTemperatureSensors_enum = ::std::os::raw::c_uint;
#[doc = " Temperature sensors."]
pub use self::nvmlTemperatureSensors_enum as nvmlTemperatureSensors_t;
#[doc = "!< Default compute mode -- multiple contexts per device"]
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_DEFAULT: nvmlComputeMode_enum = 0;
#[doc = "!< Support Removed"]
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_THREAD: nvmlComputeMode_enum = 1;
#[doc = "!< Compute-prohibited mode -- no contexts per device"]
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_PROHIBITED: nvmlComputeMode_enum = 2;
#[doc = "!< Compute-exclusive-process mode -- only one context per device, usable from multiple threads at a time"]
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_PROCESS: nvmlComputeMode_enum = 3;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_COUNT: nvmlComputeMode_enum = 4;
#[doc = " Compute mode.\n\n NVML_COMPUTEMODE_EXCLUSIVE_PROCESS was added in CUDA 4.0.\n Earlier CUDA versions supported a single exclusive mode,\n which is equivalent to NVML_COMPUTEMODE_EXCLUSIVE_THREAD in CUDA 4.0 and beyond."]
pub type nvmlComputeMode_enum = ::std::os::raw::c_uint;
#[doc = " Compute mode.\n\n NVML_COMPUTEMODE_EXCLUSIVE_PROCESS was added in CUDA 4.0.\n Earlier CUDA versions supported a single exclusive mode,\n which is equivalent to NVML_COMPUTEMODE_EXCLUSIVE_THREAD in CUDA 4.0 and beyond."]
pub use self::nvmlComputeMode_enum as nvmlComputeMode_t;
#[doc = " Clock Monitor error types"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlClkMonFaultInfo_struct {
    #[doc = " The Domain which faulted"]
    pub clkApiDomain: ::std::os::raw::c_uint,
    #[doc = " Faults Information"]
    pub clkDomainFaultMask: ::std::os::raw::c_uint,
}
#[doc = " Clock Monitor error types"]
pub type nvmlClkMonFaultInfo_t = nvmlClkMonFaultInfo_struct;
#[doc = " Clock Monitor Status"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlClkMonStatus_status {
    #[doc = " Fault status Indicator"]
    pub bGlobalStatus: ::std::os::raw::c_uint,
    #[doc = " Total faulted domain numbers"]
    pub clkMonListSize: ::std::os::raw::c_uint,
    #[doc = " The fault Information structure"]
    pub clkMonList: [nvmlClkMonFaultInfo_t; 32usize],
}
#[doc = " Clock Monitor Status"]
pub type nvmlClkMonStatus_t = nvmlClkMonStatus_status;
#[doc = " A memory error that was corrected\n\n For ECC errors, these are single bit errors\n For Texture memory, these are errors fixed by resend"]
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_CORRECTED: nvmlMemoryErrorType_enum = 0;
#[doc = " A memory error that was not corrected\n\n For ECC errors, these are double bit errors\n For Texture memory, these are errors where the resend fails"]
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_UNCORRECTED: nvmlMemoryErrorType_enum = 1;
#[doc = "!< Count of memory error types"]
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_COUNT: nvmlMemoryErrorType_enum = 2;
#[doc = " Memory error types"]
pub type nvmlMemoryErrorType_enum = ::std::os::raw::c_uint;
#[doc = " Memory error types"]
pub use self::nvmlMemoryErrorType_enum as nvmlMemoryErrorType_t;
#[doc = "!< Volatile counts are reset each time the driver loads."]
pub const nvmlEccCounterType_enum_NVML_VOLATILE_ECC: nvmlEccCounterType_enum = 0;
#[doc = "!< Aggregate counts persist across reboots (i.e. for the lifetime of the device)"]
pub const nvmlEccCounterType_enum_NVML_AGGREGATE_ECC: nvmlEccCounterType_enum = 1;
#[doc = "!< Count of memory counter types"]
pub const nvmlEccCounterType_enum_NVML_ECC_COUNTER_TYPE_COUNT: nvmlEccCounterType_enum = 2;
#[doc = " ECC counter types.\n\n Note: Volatile counts are reset each time the driver loads. On Windows this is once per boot. On Linux this can be more frequent.\n       On Linux the driver unloads when no active clients exist. If persistence mode is enabled or there is always a driver\n       client active (e.g. X11), then Linux also sees per-boot behavior. If not, volatile counts are reset each time a compute app\n       is run."]
pub type nvmlEccCounterType_enum = ::std::os::raw::c_uint;
#[doc = " ECC counter types.\n\n Note: Volatile counts are reset each time the driver loads. On Windows this is once per boot. On Linux this can be more frequent.\n       On Linux the driver unloads when no active clients exist. If persistence mode is enabled or there is always a driver\n       client active (e.g. X11), then Linux also sees per-boot behavior. If not, volatile counts are reset each time a compute app\n       is run."]
pub use self::nvmlEccCounterType_enum as nvmlEccCounterType_t;
#[doc = "!< Graphics clock domain"]
pub const nvmlClockType_enum_NVML_CLOCK_GRAPHICS: nvmlClockType_enum = 0;
#[doc = "!< SM clock domain"]
pub const nvmlClockType_enum_NVML_CLOCK_SM: nvmlClockType_enum = 1;
#[doc = "!< Memory clock domain"]
pub const nvmlClockType_enum_NVML_CLOCK_MEM: nvmlClockType_enum = 2;
#[doc = "!< Video encoder/decoder clock domain"]
pub const nvmlClockType_enum_NVML_CLOCK_VIDEO: nvmlClockType_enum = 3;
#[doc = "!< Count of clock types"]
pub const nvmlClockType_enum_NVML_CLOCK_COUNT: nvmlClockType_enum = 4;
#[doc = " Clock types.\n\n All speeds are in Mhz."]
pub type nvmlClockType_enum = ::std::os::raw::c_uint;
#[doc = " Clock types.\n\n All speeds are in Mhz."]
pub use self::nvmlClockType_enum as nvmlClockType_t;
#[doc = "!< Current actual clock value"]
pub const nvmlClockId_enum_NVML_CLOCK_ID_CURRENT: nvmlClockId_enum = 0;
#[doc = "!< Target application clock"]
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_TARGET: nvmlClockId_enum = 1;
#[doc = "!< Default application clock target"]
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_DEFAULT: nvmlClockId_enum = 2;
#[doc = "!< OEM-defined maximum clock rate"]
pub const nvmlClockId_enum_NVML_CLOCK_ID_CUSTOMER_BOOST_MAX: nvmlClockId_enum = 3;
#[doc = "!< Count of Clock Ids."]
pub const nvmlClockId_enum_NVML_CLOCK_ID_COUNT: nvmlClockId_enum = 4;
#[doc = " Clock Ids.  These are used in combination with nvmlClockType_t\n to specify a single clock value."]
pub type nvmlClockId_enum = ::std::os::raw::c_uint;
#[doc = " Clock Ids.  These are used in combination with nvmlClockType_t\n to specify a single clock value."]
pub use self::nvmlClockId_enum as nvmlClockId_t;
#[doc = "!< WDDM driver model -- GPU treated as a display device"]
pub const nvmlDriverModel_enum_NVML_DRIVER_WDDM: nvmlDriverModel_enum = 0;
#[doc = "!< WDM (TCC) model (recommended) -- GPU treated as a generic device"]
pub const nvmlDriverModel_enum_NVML_DRIVER_WDM: nvmlDriverModel_enum = 1;
#[doc = " Driver models.\n\n Windows only."]
pub type nvmlDriverModel_enum = ::std::os::raw::c_uint;
#[doc = " Driver models.\n\n Windows only."]
pub use self::nvmlDriverModel_enum as nvmlDriverModel_t;
#[doc = "!< Performance state 0 -- Maximum Performance"]
pub const nvmlPStates_enum_NVML_PSTATE_0: nvmlPStates_enum = 0;
#[doc = "!< Performance state 1"]
pub const nvmlPStates_enum_NVML_PSTATE_1: nvmlPStates_enum = 1;
#[doc = "!< Performance state 2"]
pub const nvmlPStates_enum_NVML_PSTATE_2: nvmlPStates_enum = 2;
#[doc = "!< Performance state 3"]
pub const nvmlPStates_enum_NVML_PSTATE_3: nvmlPStates_enum = 3;
#[doc = "!< Performance state 4"]
pub const nvmlPStates_enum_NVML_PSTATE_4: nvmlPStates_enum = 4;
#[doc = "!< Performance state 5"]
pub const nvmlPStates_enum_NVML_PSTATE_5: nvmlPStates_enum = 5;
#[doc = "!< Performance state 6"]
pub const nvmlPStates_enum_NVML_PSTATE_6: nvmlPStates_enum = 6;
#[doc = "!< Performance state 7"]
pub const nvmlPStates_enum_NVML_PSTATE_7: nvmlPStates_enum = 7;
#[doc = "!< Performance state 8"]
pub const nvmlPStates_enum_NVML_PSTATE_8: nvmlPStates_enum = 8;
#[doc = "!< Performance state 9"]
pub const nvmlPStates_enum_NVML_PSTATE_9: nvmlPStates_enum = 9;
#[doc = "!< Performance state 10"]
pub const nvmlPStates_enum_NVML_PSTATE_10: nvmlPStates_enum = 10;
#[doc = "!< Performance state 11"]
pub const nvmlPStates_enum_NVML_PSTATE_11: nvmlPStates_enum = 11;
#[doc = "!< Performance state 12"]
pub const nvmlPStates_enum_NVML_PSTATE_12: nvmlPStates_enum = 12;
#[doc = "!< Performance state 13"]
pub const nvmlPStates_enum_NVML_PSTATE_13: nvmlPStates_enum = 13;
#[doc = "!< Performance state 14"]
pub const nvmlPStates_enum_NVML_PSTATE_14: nvmlPStates_enum = 14;
#[doc = "!< Performance state 15 -- Minimum Performance"]
pub const nvmlPStates_enum_NVML_PSTATE_15: nvmlPStates_enum = 15;
#[doc = "!< Unknown performance state"]
pub const nvmlPStates_enum_NVML_PSTATE_UNKNOWN: nvmlPStates_enum = 32;
#[doc = " Allowed PStates."]
pub type nvmlPStates_enum = ::std::os::raw::c_uint;
#[doc = " Allowed PStates."]
pub use self::nvmlPStates_enum as nvmlPstates_t;
#[doc = "!< Everything is enabled and running at full speed"]
pub const nvmlGom_enum_NVML_GOM_ALL_ON: nvmlGom_enum = 0;
#[doc = "!< Designed for running only compute tasks. Graphics operations\n!< are not allowed"]
pub const nvmlGom_enum_NVML_GOM_COMPUTE: nvmlGom_enum = 1;
#[doc = "!< Designed for running graphics applications that don't require\n!< high bandwidth double precision"]
pub const nvmlGom_enum_NVML_GOM_LOW_DP: nvmlGom_enum = 2;
#[doc = " GPU Operation Mode\n\n GOM allows to reduce power usage and optimize GPU throughput by disabling GPU features.\n\n Each GOM is designed to meet specific user needs."]
pub type nvmlGom_enum = ::std::os::raw::c_uint;
#[doc = " GPU Operation Mode\n\n GOM allows to reduce power usage and optimize GPU throughput by disabling GPU features.\n\n Each GOM is designed to meet specific user needs."]
pub use self::nvmlGom_enum as nvmlGpuOperationMode_t;
#[doc = "!< An object defined by OEM"]
pub const nvmlInforomObject_enum_NVML_INFOROM_OEM: nvmlInforomObject_enum = 0;
#[doc = "!< The ECC object determining the level of ECC support"]
pub const nvmlInforomObject_enum_NVML_INFOROM_ECC: nvmlInforomObject_enum = 1;
#[doc = "!< The power management object"]
pub const nvmlInforomObject_enum_NVML_INFOROM_POWER: nvmlInforomObject_enum = 2;
#[doc = "!< This counts the number of infoROM objects the driver knows about"]
pub const nvmlInforomObject_enum_NVML_INFOROM_COUNT: nvmlInforomObject_enum = 3;
#[doc = " Available infoROM objects."]
pub type nvmlInforomObject_enum = ::std::os::raw::c_uint;
#[doc = " Available infoROM objects."]
pub use self::nvmlInforomObject_enum as nvmlInforomObject_t;
#[doc = "!< The operation was successful"]
pub const nvmlReturn_enum_NVML_SUCCESS: nvmlReturn_enum = 0;
#[doc = "!< NVML was not first initialized with nvmlInit()"]
pub const nvmlReturn_enum_NVML_ERROR_UNINITIALIZED: nvmlReturn_enum = 1;
#[doc = "!< A supplied argument is invalid"]
pub const nvmlReturn_enum_NVML_ERROR_INVALID_ARGUMENT: nvmlReturn_enum = 2;
#[doc = "!< The requested operation is not available on target device"]
pub const nvmlReturn_enum_NVML_ERROR_NOT_SUPPORTED: nvmlReturn_enum = 3;
#[doc = "!< The current user does not have permission for operation"]
pub const nvmlReturn_enum_NVML_ERROR_NO_PERMISSION: nvmlReturn_enum = 4;
#[doc = "!< Deprecated: Multiple initializations are now allowed through ref counting"]
pub const nvmlReturn_enum_NVML_ERROR_ALREADY_INITIALIZED: nvmlReturn_enum = 5;
#[doc = "!< A query to find an object was unsuccessful"]
pub const nvmlReturn_enum_NVML_ERROR_NOT_FOUND: nvmlReturn_enum = 6;
#[doc = "!< An input argument is not large enough"]
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_SIZE: nvmlReturn_enum = 7;
#[doc = "!< A device's external power cables are not properly attached"]
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_POWER: nvmlReturn_enum = 8;
#[doc = "!< NVIDIA driver is not loaded"]
pub const nvmlReturn_enum_NVML_ERROR_DRIVER_NOT_LOADED: nvmlReturn_enum = 9;
#[doc = "!< User provided timeout passed"]
pub const nvmlReturn_enum_NVML_ERROR_TIMEOUT: nvmlReturn_enum = 10;
#[doc = "!< NVIDIA Kernel detected an interrupt issue with a GPU"]
pub const nvmlReturn_enum_NVML_ERROR_IRQ_ISSUE: nvmlReturn_enum = 11;
#[doc = "!< NVML Shared Library couldn't be found or loaded"]
pub const nvmlReturn_enum_NVML_ERROR_LIBRARY_NOT_FOUND: nvmlReturn_enum = 12;
#[doc = "!< Local version of NVML doesn't implement this function"]
pub const nvmlReturn_enum_NVML_ERROR_FUNCTION_NOT_FOUND: nvmlReturn_enum = 13;
#[doc = "!< infoROM is corrupted"]
pub const nvmlReturn_enum_NVML_ERROR_CORRUPTED_INFOROM: nvmlReturn_enum = 14;
#[doc = "!< The GPU has fallen off the bus or has otherwise become inaccessible"]
pub const nvmlReturn_enum_NVML_ERROR_GPU_IS_LOST: nvmlReturn_enum = 15;
#[doc = "!< The GPU requires a reset before it can be used again"]
pub const nvmlReturn_enum_NVML_ERROR_RESET_REQUIRED: nvmlReturn_enum = 16;
#[doc = "!< The GPU control device has been blocked by the operating system/cgroups"]
pub const nvmlReturn_enum_NVML_ERROR_OPERATING_SYSTEM: nvmlReturn_enum = 17;
#[doc = "!< RM detects a driver/library version mismatch"]
pub const nvmlReturn_enum_NVML_ERROR_LIB_RM_VERSION_MISMATCH: nvmlReturn_enum = 18;
#[doc = "!< An operation cannot be performed because the GPU is currently in use"]
pub const nvmlReturn_enum_NVML_ERROR_IN_USE: nvmlReturn_enum = 19;
#[doc = "!< Insufficient memory"]
pub const nvmlReturn_enum_NVML_ERROR_MEMORY: nvmlReturn_enum = 20;
#[doc = "!< No data"]
pub const nvmlReturn_enum_NVML_ERROR_NO_DATA: nvmlReturn_enum = 21;
#[doc = "!< The requested vgpu operation is not available on target device, becasue ECC is enabled"]
pub const nvmlReturn_enum_NVML_ERROR_VGPU_ECC_NOT_SUPPORTED: nvmlReturn_enum = 22;
#[doc = "!< Ran out of critical resources, other than memory"]
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_RESOURCES: nvmlReturn_enum = 23;
#[doc = "!< Ran out of critical resources, other than memory"]
pub const nvmlReturn_enum_NVML_ERROR_FREQ_NOT_SUPPORTED: nvmlReturn_enum = 24;
#[doc = "!< The provided version is invalid/unsupported"]
pub const nvmlReturn_enum_NVML_ERROR_ARGUMENT_VERSION_MISMATCH: nvmlReturn_enum = 25;
#[doc = "!< An internal driver error occurred"]
pub const nvmlReturn_enum_NVML_ERROR_UNKNOWN: nvmlReturn_enum = 999;
#[doc = " Return values for NVML API calls."]
pub type nvmlReturn_enum = ::std::os::raw::c_uint;
#[doc = " Return values for NVML API calls."]
pub use self::nvmlReturn_enum as nvmlReturn_t;
#[doc = "!< GPU L1 Cache"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L1_CACHE: nvmlMemoryLocation_enum = 0;
#[doc = "!< GPU L2 Cache"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L2_CACHE: nvmlMemoryLocation_enum = 1;
#[doc = "!< Turing+ DRAM"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DRAM: nvmlMemoryLocation_enum = 2;
#[doc = "!< GPU Device Memory"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DEVICE_MEMORY: nvmlMemoryLocation_enum = 2;
#[doc = "!< GPU Register File"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_REGISTER_FILE: nvmlMemoryLocation_enum = 3;
#[doc = "!< GPU Texture Memory"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_MEMORY: nvmlMemoryLocation_enum = 4;
#[doc = "!< Shared memory"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_SHM: nvmlMemoryLocation_enum = 5;
#[doc = "!< CBU"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_CBU: nvmlMemoryLocation_enum = 6;
#[doc = "!< Turing+ SRAM"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_SRAM: nvmlMemoryLocation_enum = 7;
#[doc = "!< This counts the number of memory locations the driver knows about"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_COUNT: nvmlMemoryLocation_enum = 8;
#[doc = " See \\ref nvmlDeviceGetMemoryErrorCounter"]
pub type nvmlMemoryLocation_enum = ::std::os::raw::c_uint;
#[doc = " See \\ref nvmlDeviceGetMemoryErrorCounter"]
pub use self::nvmlMemoryLocation_enum as nvmlMemoryLocation_t;
#[doc = "!< Page was retired due to multiple single bit ECC error"]
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS:
    nvmlPageRetirementCause_enum = 0;
#[doc = "!< Page was retired due to double bit ECC error"]
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR:
    nvmlPageRetirementCause_enum = 1;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_COUNT:
    nvmlPageRetirementCause_enum = 2;
#[doc = " Causes for page retirement"]
pub type nvmlPageRetirementCause_enum = ::std::os::raw::c_uint;
#[doc = " Causes for page retirement"]
pub use self::nvmlPageRetirementCause_enum as nvmlPageRetirementCause_t;
#[doc = "!< APIs that change application clocks, see nvmlDeviceSetApplicationsClocks\n!< and see nvmlDeviceResetApplicationsClocks"]
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS:
    nvmlRestrictedAPI_enum = 0;
#[doc = "!< APIs that enable/disable Auto Boosted clocks\n!< see nvmlDeviceSetAutoBoostedClocksEnabled"]
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS:
    nvmlRestrictedAPI_enum = 1;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_COUNT: nvmlRestrictedAPI_enum = 2;
#[doc = " API types that allow changes to default permission restrictions"]
pub type nvmlRestrictedAPI_enum = ::std::os::raw::c_uint;
#[doc = " API types that allow changes to default permission restrictions"]
pub use self::nvmlRestrictedAPI_enum as nvmlRestrictedAPI_t;
#[doc = "!< Represents Bare Metal GPU"]
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_NONE: nvmlGpuVirtualizationMode =
    0;
#[doc = "!< Device is associated with GPU-Passthorugh"]
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH:
    nvmlGpuVirtualizationMode = 1;
#[doc = "!< Device is associated with vGPU inside virtual machine."]
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_VGPU: nvmlGpuVirtualizationMode =
    2;
#[doc = "!< Device is associated with VGX hypervisor in vGPU mode"]
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU:
    nvmlGpuVirtualizationMode = 3;
#[doc = "!< Device is associated with VGX hypervisor in vSGA mode"]
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA:
    nvmlGpuVirtualizationMode = 4;
#[doc = " GPU virtualization mode types."]
pub type nvmlGpuVirtualizationMode = ::std::os::raw::c_uint;
#[doc = " GPU virtualization mode types."]
pub use self::nvmlGpuVirtualizationMode as nvmlGpuVirtualizationMode_t;
#[doc = "!< Non SR-IOV mode"]
pub const nvmlHostVgpuMode_enum_NVML_HOST_VGPU_MODE_NON_SRIOV: nvmlHostVgpuMode_enum = 0;
#[doc = "!< SR-IOV mode"]
pub const nvmlHostVgpuMode_enum_NVML_HOST_VGPU_MODE_SRIOV: nvmlHostVgpuMode_enum = 1;
#[doc = " Host vGPU modes"]
pub type nvmlHostVgpuMode_enum = ::std::os::raw::c_uint;
#[doc = " Host vGPU modes"]
pub use self::nvmlHostVgpuMode_enum as nvmlHostVgpuMode_t;
#[doc = "!< VM ID represents DOMAIN ID"]
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_DOMAIN_ID: nvmlVgpuVmIdType = 0;
#[doc = "!< VM ID represents UUID"]
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_UUID: nvmlVgpuVmIdType = 1;
#[doc = " Types of VM identifiers"]
pub type nvmlVgpuVmIdType = ::std::os::raw::c_uint;
#[doc = " Types of VM identifiers"]
pub use self::nvmlVgpuVmIdType as nvmlVgpuVmIdType_t;
#[doc = "!< Guest-dependent fields uninitialized"]
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED:
    nvmlVgpuGuestInfoState_enum = 0;
#[doc = "!< Guest-dependent fields initialized"]
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED:
    nvmlVgpuGuestInfoState_enum = 1;
#[doc = " vGPU GUEST info state"]
pub type nvmlVgpuGuestInfoState_enum = ::std::os::raw::c_uint;
#[doc = " vGPU GUEST info state"]
pub use self::nvmlVgpuGuestInfoState_enum as nvmlVgpuGuestInfoState_t;
#[doc = "!< Unknown"]
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_UNKNOWN:
    nvmlGridLicenseFeatureCode_t = 0;
#[doc = "!< Virtual GPU"]
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VGPU:
    nvmlGridLicenseFeatureCode_t = 1;
#[doc = "!< Nvidia RTX"]
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_NVIDIA_RTX:
    nvmlGridLicenseFeatureCode_t = 2;
#[doc = "!< Deprecated, do not use."]
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION:
    nvmlGridLicenseFeatureCode_t = 2;
#[doc = "!< Gaming"]
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_GAMING:
    nvmlGridLicenseFeatureCode_t = 3;
#[doc = "!< Compute"]
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_COMPUTE:
    nvmlGridLicenseFeatureCode_t = 4;
#[doc = " vGPU software licensable features"]
pub type nvmlGridLicenseFeatureCode_t = ::std::os::raw::c_uint;
#[doc = "!< P2P over NVLink is supported"]
pub const nvmlVgpuCapability_enum_NVML_VGPU_CAP_NVLINK_P2P: nvmlVgpuCapability_enum = 0;
#[doc = "!< GPUDirect capability is supported"]
pub const nvmlVgpuCapability_enum_NVML_VGPU_CAP_GPUDIRECT: nvmlVgpuCapability_enum = 1;
pub const nvmlVgpuCapability_enum_NVML_VGPU_CAP_COUNT: nvmlVgpuCapability_enum = 2;
#[doc = " vGPU queryable capabilities"]
pub type nvmlVgpuCapability_enum = ::std::os::raw::c_uint;
#[doc = " vGPU queryable capabilities"]
pub use self::nvmlVgpuCapability_enum as nvmlVgpuCapability_t;
#[doc = "/\n/** @defgroup nvmlVgpuStructs vGPU Structs\n  @{\n/\n/"]
pub type nvmlVgpuTypeId_t = ::std::os::raw::c_uint;
pub type nvmlVgpuInstance_t = ::std::os::raw::c_uint;
#[doc = " Structure to store Utilization Value and vgpuInstance"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuInstanceUtilizationSample_st {
    #[doc = "!< vGPU Instance"]
    pub vgpuInstance: nvmlVgpuInstance_t,
    #[doc = "!< CPU Timestamp in microseconds"]
    pub timeStamp: ::std::os::raw::c_ulonglong,
    #[doc = "!< SM (3D/Compute) Util Value"]
    pub smUtil: nvmlValue_t,
    #[doc = "!< Frame Buffer Memory Util Value"]
    pub memUtil: nvmlValue_t,
    #[doc = "!< Encoder Util Value"]
    pub encUtil: nvmlValue_t,
    #[doc = "!< Decoder Util Value"]
    pub decUtil: nvmlValue_t,
}
#[doc = " Structure to store Utilization Value and vgpuInstance"]
pub type nvmlVgpuInstanceUtilizationSample_t = nvmlVgpuInstanceUtilizationSample_st;
#[doc = " Structure to store Utilization Value, vgpuInstance and subprocess information"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlVgpuProcessUtilizationSample_st {
    #[doc = "!< vGPU Instance"]
    pub vgpuInstance: nvmlVgpuInstance_t,
    #[doc = "!< PID of process running within the vGPU VM"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Name of process running within the vGPU VM"]
    pub processName: [::std::os::raw::c_char; 64usize],
    #[doc = "!< CPU Timestamp in microseconds"]
    pub timeStamp: ::std::os::raw::c_ulonglong,
    #[doc = "!< SM (3D/Compute) Util Value"]
    pub smUtil: ::std::os::raw::c_uint,
    #[doc = "!< Frame Buffer Memory Util Value"]
    pub memUtil: ::std::os::raw::c_uint,
    #[doc = "!< Encoder Util Value"]
    pub encUtil: ::std::os::raw::c_uint,
    #[doc = "!< Decoder Util Value"]
    pub decUtil: ::std::os::raw::c_uint,
}
#[doc = " Structure to store Utilization Value, vgpuInstance and subprocess information"]
pub type nvmlVgpuProcessUtilizationSample_t = nvmlVgpuProcessUtilizationSample_st;
#[doc = " Structure to store the vGPU license expiry details"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlVgpuLicenseExpiry_st {
    #[doc = "!< Year of license expiry"]
    pub year: ::std::os::raw::c_uint,
    #[doc = "!< Month of license expiry"]
    pub month: ::std::os::raw::c_ushort,
    #[doc = "!< Day of license expiry"]
    pub day: ::std::os::raw::c_ushort,
    #[doc = "!< Hour of license expiry"]
    pub hour: ::std::os::raw::c_ushort,
    #[doc = "!< Minutes of license expiry"]
    pub min: ::std::os::raw::c_ushort,
    #[doc = "!< Seconds of license expiry"]
    pub sec: ::std::os::raw::c_ushort,
    #[doc = "!< License expiry status"]
    pub status: ::std::os::raw::c_uchar,
}
#[doc = " Structure to store the vGPU license expiry details"]
pub type nvmlVgpuLicenseExpiry_t = nvmlVgpuLicenseExpiry_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlVgpuLicenseInfo_st {
    #[doc = "!< License status"]
    pub isLicensed: ::std::os::raw::c_uchar,
    #[doc = "!< License expiry information"]
    pub licenseExpiry: nvmlVgpuLicenseExpiry_t,
    #[doc = "!< Current license state"]
    pub currentState: ::std::os::raw::c_uint,
}
pub type nvmlVgpuLicenseInfo_t = nvmlVgpuLicenseInfo_st;
#[doc = " Structure to store utilization value and process Id"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlProcessUtilizationSample_st {
    #[doc = "!< PID of process"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< CPU Timestamp in microseconds"]
    pub timeStamp: ::std::os::raw::c_ulonglong,
    #[doc = "!< SM (3D/Compute) Util Value"]
    pub smUtil: ::std::os::raw::c_uint,
    #[doc = "!< Frame Buffer Memory Util Value"]
    pub memUtil: ::std::os::raw::c_uint,
    #[doc = "!< Encoder Util Value"]
    pub encUtil: ::std::os::raw::c_uint,
    #[doc = "!< Decoder Util Value"]
    pub decUtil: ::std::os::raw::c_uint,
}
#[doc = " Structure to store utilization value and process Id"]
pub type nvmlProcessUtilizationSample_t = nvmlProcessUtilizationSample_st;
#[doc = " Structure to store license expiry date and time values"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGridLicenseExpiry_st {
    #[doc = "!< Year value of license expiry"]
    pub year: ::std::os::raw::c_uint,
    #[doc = "!< Month value of license expiry"]
    pub month: ::std::os::raw::c_ushort,
    #[doc = "!< Day value of license expiry"]
    pub day: ::std::os::raw::c_ushort,
    #[doc = "!< Hour value of license expiry"]
    pub hour: ::std::os::raw::c_ushort,
    #[doc = "!< Minutes value of license expiry"]
    pub min: ::std::os::raw::c_ushort,
    #[doc = "!< Seconds value of license expiry"]
    pub sec: ::std::os::raw::c_ushort,
    #[doc = "!< License expiry status"]
    pub status: ::std::os::raw::c_uchar,
}
#[doc = " Structure to store license expiry date and time values"]
pub type nvmlGridLicenseExpiry_t = nvmlGridLicenseExpiry_st;
#[doc = " Structure containing vGPU software licensable feature information"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGridLicensableFeature_st {
    #[doc = "!< Licensed feature code"]
    pub featureCode: nvmlGridLicenseFeatureCode_t,
    #[doc = "!< Non-zero if feature is currently licensed, otherwise zero"]
    pub featureState: ::std::os::raw::c_uint,
    #[doc = "!< Deprecated."]
    pub licenseInfo: [::std::os::raw::c_char; 128usize],
    #[doc = "!< Product name of feature"]
    pub productName: [::std::os::raw::c_char; 128usize],
    #[doc = "!< Non-zero if feature is enabled, otherwise zero"]
    pub featureEnabled: ::std::os::raw::c_uint,
    #[doc = "!< License expiry structure containing date and time"]
    pub licenseExpiry: nvmlGridLicenseExpiry_t,
}
#[doc = " Structure containing vGPU software licensable feature information"]
pub type nvmlGridLicensableFeature_t = nvmlGridLicensableFeature_st;
#[doc = " Structure to store vGPU software licensable features"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGridLicensableFeatures_st {
    #[doc = "!< Non-zero if vGPU Software Licensing is supported on the system, otherwise zero"]
    pub isGridLicenseSupported: ::std::os::raw::c_int,
    #[doc = "!< Entries returned in \\a gridLicensableFeatures array"]
    pub licensableFeaturesCount: ::std::os::raw::c_uint,
    #[doc = "!< Array of vGPU software licensable features."]
    pub gridLicensableFeatures: [nvmlGridLicensableFeature_t; 3usize],
}
#[doc = " Structure to store vGPU software licensable features"]
pub type nvmlGridLicensableFeatures_t = nvmlGridLicensableFeatures_st;
pub type nvmlDeviceArchitecture_t = ::std::os::raw::c_uint;
pub type nvmlBusType_t = ::std::os::raw::c_uint;
pub type nvmlPowerSource_t = ::std::os::raw::c_uint;
#[doc = "!< Graphics engine domain"]
pub const nvmlGpuUtilizationDomainId_t_NVML_GPU_UTILIZATION_DOMAIN_GPU:
    nvmlGpuUtilizationDomainId_t = 0;
#[doc = "!< Frame buffer domain"]
pub const nvmlGpuUtilizationDomainId_t_NVML_GPU_UTILIZATION_DOMAIN_FB:
    nvmlGpuUtilizationDomainId_t = 1;
#[doc = "!< Video engine domain"]
pub const nvmlGpuUtilizationDomainId_t_NVML_GPU_UTILIZATION_DOMAIN_VID:
    nvmlGpuUtilizationDomainId_t = 2;
#[doc = "!< Bus interface domain"]
pub const nvmlGpuUtilizationDomainId_t_NVML_GPU_UTILIZATION_DOMAIN_BUS:
    nvmlGpuUtilizationDomainId_t = 3;
pub type nvmlGpuUtilizationDomainId_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGpuDynamicPstatesInfo_st {
    #[doc = "!< Reserved for future use"]
    pub flags: ::std::os::raw::c_uint,
    pub utilization: [nvmlGpuDynamicPstatesInfo_st__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGpuDynamicPstatesInfo_st__bindgen_ty_1 {
    #[doc = "!< Set if this utilization domain is present on this GPU"]
    pub bIsPresent: ::std::os::raw::c_uint,
    #[doc = "!< Percentage of time where the domain is considered busy in the last 1-second interval"]
    pub percentage: ::std::os::raw::c_uint,
    #[doc = "!< Utilization threshold that can trigger a perf-increasing P-State change when crossed"]
    pub incThreshold: ::std::os::raw::c_uint,
    #[doc = "!< Utilization threshold that can trigger a perf-decreasing P-State change when crossed"]
    pub decThreshold: ::std::os::raw::c_uint,
}
pub type nvmlGpuDynamicPstatesInfo_t = nvmlGpuDynamicPstatesInfo_st;
#[doc = " Information for a Field Value Sample"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFieldValue_st {
    #[doc = "!< ID of the NVML field to retrieve. This must be set before any call that uses this struct. See the constants starting with NVML_FI_ above."]
    pub fieldId: ::std::os::raw::c_uint,
    #[doc = "!< Scope ID can represent data used by NVML depending on fieldId's context. For example, for NVLink throughput counter data, scopeId can represent linkId."]
    pub scopeId: ::std::os::raw::c_uint,
    #[doc = "!< CPU Timestamp of this value in microseconds since 1970"]
    pub timestamp: ::std::os::raw::c_longlong,
    #[doc = "!< How long this field value took to update (in usec) within NVML. This may be averaged across several fields that are serviced by the same driver call."]
    pub latencyUsec: ::std::os::raw::c_longlong,
    #[doc = "!< Type of the value stored in value"]
    pub valueType: nvmlValueType_t,
    #[doc = "!< Return code for retrieving this value. This must be checked before looking at value, as value is undefined if nvmlReturn != NVML_SUCCESS"]
    pub nvmlReturn: nvmlReturn_t,
    #[doc = "!< Value for this field. This is only valid if nvmlReturn == NVML_SUCCESS"]
    pub value: nvmlValue_t,
}
#[doc = " Information for a Field Value Sample"]
pub type nvmlFieldValue_t = nvmlFieldValue_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnit_st {
    _unused: [u8; 0],
}
#[doc = "/\n/** @defgroup nvmlUnitStructs Unit Structs\n  @{\n/\n/"]
pub type nvmlUnit_t = *mut nvmlUnit_st;
#[doc = " Description of HWBC entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlHwbcEntry_st {
    pub hwbcId: ::std::os::raw::c_uint,
    pub firmwareVersion: [::std::os::raw::c_char; 32usize],
}
#[doc = " Description of HWBC entry"]
pub type nvmlHwbcEntry_t = nvmlHwbcEntry_st;
#[doc = "!< Fan is working properly"]
pub const nvmlFanState_enum_NVML_FAN_NORMAL: nvmlFanState_enum = 0;
#[doc = "!< Fan has failed"]
pub const nvmlFanState_enum_NVML_FAN_FAILED: nvmlFanState_enum = 1;
#[doc = " Fan state enum."]
pub type nvmlFanState_enum = ::std::os::raw::c_uint;
#[doc = " Fan state enum."]
pub use self::nvmlFanState_enum as nvmlFanState_t;
#[doc = "!< GREEN, indicates good health"]
pub const nvmlLedColor_enum_NVML_LED_COLOR_GREEN: nvmlLedColor_enum = 0;
#[doc = "!< AMBER, indicates problem"]
pub const nvmlLedColor_enum_NVML_LED_COLOR_AMBER: nvmlLedColor_enum = 1;
#[doc = " Led color enum."]
pub type nvmlLedColor_enum = ::std::os::raw::c_uint;
#[doc = " Led color enum."]
pub use self::nvmlLedColor_enum as nvmlLedColor_t;
#[doc = " LED states for an S-class unit."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlLedState_st {
    #[doc = "!< If amber, a text description of the cause"]
    pub cause: [::std::os::raw::c_char; 256usize],
    #[doc = "!< GREEN or AMBER"]
    pub color: nvmlLedColor_t,
}
#[doc = " LED states for an S-class unit."]
pub type nvmlLedState_t = nvmlLedState_st;
#[doc = " Static S-class unit info."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlUnitInfo_st {
    #[doc = "!< Product name"]
    pub name: [::std::os::raw::c_char; 96usize],
    #[doc = "!< Product identifier"]
    pub id: [::std::os::raw::c_char; 96usize],
    #[doc = "!< Product serial number"]
    pub serial: [::std::os::raw::c_char; 96usize],
    #[doc = "!< Firmware version"]
    pub firmwareVersion: [::std::os::raw::c_char; 96usize],
}
#[doc = " Static S-class unit info."]
pub type nvmlUnitInfo_t = nvmlUnitInfo_st;
#[doc = " Power usage information for an S-class unit.\n The power supply state is a human readable string that equals \"Normal\" or contains\n a combination of \"Abnormal\" plus one or more of the following:\n\n    - High voltage\n    - Fan failure\n    - Heatsink temperature\n    - Current limit\n    - Voltage below UV alarm threshold\n    - Low-voltage\n    - SI2C remote off command\n    - MOD_DISABLE input\n    - Short pin transition"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlPSUInfo_st {
    #[doc = "!< The power supply state"]
    pub state: [::std::os::raw::c_char; 256usize],
    #[doc = "!< PSU current (A)"]
    pub current: ::std::os::raw::c_uint,
    #[doc = "!< PSU voltage (V)"]
    pub voltage: ::std::os::raw::c_uint,
    #[doc = "!< PSU power draw (W)"]
    pub power: ::std::os::raw::c_uint,
}
#[doc = " Power usage information for an S-class unit.\n The power supply state is a human readable string that equals \"Normal\" or contains\n a combination of \"Abnormal\" plus one or more of the following:\n\n    - High voltage\n    - Fan failure\n    - Heatsink temperature\n    - Current limit\n    - Voltage below UV alarm threshold\n    - Low-voltage\n    - SI2C remote off command\n    - MOD_DISABLE input\n    - Short pin transition"]
pub type nvmlPSUInfo_t = nvmlPSUInfo_st;
#[doc = " Fan speed reading for a single fan in an S-class unit."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlUnitFanInfo_st {
    #[doc = "!< Fan speed (RPM)"]
    pub speed: ::std::os::raw::c_uint,
    #[doc = "!< Flag that indicates whether fan is working properly"]
    pub state: nvmlFanState_t,
}
#[doc = " Fan speed reading for a single fan in an S-class unit."]
pub type nvmlUnitFanInfo_t = nvmlUnitFanInfo_st;
#[doc = " Fan speed readings for an entire S-class unit."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlUnitFanSpeeds_st {
    #[doc = "!< Fan speed data for each fan"]
    pub fans: [nvmlUnitFanInfo_t; 24usize],
    #[doc = "!< Number of fans in unit"]
    pub count: ::std::os::raw::c_uint,
}
#[doc = " Fan speed readings for an entire S-class unit."]
pub type nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEventSet_st {
    _unused: [u8; 0],
}
#[doc = " Handle to an event set"]
pub type nvmlEventSet_t = *mut nvmlEventSet_st;
#[doc = " Information about occurred event"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlEventData_st {
    #[doc = "!< Specific device where the event occurred"]
    pub device: nvmlDevice_t,
    #[doc = "!< Information about what specific event occurred"]
    pub eventType: ::std::os::raw::c_ulonglong,
    #[doc = "!< Stores XID error for the device in the event of nvmlEventTypeXidCriticalError,"]
    pub eventData: ::std::os::raw::c_ulonglong,
    #[doc = "!< If MIG is enabled and nvmlEventTypeXidCriticalError event is attributable to a GPU"]
    pub gpuInstanceId: ::std::os::raw::c_uint,
    #[doc = "!< If MIG is enabled and nvmlEventTypeXidCriticalError event is attributable to a"]
    pub computeInstanceId: ::std::os::raw::c_uint,
}
#[doc = " Information about occurred event"]
pub type nvmlEventData_t = nvmlEventData_st;
#[doc = " Describes accounting statistics of a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlAccountingStats_st {
    #[doc = "!< Percent of time over the process's lifetime during which one or more kernels was executing on the GPU."]
    pub gpuUtilization: ::std::os::raw::c_uint,
    #[doc = "!< Percent of time over the process's lifetime during which global (device) memory was being read or written."]
    pub memoryUtilization: ::std::os::raw::c_uint,
    #[doc = "!< Maximum total memory in bytes that was ever allocated by the process."]
    pub maxMemoryUsage: ::std::os::raw::c_ulonglong,
    #[doc = "!< Amount of time in ms during which the compute context was active. The time is reported as 0 if\n!< the process is not terminated"]
    pub time: ::std::os::raw::c_ulonglong,
    #[doc = "!< CPU Timestamp in usec representing start time for the process"]
    pub startTime: ::std::os::raw::c_ulonglong,
    #[doc = "!< Flag to represent if the process is running (1 for running, 0 for terminated)"]
    pub isRunning: ::std::os::raw::c_uint,
    #[doc = "!< Reserved for future use"]
    pub reserved: [::std::os::raw::c_uint; 5usize],
}
#[doc = " Describes accounting statistics of a process."]
pub type nvmlAccountingStats_t = nvmlAccountingStats_st;
#[doc = "!< H264 encoder"]
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_H264: nvmlEncoderQueryType_enum = 0;
#[doc = "!< HEVC encoder"]
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_HEVC: nvmlEncoderQueryType_enum = 1;
#[doc = " Represents type of encoder for capacity can be queried"]
pub type nvmlEncoderQueryType_enum = ::std::os::raw::c_uint;
#[doc = " Represents type of encoder for capacity can be queried"]
pub use self::nvmlEncoderQueryType_enum as nvmlEncoderType_t;
#[doc = " Structure to hold encoder session data"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlEncoderSessionInfo_st {
    #[doc = "!< Unique session ID"]
    pub sessionId: ::std::os::raw::c_uint,
    #[doc = "!< Owning process ID"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Owning vGPU instance ID (only valid on vGPU hosts, otherwise zero)"]
    pub vgpuInstance: nvmlVgpuInstance_t,
    #[doc = "!< Video encoder type"]
    pub codecType: nvmlEncoderType_t,
    #[doc = "!< Current encode horizontal resolution"]
    pub hResolution: ::std::os::raw::c_uint,
    #[doc = "!< Current encode vertical resolution"]
    pub vResolution: ::std::os::raw::c_uint,
    #[doc = "!< Moving average encode frames per second"]
    pub averageFps: ::std::os::raw::c_uint,
    #[doc = "!< Moving average encode latency in microseconds"]
    pub averageLatency: ::std::os::raw::c_uint,
}
#[doc = " Structure to hold encoder session data"]
pub type nvmlEncoderSessionInfo_t = nvmlEncoderSessionInfo_st;
#[doc = "!< Unknwon"]
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_UNKNOWN: nvmlFBCSessionType_enum = 0;
#[doc = "!< ToSys"]
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_TOSYS: nvmlFBCSessionType_enum = 1;
#[doc = "!< Cuda"]
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_CUDA: nvmlFBCSessionType_enum = 2;
#[doc = "!< Vid"]
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_VID: nvmlFBCSessionType_enum = 3;
#[doc = "!< HEnc"]
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_HWENC: nvmlFBCSessionType_enum = 4;
#[doc = " Represents frame buffer capture session type"]
pub type nvmlFBCSessionType_enum = ::std::os::raw::c_uint;
#[doc = " Represents frame buffer capture session type"]
pub use self::nvmlFBCSessionType_enum as nvmlFBCSessionType_t;
#[doc = " Structure to hold frame buffer capture sessions stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlFBCStats_st {
    #[doc = "!< Total no of sessions"]
    pub sessionsCount: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frames captured per second"]
    pub averageFPS: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frame capture latency in microseconds"]
    pub averageLatency: ::std::os::raw::c_uint,
}
#[doc = " Structure to hold frame buffer capture sessions stats"]
pub type nvmlFBCStats_t = nvmlFBCStats_st;
#[doc = " Structure to hold FBC session data"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlFBCSessionInfo_st {
    #[doc = "!< Unique session ID"]
    pub sessionId: ::std::os::raw::c_uint,
    #[doc = "!< Owning process ID"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Owning vGPU instance ID (only valid on vGPU hosts, otherwise zero)"]
    pub vgpuInstance: nvmlVgpuInstance_t,
    #[doc = "!< Display identifier"]
    pub displayOrdinal: ::std::os::raw::c_uint,
    #[doc = "!< Type of frame buffer capture session"]
    pub sessionType: nvmlFBCSessionType_t,
    #[doc = "!< Session flags (one or more of NVML_NVFBC_SESSION_FLAG_XXX)."]
    pub sessionFlags: ::std::os::raw::c_uint,
    #[doc = "!< Max horizontal resolution supported by the capture session"]
    pub hMaxResolution: ::std::os::raw::c_uint,
    #[doc = "!< Max vertical resolution supported by the capture session"]
    pub vMaxResolution: ::std::os::raw::c_uint,
    #[doc = "!< Horizontal resolution requested by caller in capture call"]
    pub hResolution: ::std::os::raw::c_uint,
    #[doc = "!< Vertical resolution requested by caller in capture call"]
    pub vResolution: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frames captured per second"]
    pub averageFPS: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frame capture latency in microseconds"]
    pub averageLatency: ::std::os::raw::c_uint,
}
#[doc = " Structure to hold FBC session data"]
pub type nvmlFBCSessionInfo_t = nvmlFBCSessionInfo_st;
pub const nvmlDetachGpuState_enum_NVML_DETACH_GPU_KEEP: nvmlDetachGpuState_enum = 0;
pub const nvmlDetachGpuState_enum_NVML_DETACH_GPU_REMOVE: nvmlDetachGpuState_enum = 1;
#[doc = "  Is the GPU device to be removed from the kernel by nvmlDeviceRemoveGpu()"]
pub type nvmlDetachGpuState_enum = ::std::os::raw::c_uint;
#[doc = "  Is the GPU device to be removed from the kernel by nvmlDeviceRemoveGpu()"]
pub use self::nvmlDetachGpuState_enum as nvmlDetachGpuState_t;
pub const nvmlPcieLinkState_enum_NVML_PCIE_LINK_KEEP: nvmlPcieLinkState_enum = 0;
pub const nvmlPcieLinkState_enum_NVML_PCIE_LINK_SHUT_DOWN: nvmlPcieLinkState_enum = 1;
#[doc = "  Parent bridge PCIe link state requested by nvmlDeviceRemoveGpu()"]
pub type nvmlPcieLinkState_enum = ::std::os::raw::c_uint;
#[doc = "  Parent bridge PCIe link state requested by nvmlDeviceRemoveGpu()"]
pub use self::nvmlPcieLinkState_enum as nvmlPcieLinkState_t;
extern "C" {
    #[doc = " Initialize NVML, but don't initialize any GPUs yet.\n\n \\note nvmlInit_v3 introduces a \"flags\" argument, that allows passing boolean values\n       modifying the behaviour of nvmlInit().\n \\note In NVML 5.319 new nvmlInit_v2 has replaced nvmlInit\"_v1\" (default in NVML 4.304 and older) that\n       did initialize all GPU devices in the system.\n\n This allows NVML to communicate with a GPU\n when other GPUs in the system are unstable or in a bad state.  When using this API, GPUs are\n discovered and initialized in nvmlDeviceGetHandleBy* functions instead.\n\n \\note To contrast nvmlInit_v2 with nvmlInit\"_v1\", NVML 4.304 nvmlInit\"_v1\" will fail when any detected GPU is in\n       a bad or unstable state.\n\n For all products.\n\n This method, should be called once before invoking any other methods in the library.\n A reference count of the number of initializations is maintained.  Shutdown only occurs\n when the reference count reaches zero.\n\n @return\n         - \\ref NVML_SUCCESS                   if NVML has been properly initialized\n         - \\ref NVML_ERROR_DRIVER_NOT_LOADED   if NVIDIA driver is not running\n         - \\ref NVML_ERROR_NO_PERMISSION       if NVML does not have permission to talk to the driver\n         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlInit_v2() -> nvmlReturn_t;
}
extern "C" {
    #[doc = " nvmlInitWithFlags is a variant of nvmlInit(), that allows passing a set of boolean values\n       modifying the behaviour of nvmlInit().\n       Other than the \"flags\" parameter it is completely similar to \\ref nvmlInit_v2.\n\n For all products.\n\n @param flags                                 behaviour modifier flags\n\n @return\n         - \\ref NVML_SUCCESS                   if NVML has been properly initialized\n         - \\ref NVML_ERROR_DRIVER_NOT_LOADED   if NVIDIA driver is not running\n         - \\ref NVML_ERROR_NO_PERMISSION       if NVML does not have permission to talk to the driver\n         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlInitWithFlags(flags: ::std::os::raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Shut down NVML by releasing all GPU resources previously allocated with \\ref nvmlInit_v2().\n\n For all products.\n\n This method should be called after NVML work is done, once for each call to \\ref nvmlInit_v2()\n A reference count of the number of initializations is maintained.  Shutdown only occurs\n when the reference count reaches zero.  For backwards compatibility, no error is reported if\n nvmlShutdown() is called more times than nvmlInit().\n\n @return\n         - \\ref NVML_SUCCESS                 if NVML has been properly shut down\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlShutdown() -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Helper method for converting NVML error codes into readable strings.\n\n For all products.\n\n @param result                               NVML error code to convert\n\n @return String representation of the error.\n"]
    pub fn nvmlErrorString(result: nvmlReturn_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Retrieves the version of the system's graphics driver.\n\n For all products.\n\n The version identifier is an alphanumeric string.  It will not exceed 80 characters in length\n (including the NULL terminator).  See \\ref nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE.\n\n @param version                              Reference in which to return the version identifier\n @param length                               The maximum allowed length of the string returned in \\a version\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a version has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a version is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    pub fn nvmlSystemGetDriverVersion(
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the version of the NVML library.\n\n For all products.\n\n The version identifier is an alphanumeric string.  It will not exceed 80 characters in length\n (including the NULL terminator).  See \\ref nvmlConstants::NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE.\n\n @param version                              Reference in which to return the version identifier\n @param length                               The maximum allowed length of the string returned in \\a version\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a version has been set\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a version is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    pub fn nvmlSystemGetNVMLVersion(
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the version of the CUDA driver.\n\n For all products.\n\n The CUDA driver version returned will be retreived from the currently installed version of CUDA.\n If the cuda library is not found, this function will return a known supported version number.\n\n @param cudaDriverVersion                    Reference in which to return the version identifier\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a cudaDriverVersion has been set\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a cudaDriverVersion is NULL"]
    pub fn nvmlSystemGetCudaDriverVersion(
        cudaDriverVersion: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the version of the CUDA driver from the shared library.\n\n For all products.\n\n The returned CUDA driver version by calling cuDriverGetVersion()\n\n @param cudaDriverVersion                    Reference in which to return the version identifier\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a cudaDriverVersion has been set\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a cudaDriverVersion is NULL\n         - \\ref NVML_ERROR_LIBRARY_NOT_FOUND  if \\a libcuda.so.1 or libcuda.dll is not found\n         - \\ref NVML_ERROR_FUNCTION_NOT_FOUND if \\a cuDriverGetVersion() is not found in the shared library"]
    pub fn nvmlSystemGetCudaDriverVersion_v2(
        cudaDriverVersion: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets name of the process with provided process id\n\n For all products.\n\n Returned process name is cropped to provided length.\n name string is encoded in ANSI.\n\n @param pid                                  The identifier of the process\n @param name                                 Reference in which to return the process name\n @param length                               The maximum allowed length of the string returned in \\a name\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a name has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a name is NULL or \\a length is 0.\n         - \\ref NVML_ERROR_NOT_FOUND         if process doesn't exists\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlSystemGetProcessName(
        pid: ::std::os::raw::c_uint,
        name: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the number of units in the system.\n\n For S-class products.\n\n @param unitCount                            Reference in which to return the number of units\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a unitCount has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unitCount is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetCount(unitCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Acquire the handle for a particular unit, based on its index.\n\n For S-class products.\n\n Valid indices are derived from the \\a unitCount returned by \\ref nvmlUnitGetCount().\n   For example, if \\a unitCount is 2 the valid indices are 0 and 1, corresponding to UNIT 0 and UNIT 1.\n\n The order in which NVML enumerates units has no guarantees of consistency between reboots.\n\n @param index                                The index of the target unit, >= 0 and < \\a unitCount\n @param unit                                 Reference in which to return the unit handle\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a unit has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a index is invalid or \\a unit is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetHandleByIndex(
        index: ::std::os::raw::c_uint,
        unit: *mut nvmlUnit_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the static information associated with a unit.\n\n For S-class products.\n\n See \\ref nvmlUnitInfo_t for details on available unit info.\n\n @param unit                                 The identifier of the target unit\n @param info                                 Reference in which to return the unit information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a info has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit is invalid or \\a info is NULL"]
    pub fn nvmlUnitGetUnitInfo(unit: nvmlUnit_t, info: *mut nvmlUnitInfo_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the LED state associated with this unit.\n\n For S-class products.\n\n See \\ref nvmlLedState_t for details on allowed states.\n\n @param unit                                 The identifier of the target unit\n @param state                                Reference in which to return the current LED state\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a state has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit is invalid or \\a state is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlUnitSetLedState()"]
    pub fn nvmlUnitGetLedState(unit: nvmlUnit_t, state: *mut nvmlLedState_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the PSU stats for the unit.\n\n For S-class products.\n\n See \\ref nvmlPSUInfo_t for details on available PSU info.\n\n @param unit                                 The identifier of the target unit\n @param psu                                  Reference in which to return the PSU information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a psu has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit is invalid or \\a psu is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetPsuInfo(unit: nvmlUnit_t, psu: *mut nvmlPSUInfo_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the temperature readings for the unit, in degrees C.\n\n For S-class products.\n\n Depending on the product, readings may be available for intake (type=0),\n exhaust (type=1) and board (type=2).\n\n @param unit                                 The identifier of the target unit\n @param type                                 The type of reading to take\n @param temp                                 Reference in which to return the intake temperature\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a temp has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit or \\a type is invalid or \\a temp is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetTemperature(
        unit: nvmlUnit_t,
        type_: ::std::os::raw::c_uint,
        temp: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the fan speed readings for the unit.\n\n For S-class products.\n\n See \\ref nvmlUnitFanSpeeds_t for details on available fan speed info.\n\n @param unit                                 The identifier of the target unit\n @param fanSpeeds                            Reference in which to return the fan speed information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a fanSpeeds has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit is invalid or \\a fanSpeeds is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetFanSpeedInfo(
        unit: nvmlUnit_t,
        fanSpeeds: *mut nvmlUnitFanSpeeds_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the set of GPU devices that are attached to the specified unit.\n\n For S-class products.\n\n The \\a deviceCount argument is expected to be set to the size of the input \\a devices array.\n\n @param unit                                 The identifier of the target unit\n @param deviceCount                          Reference in which to provide the \\a devices array size, and\n                                             to return the number of attached GPU devices\n @param devices                              Reference in which to return the references to the attached GPU devices\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a deviceCount and \\a devices have been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a deviceCount indicates that the \\a devices array is too small\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit is invalid, either of \\a deviceCount or \\a devices is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetDevices(
        unit: nvmlUnit_t,
        deviceCount: *mut ::std::os::raw::c_uint,
        devices: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the IDs and firmware versions for any Host Interface Cards (HICs) in the system.\n\n For S-class products.\n\n The \\a hwbcCount argument is expected to be set to the size of the input \\a hwbcEntries array.\n The HIC must be connected to an S-class system for it to be reported by this function.\n\n @param hwbcCount                            Size of hwbcEntries array\n @param hwbcEntries                          Array holding information about hwbc\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a hwbcCount and \\a hwbcEntries have been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if either \\a hwbcCount or \\a hwbcEntries is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a hwbcCount indicates that the \\a hwbcEntries array is too small"]
    pub fn nvmlSystemGetHicVersion(
        hwbcCount: *mut ::std::os::raw::c_uint,
        hwbcEntries: *mut nvmlHwbcEntry_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the number of compute devices in the system. A compute device is a single GPU.\n\n For all products.\n\n Note: New nvmlDeviceGetCount_v2 (default in NVML 5.319) returns count of all devices in the system\n       even if nvmlDeviceGetHandleByIndex_v2 returns NVML_ERROR_NO_PERMISSION for such device.\n       Update your code to handle this error, or use NVML 4.304 or older nvml header file.\n       For backward binary compatibility reasons _v1 version of the API is still present in the shared\n       library.\n       Old _v1 version of nvmlDeviceGetCount doesn't count devices that NVML has no permission to talk to.\n\n @param deviceCount                          Reference in which to return the number of accessible devices\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a deviceCount has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a deviceCount is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetCount_v2(deviceCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get attributes (engine counts etc.) for the given NVML device handle.\n\n @note This API currently only supports MIG device handles.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               NVML device handle\n @param attributes                           Device attributes\n\n @return\n        - \\ref NVML_SUCCESS                  if \\a device attributes were successfully retrieved\n        - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device handle is invalid\n        - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n        - \\ref NVML_ERROR_NOT_SUPPORTED      if this query is not supported by the device\n        - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetAttributes_v2(
        device: nvmlDevice_t,
        attributes: *mut nvmlDeviceAttributes_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Acquire the handle for a particular device, based on its index.\n\n For all products.\n\n Valid indices are derived from the \\a accessibleDevices count returned by\n   \\ref nvmlDeviceGetCount_v2(). For example, if \\a accessibleDevices is 2 the valid indices\n   are 0 and 1, corresponding to GPU 0 and GPU 1.\n\n The order in which NVML enumerates devices has no guarantees of consistency between reboots. For that reason it\n   is recommended that devices be looked up by their PCI ids or UUID. See\n   \\ref nvmlDeviceGetHandleByUUID() and \\ref nvmlDeviceGetHandleByPciBusId_v2().\n\n Note: The NVML index may not correlate with other APIs, such as the CUDA device index.\n\n Starting from NVML 5, this API causes NVML to initialize the target GPU\n NVML may initialize additional GPUs if:\n  - The target GPU is an SLI slave\n\n Note: New nvmlDeviceGetCount_v2 (default in NVML 5.319) returns count of all devices in the system\n       even if nvmlDeviceGetHandleByIndex_v2 returns NVML_ERROR_NO_PERMISSION for such device.\n       Update your code to handle this error, or use NVML 4.304 or older nvml header file.\n       For backward binary compatibility reasons _v1 version of the API is still present in the shared\n       library.\n       Old _v1 version of nvmlDeviceGetCount doesn't count devices that NVML has no permission to talk to.\n\n       This means that nvmlDeviceGetHandleByIndex_v2 and _v1 can return different devices for the same index.\n       If you don't touch macros that map old (_v1) versions to _v2 versions at the top of the file you don't\n       need to worry about that.\n\n @param index                                The index of the target GPU, >= 0 and < \\a accessibleDevices\n @param device                               Reference in which to return the device handle\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a device has been set\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a index is invalid or \\a device is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_POWER if any attached devices have improperly attached external power cables\n         - \\ref NVML_ERROR_NO_PERMISSION      if the user doesn't have permission to talk to this device\n         - \\ref NVML_ERROR_IRQ_ISSUE          if NVIDIA kernel detected an interrupt issue with the attached GPUs\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error\n\n @see nvmlDeviceGetIndex\n @see nvmlDeviceGetCount"]
    pub fn nvmlDeviceGetHandleByIndex_v2(
        index: ::std::os::raw::c_uint,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Acquire the handle for a particular device, based on its board serial number.\n\n For Fermi &tm; or newer fully supported devices.\n\n This number corresponds to the value printed directly on the board, and to the value returned by\n   \\ref nvmlDeviceGetSerial().\n\n @deprecated Since more than one GPU can exist on a single board this function is deprecated in favor\n             of \\ref nvmlDeviceGetHandleByUUID.\n             For dual GPU boards this function will return NVML_ERROR_INVALID_ARGUMENT.\n\n Starting from NVML 5, this API causes NVML to initialize the target GPU\n NVML may initialize additional GPUs as it searches for the target GPU\n\n @param serial                               The board serial number of the target GPU\n @param device                               Reference in which to return the device handle\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a device has been set\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a serial is invalid, \\a device is NULL or more than one\n                                              device has the same serial (dual GPU boards)\n         - \\ref NVML_ERROR_NOT_FOUND          if \\a serial does not match a valid device on the system\n         - \\ref NVML_ERROR_INSUFFICIENT_POWER if any attached devices have improperly attached external power cables\n         - \\ref NVML_ERROR_IRQ_ISSUE          if NVIDIA kernel detected an interrupt issue with the attached GPUs\n         - \\ref NVML_ERROR_GPU_IS_LOST        if any GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error\n\n @see nvmlDeviceGetSerial\n @see nvmlDeviceGetHandleByUUID"]
    pub fn nvmlDeviceGetHandleBySerial(
        serial: *const ::std::os::raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Acquire the handle for a particular device, based on its globally unique immutable UUID associated with each device.\n\n For all products.\n\n @param uuid                                 The UUID of the target GPU or MIG instance\n @param device                               Reference in which to return the device handle or MIG device handle\n\n Starting from NVML 5, this API causes NVML to initialize the target GPU\n NVML may initialize additional GPUs as it searches for the target GPU\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a device has been set\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a uuid is invalid or \\a device is null\n         - \\ref NVML_ERROR_NOT_FOUND          if \\a uuid does not match a valid device on the system\n         - \\ref NVML_ERROR_INSUFFICIENT_POWER if any attached devices have improperly attached external power cables\n         - \\ref NVML_ERROR_IRQ_ISSUE          if NVIDIA kernel detected an interrupt issue with the attached GPUs\n         - \\ref NVML_ERROR_GPU_IS_LOST        if any GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error\n\n @see nvmlDeviceGetUUID"]
    pub fn nvmlDeviceGetHandleByUUID(
        uuid: *const ::std::os::raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Acquire the handle for a particular device, based on its PCI bus id.\n\n For all products.\n\n This value corresponds to the nvmlPciInfo_t::busId returned by \\ref nvmlDeviceGetPciInfo_v3().\n\n Starting from NVML 5, this API causes NVML to initialize the target GPU\n NVML may initialize additional GPUs if:\n  - The target GPU is an SLI slave\n\n \\note NVML 4.304 and older version of nvmlDeviceGetHandleByPciBusId\"_v1\" returns NVML_ERROR_NOT_FOUND\n       instead of NVML_ERROR_NO_PERMISSION.\n\n @param pciBusId                             The PCI bus id of the target GPU\n @param device                               Reference in which to return the device handle\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a device has been set\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a pciBusId is invalid or \\a device is NULL\n         - \\ref NVML_ERROR_NOT_FOUND          if \\a pciBusId does not match a valid device on the system\n         - \\ref NVML_ERROR_INSUFFICIENT_POWER if the attached device has improperly attached external power cables\n         - \\ref NVML_ERROR_NO_PERMISSION      if the user doesn't have permission to talk to this device\n         - \\ref NVML_ERROR_IRQ_ISSUE          if NVIDIA kernel detected an interrupt issue with the attached GPUs\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetHandleByPciBusId_v2(
        pciBusId: *const ::std::os::raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the name of this device.\n\n For all products.\n\n The name is an alphanumeric string that denotes a particular product, e.g. Tesla &tm; C2070. It will not\n exceed 96 characters in length (including the NULL terminator).  See \\ref\n nvmlConstants::NVML_DEVICE_NAME_V2_BUFFER_SIZE.\n\n When used with MIG device handles the API returns MIG device names which can be used to identify devices\n based on their attributes.\n\n @param device                               The identifier of the target device\n @param name                                 Reference in which to return the product name\n @param length                               The maximum allowed length of the string returned in \\a name\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a name has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a name is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetName(
        device: nvmlDevice_t,
        name: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the brand of this device.\n\n For all products.\n\n The type is a member of \\ref nvmlBrandType_t defined above.\n\n @param device                               The identifier of the target device\n @param type                                 Reference in which to return the product brand type\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a name has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a type is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetBrand(device: nvmlDevice_t, type_: *mut nvmlBrandType_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the NVML index of this device.\n\n For all products.\n\n Valid indices are derived from the \\a accessibleDevices count returned by\n   \\ref nvmlDeviceGetCount_v2(). For example, if \\a accessibleDevices is 2 the valid indices\n   are 0 and 1, corresponding to GPU 0 and GPU 1.\n\n The order in which NVML enumerates devices has no guarantees of consistency between reboots. For that reason it\n   is recommended that devices be looked up by their PCI ids or GPU UUID. See\n   \\ref nvmlDeviceGetHandleByPciBusId_v2() and \\ref nvmlDeviceGetHandleByUUID().\n\n When used with MIG device handles this API returns indices that can be\n passed to \\ref nvmlDeviceGetMigDeviceHandleByIndex to retrieve an identical handle.\n MIG device indices are unique within a device.\n\n Note: The NVML index may not correlate with other APIs, such as the CUDA device index.\n\n @param device                               The identifier of the target device\n @param index                                Reference in which to return the NVML index of the device\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a index has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a index is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetHandleByIndex()\n @see nvmlDeviceGetCount()"]
    pub fn nvmlDeviceGetIndex(
        device: nvmlDevice_t,
        index: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the globally unique board serial number associated with this device's board.\n\n For all products with an inforom.\n\n The serial number is an alphanumeric string that will not exceed 30 characters (including the NULL terminator).\n This number matches the serial number tag that is physically attached to the board.  See \\ref\n nvmlConstants::NVML_DEVICE_SERIAL_BUFFER_SIZE.\n\n @param device                               The identifier of the target device\n @param serial                               Reference in which to return the board/module serial number\n @param length                               The maximum allowed length of the string returned in \\a serial\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a serial has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a serial is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetSerial(
        device: nvmlDevice_t,
        serial: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
pub type nvmlAffinityScope_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Retrieves an array of unsigned ints (sized to nodeSetSize) of bitmasks with\n the ideal memory affinity within node or socket for the device.\n For example, if NUMA node 0, 1 are ideal within the socket for the device and nodeSetSize ==  1,\n     result[0] = 0x3\n\n \\note If requested scope is not applicable to the target topology, the API\n       will fall back to reporting the memory affinity for the immediate non-I/O\n       ancestor of the device.\n\n For Kepler &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               The identifier of the target device\n @param nodeSetSize                          The size of the nodeSet array that is safe to access\n @param nodeSet                              Array reference in which to return a bitmask of NODEs, 64 NODEs per\n                                             unsigned long on 64-bit machines, 32 on 32-bit machines\n @param scope                                Scope that change the default behavior\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a NUMA node Affinity has been filled\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, nodeSetSize == 0, nodeSet is NULL or scope is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMemoryAffinity(
        device: nvmlDevice_t,
        nodeSetSize: ::std::os::raw::c_uint,
        nodeSet: *mut ::std::os::raw::c_ulong,
        scope: nvmlAffinityScope_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves an array of unsigned ints (sized to cpuSetSize) of bitmasks with the\n ideal CPU affinity within node or socket for the device.\n For example, if processors 0, 1, 32, and 33 are ideal for the device and cpuSetSize == 2,\n     result[0] = 0x3, result[1] = 0x3\n\n \\note If requested scope is not applicable to the target topology, the API\n       will fall back to reporting the CPU affinity for the immediate non-I/O\n       ancestor of the device.\n\n For Kepler &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               The identifier of the target device\n @param cpuSetSize                           The size of the cpuSet array that is safe to access\n @param cpuSet                               Array reference in which to return a bitmask of CPUs, 64 CPUs per\n                                                 unsigned long on 64-bit machines, 32 on 32-bit machines\n @param scope                                Scope that change the default behavior\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a cpuAffinity has been filled\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, cpuSetSize == 0, cpuSet is NULL or sope is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetCpuAffinityWithinScope(
        device: nvmlDevice_t,
        cpuSetSize: ::std::os::raw::c_uint,
        cpuSet: *mut ::std::os::raw::c_ulong,
        scope: nvmlAffinityScope_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves an array of unsigned ints (sized to cpuSetSize) of bitmasks with the ideal CPU affinity for the device\n For example, if processors 0, 1, 32, and 33 are ideal for the device and cpuSetSize == 2,\n     result[0] = 0x3, result[1] = 0x3\n This is equivalent to calling \\ref nvmlDeviceGetCpuAffinityWithinScope with \\ref NVML_AFFINITY_SCOPE_NODE.\n\n For Kepler &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               The identifier of the target device\n @param cpuSetSize                           The size of the cpuSet array that is safe to access\n @param cpuSet                               Array reference in which to return a bitmask of CPUs, 64 CPUs per\n                                                 unsigned long on 64-bit machines, 32 on 32-bit machines\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a cpuAffinity has been filled\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, cpuSetSize == 0, or cpuSet is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetCpuAffinity(
        device: nvmlDevice_t,
        cpuSetSize: ::std::os::raw::c_uint,
        cpuSet: *mut ::std::os::raw::c_ulong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Sets the ideal affinity for the calling thread and device using the guidelines\n given in nvmlDeviceGetCpuAffinity().  Note, this is a change as of version 8.0.\n Older versions set the affinity for a calling process and all children.\n Currently supports up to 1024 processors.\n\n For Kepler &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               The identifier of the target device\n\n @return\n         - \\ref NVML_SUCCESS                 if the calling process has been successfully bound\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Clear all affinity bindings for the calling thread.  Note, this is a change as of version\n 8.0 as older versions cleared the affinity for a calling process and all children.\n\n For Kepler &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               The identifier of the target device\n\n @return\n         - \\ref NVML_SUCCESS                 if the calling process has been successfully unbound\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceClearCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " @}"]
    pub fn nvmlDeviceGetTopologyCommonAncestor(
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        pathInfo: *mut nvmlGpuTopologyLevel_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the set of GPUs that are nearest to a given device at a specific interconnectivity level\n For all products.\n Supported on Linux only.\n\n @param device                               The identifier of the first device\n @param level                                The \\ref nvmlGpuTopologyLevel_t level to search for other GPUs\n @param count                                When zero, is set to the number of matching GPUs such that \\a deviceArray\n                                             can be malloc'd.  When non-zero, \\a deviceArray will be filled with \\a count\n                                             number of device handles.\n @param deviceArray                          An array of device handles for GPUs found at \\a level\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a deviceArray or \\a count (if initially zero) has been set\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a level, or \\a count is invalid, or \\a deviceArray is NULL with a non-zero \\a count\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature\n         - \\ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery"]
    pub fn nvmlDeviceGetTopologyNearestGpus(
        device: nvmlDevice_t,
        level: nvmlGpuTopologyLevel_t,
        count: *mut ::std::os::raw::c_uint,
        deviceArray: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the set of GPUs that have a CPU affinity with the given CPU number\n For all products.\n Supported on Linux only.\n\n @param cpuNumber                            The CPU number\n @param count                                When zero, is set to the number of matching GPUs such that \\a deviceArray\n                                             can be malloc'd.  When non-zero, \\a deviceArray will be filled with \\a count\n                                             number of device handles.\n @param deviceArray                          An array of device handles for GPUs found with affinity to \\a cpuNumber\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a deviceArray or \\a count (if initially zero) has been set\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a cpuNumber, or \\a count is invalid, or \\a deviceArray is NULL with a non-zero \\a count\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature\n         - \\ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery"]
    pub fn nvmlSystemGetTopologyGpuSet(
        cpuNumber: ::std::os::raw::c_uint,
        count: *mut ::std::os::raw::c_uint,
        deviceArray: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the status for a given p2p capability index between a given pair of GPU\n\n @param device1                              The first device\n @param device2                              The second device\n @param p2pIndex                             p2p Capability Index being looked for between \\a device1 and \\a device2\n @param p2pStatus                            Reference in which to return the status of the \\a p2pIndex\n                                             between \\a device1 and \\a device2\n @return\n         - \\ref NVML_SUCCESS         if \\a p2pStatus has been populated\n         - \\ref NVML_ERROR_INVALID_ARGUMENT     if \\a device1 or \\a device2 or \\a p2pIndex is invalid or \\a p2pStatus is NULL\n         - \\ref NVML_ERROR_UNKNOWN              on any unexpected error"]
    pub fn nvmlDeviceGetP2PStatus(
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        p2pIndex: nvmlGpuP2PCapsIndex_t,
        p2pStatus: *mut nvmlGpuP2PStatus_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the globally unique immutable UUID associated with this device, as a 5 part hexadecimal string,\n that augments the immutable, board serial identifier.\n\n For all products.\n\n The UUID is a globally unique identifier. It is the only available identifier for pre-Fermi-architecture products.\n It does NOT correspond to any identifier printed on the board.  It will not exceed 96 characters in length\n (including the NULL terminator).  See \\ref nvmlConstants::NVML_DEVICE_UUID_V2_BUFFER_SIZE.\n\n When used with MIG device handles the API returns globally unique UUIDs which can be used to identify MIG\n devices across both GPU and MIG devices. UUIDs are immutable for the lifetime of a MIG device.\n\n @param device                               The identifier of the target device\n @param uuid                                 Reference in which to return the GPU UUID\n @param length                               The maximum allowed length of the string returned in \\a uuid\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a uuid has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a uuid is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetUUID(
        device: nvmlDevice_t,
        uuid: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the MDEV UUID of a vGPU instance.\n\n The MDEV UUID is a globally unique identifier of the mdev device assigned to the VM, and is returned as a 5-part hexadecimal string,\n not exceeding 80 characters in length (including the NULL terminator).\n MDEV UUID is displayed only on KVM platform.\n See \\ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param vgpuInstance             Identifier of the target vGPU instance\n @param mdevUuid                 Pointer to caller-supplied buffer to hold MDEV UUID\n @param size                     Size of buffer in bytes\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_NOT_SUPPORTED     on any hypervisor other than KVM\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a mdevUuid is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a size is too small\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetMdevUUID(
        vgpuInstance: nvmlVgpuInstance_t,
        mdevUuid: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves minor number for the device. The minor number for the device is such that the Nvidia device node file for\n each GPU will have the form /dev/nvidia[minor number].\n\n For all products.\n Supported only for Linux\n\n @param device                                The identifier of the target device\n @param minorNumber                           Reference in which to return the minor number for the device\n @return\n         - \\ref NVML_SUCCESS                 if the minor number is successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a minorNumber is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMinorNumber(
        device: nvmlDevice_t,
        minorNumber: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the the device board part number which is programmed into the board's InfoROM\n\n For all products.\n\n @param device                                Identifier of the target device\n @param partNumber                            Reference to the buffer to return\n @param length                                Length of the buffer reference\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a partNumber has been set\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_NOT_SUPPORTED      if the needed VBIOS fields have not been filled\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device is invalid or \\a serial is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetBoardPartNumber(
        device: nvmlDevice_t,
        partNumber: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the version information for the device's infoROM object.\n\n For all products with an inforom.\n\n Fermi and higher parts have non-volatile on-board memory for persisting device info, such as aggregate\n ECC counts. The version of the data structures in this memory may change from time to time. It will not\n exceed 16 characters in length (including the NULL terminator).\n See \\ref nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE.\n\n See \\ref nvmlInforomObject_t for details on the available infoROM objects.\n\n @param device                               The identifier of the target device\n @param object                               The target infoROM object\n @param version                              Reference in which to return the infoROM version\n @param length                               The maximum allowed length of the string returned in \\a version\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a version has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a version is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetInforomImageVersion"]
    pub fn nvmlDeviceGetInforomVersion(
        device: nvmlDevice_t,
        object: nvmlInforomObject_t,
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the global infoROM image version\n\n For all products with an inforom.\n\n Image version just like VBIOS version uniquely describes the exact version of the infoROM flashed on the board\n in contrast to infoROM object version which is only an indicator of supported features.\n Version string will not exceed 16 characters in length (including the NULL terminator).\n See \\ref nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE.\n\n @param device                               The identifier of the target device\n @param version                              Reference in which to return the infoROM image version\n @param length                               The maximum allowed length of the string returned in \\a version\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a version has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a version is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetInforomVersion"]
    pub fn nvmlDeviceGetInforomImageVersion(
        device: nvmlDevice_t,
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the checksum of the configuration stored in the device's infoROM.\n\n For all products with an inforom.\n\n Can be used to make sure that two GPUs have the exact same configuration.\n Current checksum takes into account configuration stored in PWR and ECC infoROM objects.\n Checksum can change between driver releases or when user changes configuration (e.g. disable/enable ECC)\n\n @param device                               The identifier of the target device\n @param checksum                             Reference in which to return the infoROM configuration checksum\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a checksum has been set\n         - \\ref NVML_ERROR_CORRUPTED_INFOROM if the device's checksum couldn't be retrieved due to infoROM corruption\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a checksum is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetInforomConfigurationChecksum(
        device: nvmlDevice_t,
        checksum: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Reads the infoROM from the flash and verifies the checksums.\n\n For all products with an inforom.\n\n @param device                               The identifier of the target device\n\n @return\n         - \\ref NVML_SUCCESS                 if infoROM is not corrupted\n         - \\ref NVML_ERROR_CORRUPTED_INFOROM if the device's infoROM is corrupted\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceValidateInforom(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the display mode for the device.\n\n For all products.\n\n This method indicates whether a physical display (e.g. monitor) is currently connected to\n any of the device's connectors.\n\n See \\ref nvmlEnableState_t for details on allowed modes.\n\n @param device                               The identifier of the target device\n @param display                              Reference in which to return the display mode\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a display has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a display is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetDisplayMode(
        device: nvmlDevice_t,
        display: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the display active state for the device.\n\n For all products.\n\n This method indicates whether a display is initialized on the device.\n For example whether X Server is attached to this device and has allocated memory for the screen.\n\n Display can be active even when no monitor is physically attached.\n\n See \\ref nvmlEnableState_t for details on allowed modes.\n\n @param device                               The identifier of the target device\n @param isActive                             Reference in which to return the display active state\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a isActive has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a isActive is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetDisplayActive(
        device: nvmlDevice_t,
        isActive: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the persistence mode associated with this device.\n\n For all products.\n For Linux only.\n\n When driver persistence mode is enabled the driver software state is not torn down when the last\n client disconnects. By default this feature is disabled.\n\n See \\ref nvmlEnableState_t for details on allowed modes.\n\n @param device                               The identifier of the target device\n @param mode                                 Reference in which to return the current driver persistence mode\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a mode has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceSetPersistenceMode()"]
    pub fn nvmlDeviceGetPersistenceMode(
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the PCI attributes of this device.\n\n For all products.\n\n See \\ref nvmlPciInfo_t for details on the available PCI info.\n\n @param device                               The identifier of the target device\n @param pci                                  Reference in which to return the PCI info\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a pci has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a pci is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPciInfo_v3(device: nvmlDevice_t, pci: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the maximum PCIe link generation possible with this device and system\n\n I.E. for a generation 2 PCIe device attached to a generation 1 PCIe bus the max link generation this function will\n report is generation 1.\n\n For Fermi &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param maxLinkGen                           Reference in which to return the max PCIe link generation\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a maxLinkGen has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a maxLinkGen is null\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMaxPcieLinkGeneration(
        device: nvmlDevice_t,
        maxLinkGen: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the maximum PCIe link width possible with this device and system\n\n I.E. for a device with a 16x PCIe bus width attached to a 8x PCIe system bus this function will report\n a max link width of 8.\n\n For Fermi &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param maxLinkWidth                         Reference in which to return the max PCIe link generation\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a maxLinkWidth has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a maxLinkWidth is null\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMaxPcieLinkWidth(
        device: nvmlDevice_t,
        maxLinkWidth: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current PCIe link generation\n\n For Fermi &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param currLinkGen                          Reference in which to return the current PCIe link generation\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a currLinkGen has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a currLinkGen is null\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetCurrPcieLinkGeneration(
        device: nvmlDevice_t,
        currLinkGen: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current PCIe link width\n\n For Fermi &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param currLinkWidth                        Reference in which to return the current PCIe link generation\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a currLinkWidth has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a currLinkWidth is null\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetCurrPcieLinkWidth(
        device: nvmlDevice_t,
        currLinkWidth: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve PCIe utilization information.\n This function is querying a byte counter over a 20ms interval and thus is the\n   PCIe throughput over that interval.\n\n For Maxwell &tm; or newer fully supported devices.\n\n This method is not supported in virtual machines running virtual GPU (vGPU).\n\n @param device                               The identifier of the target device\n @param counter                              The specific counter that should be queried \\ref nvmlPcieUtilCounter_t\n @param value                                Reference in which to return throughput in KB/s\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a value has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a counter is invalid, or \\a value is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPcieThroughput(
        device: nvmlDevice_t,
        counter: nvmlPcieUtilCounter_t,
        value: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the PCIe replay counter.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param value                                Reference in which to return the counter's value\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a value has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a value is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPcieReplayCounter(
        device: nvmlDevice_t,
        value: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current clock speeds for the device.\n\n For Fermi &tm; or newer fully supported devices.\n\n See \\ref nvmlClockType_t for details on available clock information.\n\n @param device                               The identifier of the target device\n @param type                                 Identify which clock domain to query\n @param clock                                Reference in which to return the clock speed in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a clock has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clock is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetClockInfo(
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        clock: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the maximum clock speeds for the device.\n\n For Fermi &tm; or newer fully supported devices.\n\n See \\ref nvmlClockType_t for details on available clock information.\n\n \\note On GPUs from Fermi family current P0 clocks (reported by \\ref nvmlDeviceGetClockInfo) can differ from max clocks\n       by few MHz.\n\n @param device                               The identifier of the target device\n @param type                                 Identify which clock domain to query\n @param clock                                Reference in which to return the clock speed in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a clock has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clock is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMaxClockInfo(
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        clock: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current setting of a clock that applications will use unless an overspec situation occurs.\n Can be changed using \\ref nvmlDeviceSetApplicationsClocks.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param clockType                            Identify which clock domain to query\n @param clockMHz                             Reference in which to return the clock in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a clockMHz has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clockMHz is NULL or \\a clockType is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetApplicationsClock(
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the default applications clock that GPU boots with or\n defaults to after \\ref nvmlDeviceResetApplicationsClocks call.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param clockType                            Identify which clock domain to query\n @param clockMHz                             Reference in which to return the default clock in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a clockMHz has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clockMHz is NULL or \\a clockType is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n \\see nvmlDeviceGetApplicationsClock"]
    pub fn nvmlDeviceGetDefaultApplicationsClock(
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Resets the application clock to the default value\n\n This is the applications clock that will be used after system reboot or driver reload.\n Default value is constant, but the current value an be changed using \\ref nvmlDeviceSetApplicationsClocks.\n\n On Pascal and newer hardware, if clocks were previously locked with \\ref nvmlDeviceSetApplicationsClocks,\n this call will unlock clocks. This returns clocks their default behavior ofautomatically boosting above\n base clocks as thermal limits allow.\n\n @see nvmlDeviceGetApplicationsClock\n @see nvmlDeviceSetApplicationsClocks\n\n For Fermi &tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.\n\n @param device                               The identifier of the target device\n\n @return\n         - \\ref NVML_SUCCESS                 if new settings were successfully set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceResetApplicationsClocks(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the clock speed for the clock specified by the clock type and clock ID.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param clockType                            Identify which clock domain to query\n @param clockId                              Identify which clock in the domain to query\n @param clockMHz                             Reference in which to return the clock in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a clockMHz has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clockMHz is NULL or \\a clockType is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetClock(
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockId: nvmlClockId_t,
        clockMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the customer defined maximum boost clock speed specified by the given clock type.\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param clockType                            Identify which clock domain to query\n @param clockMHz                             Reference in which to return the clock in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a clockMHz has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clockMHz is NULL or \\a clockType is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device or the \\a clockType on this device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMaxCustomerBoostClock(
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the list of possible memory clocks that can be used as an argument for \\ref nvmlDeviceSetApplicationsClocks.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param count                                Reference in which to provide the \\a clocksMHz array size, and\n                                             to return the number of elements\n @param clocksMHz                            Reference in which to return the clock in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a count and \\a clocksMHz have been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a count is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a count is too small (\\a count is set to the number of\n                                                required elements)\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceSetApplicationsClocks\n @see nvmlDeviceGetSupportedGraphicsClocks"]
    pub fn nvmlDeviceGetSupportedMemoryClocks(
        device: nvmlDevice_t,
        count: *mut ::std::os::raw::c_uint,
        clocksMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the list of possible graphics clocks that can be used as an argument for \\ref nvmlDeviceSetApplicationsClocks.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param memoryClockMHz                       Memory clock for which to return possible graphics clocks\n @param count                                Reference in which to provide the \\a clocksMHz array size, and\n                                             to return the number of elements\n @param clocksMHz                            Reference in which to return the clocks in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a count and \\a clocksMHz have been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_NOT_FOUND         if the specified \\a memoryClockMHz is not a supported frequency\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clock is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a count is too small\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceSetApplicationsClocks\n @see nvmlDeviceGetSupportedMemoryClocks"]
    pub fn nvmlDeviceGetSupportedGraphicsClocks(
        device: nvmlDevice_t,
        memoryClockMHz: ::std::os::raw::c_uint,
        count: *mut ::std::os::raw::c_uint,
        clocksMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the current state of Auto Boosted clocks on a device and store it in \\a isEnabled\n\n For Kepler &tm; or newer fully supported devices.\n\n Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates\n to maximize performance as thermal limits allow.\n\n On Pascal and newer hardware, Auto Aoosted clocks are controlled through application clocks.\n Use \\ref nvmlDeviceSetApplicationsClocks and \\ref nvmlDeviceResetApplicationsClocks to control Auto Boost\n behavior.\n\n @param device                               The identifier of the target device\n @param isEnabled                            Where to store the current state of Auto Boosted clocks of the target device\n @param defaultIsEnabled                     Where to store the default Auto Boosted clocks behavior of the target device that the device will\n                                                 revert to when no applications are using the GPU\n\n @return\n         - \\ref NVML_SUCCESS                 If \\a isEnabled has been been set with the Auto Boosted clocks state of \\a device\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a isEnabled is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n"]
    pub fn nvmlDeviceGetAutoBoostedClocksEnabled(
        device: nvmlDevice_t,
        isEnabled: *mut nvmlEnableState_t,
        defaultIsEnabled: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Try to set the current state of Auto Boosted clocks on a device.\n\n For Kepler &tm; or newer fully supported devices.\n\n Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates\n to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock\n rates are desired.\n\n Non-root users may use this API by default but can be restricted by root from using this API by calling\n \\ref nvmlDeviceSetAPIRestriction with apiType=NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS.\n Note: Persistence Mode is required to modify current Auto Boost settings, therefore, it must be enabled.\n\n On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks.\n Use \\ref nvmlDeviceSetApplicationsClocks and \\ref nvmlDeviceResetApplicationsClocks to control Auto Boost\n behavior.\n\n @param device                               The identifier of the target device\n @param enabled                              What state to try to set Auto Boosted clocks of the target device to\n\n @return\n         - \\ref NVML_SUCCESS                 If the Auto Boosted clocks were successfully set to the state specified by \\a enabled\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n"]
    pub fn nvmlDeviceSetAutoBoostedClocksEnabled(
        device: nvmlDevice_t,
        enabled: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Try to set the default state of Auto Boosted clocks on a device. This is the default state that Auto Boosted clocks will\n return to when no compute running processes (e.g. CUDA application which have an active context) are running\n\n For Kepler &tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.\n Requires root/admin permissions.\n\n Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates\n to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock\n rates are desired.\n\n On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks.\n Use \\ref nvmlDeviceSetApplicationsClocks and \\ref nvmlDeviceResetApplicationsClocks to control Auto Boost\n behavior.\n\n @param device                               The identifier of the target device\n @param enabled                              What state to try to set default Auto Boosted clocks of the target device to\n @param flags                                Flags that change the default behavior. Currently Unused.\n\n @return\n         - \\ref NVML_SUCCESS                 If the Auto Boosted clock's default state was successfully set to the state specified by \\a enabled\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_NO_PERMISSION     If the calling user does not have permission to change Auto Boosted clock's default state.\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n"]
    pub fn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(
        device: nvmlDevice_t,
        enabled: nvmlEnableState_t,
        flags: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the intended operating speed of the device's fan.\n\n Note: The reported speed is the intended fan speed.  If the fan is physically blocked and unable to spin, the\n output will not match the actual fan speed.\n\n For all discrete products with dedicated fans.\n\n The fan speed is expressed as a percentage of the product's maximum noise tolerance fan speed.\n This value may exceed 100% in certain cases.\n\n @param device                               The identifier of the target device\n @param speed                                Reference in which to return the fan speed percentage\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a speed has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a speed is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a fan\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetFanSpeed(
        device: nvmlDevice_t,
        speed: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the intended operating speed of the device's specified fan.\n\n Note: The reported speed is the intended fan speed. If the fan is physically blocked and unable to spin, the\n output will not match the actual fan speed.\n\n For all discrete products with dedicated fans.\n\n The fan speed is expressed as a percentage of the product's maximum noise tolerance fan speed.\n This value may exceed 100% in certain cases.\n\n @param device                                The identifier of the target device\n @param fan                                   The index of the target fan, zero indexed.\n @param speed                                 Reference in which to return the fan speed percentage\n\n @return\n        - \\ref NVML_SUCCESS                   if \\a speed has been set\n        - \\ref NVML_ERROR_UNINITIALIZED       if the library has not been successfully initialized\n        - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a device is invalid, \\a fan is not an acceptable index, or \\a speed is NULL\n        - \\ref NVML_ERROR_NOT_SUPPORTED       if the device does not have a fan or is newer than Maxwell\n        - \\ref NVML_ERROR_GPU_IS_LOST         if the target GPU has fallen off the bus or is otherwise inaccessible\n        - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlDeviceGetFanSpeed_v2(
        device: nvmlDevice_t,
        fan: ::std::os::raw::c_uint,
        speed: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the intended target speed of the device's specified fan.\n\n Normally, the driver dynamically adjusts the fan based on\n the needs of the GPU.  But when user set fan speed using nvmlDeviceSetFanSpeed_v2,\n the driver will attempt to make the fan achieve the setting in\n nvmlDeviceSetFanSpeed_v2.  The actual current speed of the fan\n is reported in nvmlDeviceGetFanSpeed_v2.\n\n For all discrete products with dedicated fans.\n\n The fan speed is expressed as a percentage of the product's maximum noise tolerance fan speed.\n This value may exceed 100% in certain cases.\n\n @param device                                The identifier of the target device\n @param fan                                   The index of the target fan, zero indexed.\n @param targetSpeed                           Reference in which to return the fan speed percentage\n\n @return\n        - \\ref NVML_SUCCESS                   if \\a speed has been set\n        - \\ref NVML_ERROR_UNINITIALIZED       if the library has not been successfully initialized\n        - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a device is invalid, \\a fan is not an acceptable index, or \\a speed is NULL\n        - \\ref NVML_ERROR_NOT_SUPPORTED       if the device does not have a fan or is newer than Maxwell\n        - \\ref NVML_ERROR_GPU_IS_LOST         if the target GPU has fallen off the bus or is otherwise inaccessible\n        - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlDeviceGetTargetFanSpeed(
        device: nvmlDevice_t,
        fan: ::std::os::raw::c_uint,
        targetSpeed: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Sets the speed of the fan control policy to default.\n\n For all cuda-capable discrete products with fans\n\n @param device                        The identifier of the target device\n @param fan                           The index of the fan, starting at zero\n\n return\n         NVML_SUCCESS                 if speed has been adjusted\n         NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         NVML_ERROR_INVALID_ARGUMENT  if device is invalid\n         NVML_ERROR_NOT_SUPPORTED     if the device does not support this\n                                      (doesn't have fans)\n         NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetDefaultFanSpeed_v2(
        device: nvmlDevice_t,
        fan: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the min and max fan speed that user can set for the GPU fan.\n\n For all cuda-capable discrete products with fans\n\n @param device                        The identifier of the target device\n @param minSpeed                      The minimum speed allowed to set\n @param maxSpeed                      The maximum speed allowed to set\n\n return\n         NVML_SUCCESS                 if speed has been adjusted\n         NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         NVML_ERROR_INVALID_ARGUMENT  if device is invalid\n         NVML_ERROR_NOT_SUPPORTED     if the device does not support this\n                                      (doesn't have fans)\n         NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMinMaxFanSpeed(
        device: nvmlDevice_t,
        minSpeed: *mut ::std::os::raw::c_uint,
        maxSpeed: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the number of fans on the device.\n\n For all discrete products with dedicated fans.\n\n @param device                               The identifier of the target device\n @param numFans                              The number of fans\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a fan number query was successful\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a numFans is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a fan\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNumFans(
        device: nvmlDevice_t,
        numFans: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current temperature readings for the device, in degrees C.\n\n For all products.\n\n See \\ref nvmlTemperatureSensors_t for details on available temperature sensors.\n\n @param device                               The identifier of the target device\n @param sensorType                           Flag that indicates which sensor reading to retrieve\n @param temp                                 Reference in which to return the temperature reading\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a temp has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a sensorType is invalid or \\a temp is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have the specified sensor\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetTemperature(
        device: nvmlDevice_t,
        sensorType: nvmlTemperatureSensors_t,
        temp: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the temperature threshold for the GPU with the specified threshold type in degrees C.\n\n For Kepler &tm; or newer fully supported devices.\n\n See \\ref nvmlTemperatureThresholds_t for details on available temperature thresholds.\n\n @param device                               The identifier of the target device\n @param thresholdType                        The type of threshold value queried\n @param temp                                 Reference in which to return the temperature reading\n @return\n         - \\ref NVML_SUCCESS                 if \\a temp has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a thresholdType is invalid or \\a temp is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a temperature sensor or is unsupported\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetTemperatureThreshold(
        device: nvmlDevice_t,
        thresholdType: nvmlTemperatureThresholds_t,
        temp: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Sets the temperature threshold for the GPU with the specified threshold type in degrees C.\n\n For Maxwell &tm; or newer fully supported devices.\n\n See \\ref nvmlTemperatureThresholds_t for details on available temperature thresholds.\n\n @param device                               The identifier of the target device\n @param thresholdType                        The type of threshold value to be set\n @param temp                                 Reference which hold the value to be set\n @return\n         - \\ref NVML_SUCCESS                 if \\a temp has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a thresholdType is invalid or \\a temp is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a temperature sensor or is unsupported\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetTemperatureThreshold(
        device: nvmlDevice_t,
        thresholdType: nvmlTemperatureThresholds_t,
        temp: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Used to execute a list of thermal system instructions.\n\n @param device                               The identifier of the target device\n @param sensorIndex                          The index of the thermal sensor\n @param pThermalSettings                     Reference in which to return the thermal sensor information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a pThermalSettings has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a pThermalSettings is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetThermalSettings(
        device: nvmlDevice_t,
        sensorIndex: ::std::os::raw::c_uint,
        pThermalSettings: *mut nvmlGpuThermalSettings_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current performance state for the device.\n\n For Fermi &tm; or newer fully supported devices.\n\n See \\ref nvmlPstates_t for details on allowed performance states.\n\n @param device                               The identifier of the target device\n @param pState                               Reference in which to return the performance state reading\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a pState has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a pState is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPerformanceState(
        device: nvmlDevice_t,
        pState: *mut nvmlPstates_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves current clocks throttling reasons.\n\n For all fully supported products.\n\n \\note More than one bit can be enabled at the same time. Multiple reasons can be affecting clocks at once.\n\n @param device                                The identifier of the target device\n @param clocksThrottleReasons                 Reference in which to return bitmask of active clocks throttle\n                                                  reasons\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a clocksThrottleReasons has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clocksThrottleReasons is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlClocksThrottleReasons\n @see nvmlDeviceGetSupportedClocksThrottleReasons"]
    pub fn nvmlDeviceGetCurrentClocksThrottleReasons(
        device: nvmlDevice_t,
        clocksThrottleReasons: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves bitmask of supported clocks throttle reasons that can be returned by\n \\ref nvmlDeviceGetCurrentClocksThrottleReasons\n\n For all fully supported products.\n\n This method is not supported in virtual machines running virtual GPU (vGPU).\n\n @param device                               The identifier of the target device\n @param supportedClocksThrottleReasons       Reference in which to return bitmask of supported\n                                              clocks throttle reasons\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a supportedClocksThrottleReasons has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a supportedClocksThrottleReasons is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlClocksThrottleReasons\n @see nvmlDeviceGetCurrentClocksThrottleReasons"]
    pub fn nvmlDeviceGetSupportedClocksThrottleReasons(
        device: nvmlDevice_t,
        supportedClocksThrottleReasons: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Deprecated: Use \\ref nvmlDeviceGetPerformanceState. This function exposes an incorrect generalization.\n\n Retrieve the current performance state for the device.\n\n For Fermi &tm; or newer fully supported devices.\n\n See \\ref nvmlPstates_t for details on allowed performance states.\n\n @param device                               The identifier of the target device\n @param pState                               Reference in which to return the performance state reading\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a pState has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a pState is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerState(
        device: nvmlDevice_t,
        pState: *mut nvmlPstates_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " This API has been deprecated.\n\n Retrieves the power management mode associated with this device.\n\n For products from the Fermi family.\n     - Requires \\a NVML_INFOROM_POWER version 3.0 or higher.\n\n For from the Kepler or newer families.\n     - Does not require \\a NVML_INFOROM_POWER object.\n\n This flag indicates whether any power management algorithm is currently active on the device. An\n enabled state does not necessarily mean the device is being actively throttled -- only that\n that the driver will do so if the appropriate conditions are met.\n\n See \\ref nvmlEnableState_t for details on allowed modes.\n\n @param device                               The identifier of the target device\n @param mode                                 Reference in which to return the current power management mode\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a mode has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerManagementMode(
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the power management limit associated with this device.\n\n For Fermi &tm; or newer fully supported devices.\n\n The power limit defines the upper boundary for the card's power draw. If\n the card's total power draw reaches this limit the power management algorithm kicks in.\n\n This reading is only available if power management mode is supported.\n See \\ref nvmlDeviceGetPowerManagementMode.\n\n @param device                               The identifier of the target device\n @param limit                                Reference in which to return the power management limit in milliwatts\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a limit has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a limit is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerManagementLimit(
        device: nvmlDevice_t,
        limit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves information about possible values of power management limits on this device.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param minLimit                             Reference in which to return the minimum power management limit in milliwatts\n @param maxLimit                             Reference in which to return the maximum power management limit in milliwatts\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a minLimit and \\a maxLimit have been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a minLimit or \\a maxLimit is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceSetPowerManagementLimit"]
    pub fn nvmlDeviceGetPowerManagementLimitConstraints(
        device: nvmlDevice_t,
        minLimit: *mut ::std::os::raw::c_uint,
        maxLimit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves default power management limit on this device, in milliwatts.\n Default power management limit is a power management limit that the device boots with.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param defaultLimit                         Reference in which to return the default power management limit in milliwatts\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a defaultLimit has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a defaultLimit is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerManagementDefaultLimit(
        device: nvmlDevice_t,
        defaultLimit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves power usage for this GPU in milliwatts and its associated circuitry (e.g. memory)\n\n For Fermi &tm; or newer fully supported devices.\n\n On Fermi and Kepler GPUs the reading is accurate to within +/- 5% of current power draw.\n\n It is only available if power management mode is supported. See \\ref nvmlDeviceGetPowerManagementMode.\n\n @param device                               The identifier of the target device\n @param power                                Reference in which to return the power usage information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a power has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a power is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support power readings\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerUsage(
        device: nvmlDevice_t,
        power: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves current power mode on this device.\n\n %ADA_OR_NEWER%\n\n @param device                               The identifier of the target device\n @param powerModeId                          Reference in which to return the power mode\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a power has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a power is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support power readings\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerMode(
        device: nvmlDevice_t,
        powerModeId: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves bitmask of supported power modes on this device.\n\n %ADA_OR_NEWER%\n\n @param device                               The identifier of the target device\n @param supportedPowerModes                   Reference in which to return the bitmask of supported power mode\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a bitmask of supported power mode has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a power is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support power readings\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetSupportedPowerModes(
        device: nvmlDevice_t,
        supportedPowerModes: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Sets new power mode.\n\n %ADA_OR_NEWER%\n\n @param device                               The identifier of the target device\n @param powerModeId                          Power mode to set.\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a power has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a power is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support power readings\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetPowerMode(
        device: nvmlDevice_t,
        powerModeId: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves total energy consumption for this GPU in millijoules (mJ) since the driver was last reloaded\n\n For Volta &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param energy                               Reference in which to return the energy consumption information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a energy has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a energy is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support energy readings\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetTotalEnergyConsumption(
        device: nvmlDevice_t,
        energy: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get the effective power limit that the driver enforces after taking into account all limiters\n\n Note: This can be different from the \\ref nvmlDeviceGetPowerManagementLimit if other limits are set elsewhere\n This includes the out of band power limit interface\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                           The device to communicate with\n @param limit                            Reference in which to return the power management limit in milliwatts\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a limit has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a limit is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetEnforcedPowerLimit(
        device: nvmlDevice_t,
        limit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current GOM and pending GOM (the one that GPU will switch to after reboot).\n\n For GK110 M-class and X-class Tesla &tm; products from the Kepler family.\n Modes \\ref NVML_GOM_LOW_DP and \\ref NVML_GOM_ALL_ON are supported on fully supported GeForce products.\n Not supported on Quadro &reg; and Tesla &tm; C-class products.\n\n @param device                               The identifier of the target device\n @param current                              Reference in which to return the current GOM\n @param pending                              Reference in which to return the pending GOM\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a mode has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a current or \\a pending is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlGpuOperationMode_t\n @see nvmlDeviceSetGpuOperationMode"]
    pub fn nvmlDeviceGetGpuOperationMode(
        device: nvmlDevice_t,
        current: *mut nvmlGpuOperationMode_t,
        pending: *mut nvmlGpuOperationMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the amount of used, free, reserved and total memory available on the device, in bytes.\n The reserved amount is supported on version 2 only.\n\n For all products.\n\n Enabling ECC reduces the amount of total available memory, due to the extra required parity bits.\n Under WDDM most device memory is allocated and managed on startup by Windows.\n\n Under Linux and Windows TCC, the reported amount of used memory is equal to the sum of memory allocated\n by all active channels on the device.\n\n See \\ref nvmlMemory_v2_t for details on available memory info.\n\n @note In MIG mode, if device handle is provided, the API returns aggregate\n       information, only if the caller has appropriate privileges. Per-instance\n       information can be queried by using specific MIG device handles.\n\n @note nvmlDeviceGetMemoryInfo_v2 adds additional memory information.\n\n @param device                               The identifier of the target device\n @param memory                               Reference in which to return the memory information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a memory has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a memory is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMemoryInfo(device: nvmlDevice_t, memory: *mut nvmlMemory_t)
        -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMemoryInfo_v2(
        device: nvmlDevice_t,
        memory: *mut nvmlMemory_v2_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current compute mode for the device.\n\n For all products.\n\n See \\ref nvmlComputeMode_t for details on allowed compute modes.\n\n @param device                               The identifier of the target device\n @param mode                                 Reference in which to return the current compute mode\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a mode has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceSetComputeMode()"]
    pub fn nvmlDeviceGetComputeMode(
        device: nvmlDevice_t,
        mode: *mut nvmlComputeMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the CUDA compute capability of the device.\n\n For all products.\n\n Returns the major and minor compute capability version numbers of the\n device.  The major and minor versions are equivalent to the\n CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR and\n CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR attributes that would be\n returned by CUDA's cuDeviceGetAttribute().\n\n @param device                               The identifier of the target device\n @param major                                Reference in which to return the major CUDA compute capability\n @param minor                                Reference in which to return the minor CUDA compute capability\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a major and \\a minor have been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a major or \\a minor are NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetCudaComputeCapability(
        device: nvmlDevice_t,
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current and pending ECC modes for the device.\n\n For Fermi &tm; or newer fully supported devices.\n Only applicable to devices with ECC.\n Requires \\a NVML_INFOROM_ECC version 1.0 or higher.\n\n Changing ECC modes requires a reboot. The \"pending\" ECC mode refers to the target mode following\n the next reboot.\n\n See \\ref nvmlEnableState_t for details on allowed modes.\n\n @param device                               The identifier of the target device\n @param current                              Reference in which to return the current ECC mode\n @param pending                              Reference in which to return the pending ECC mode\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a current and \\a pending have been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or either \\a current or \\a pending is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceSetEccMode()"]
    pub fn nvmlDeviceGetEccMode(
        device: nvmlDevice_t,
        current: *mut nvmlEnableState_t,
        pending: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the default ECC modes for the device.\n\n For Fermi &tm; or newer fully supported devices.\n Only applicable to devices with ECC.\n Requires \\a NVML_INFOROM_ECC version 1.0 or higher.\n\n See \\ref nvmlEnableState_t for details on allowed modes.\n\n @param device                               The identifier of the target device\n @param defaultMode                          Reference in which to return the default ECC mode\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a current and \\a pending have been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a default is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceSetEccMode()"]
    pub fn nvmlDeviceGetDefaultEccMode(
        device: nvmlDevice_t,
        defaultMode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the device boardId from 0-N.\n Devices with the same boardId indicate GPUs connected to the same PLX.  Use in conjunction with\n  \\ref nvmlDeviceGetMultiGpuBoard() to decide if they are on the same board as well.\n  The boardId returned is a unique ID for the current configuration.  Uniqueness and ordering across\n  reboots and system configurations is not guaranteed (i.e. if a Tesla K40c returns 0x100 and\n  the two GPUs on a Tesla K10 in the same system returns 0x200 it is not guaranteed they will\n  always return those values but they will always be different from each other).\n\n\n For Fermi &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param boardId                              Reference in which to return the device's board ID\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a boardId has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a boardId is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetBoardId(
        device: nvmlDevice_t,
        boardId: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves whether the device is on a Multi-GPU Board\n Devices that are on multi-GPU boards will set \\a multiGpuBool to a non-zero value.\n\n For Fermi &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param multiGpuBool                         Reference in which to return a zero or non-zero value\n                                                 to indicate whether the device is on a multi GPU board\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a multiGpuBool has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a multiGpuBool is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMultiGpuBoard(
        device: nvmlDevice_t,
        multiGpuBool: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the total ECC error counts for the device.\n\n For Fermi &tm; or newer fully supported devices.\n Only applicable to devices with ECC.\n Requires \\a NVML_INFOROM_ECC version 1.0 or higher.\n Requires ECC Mode to be enabled.\n\n The total error count is the sum of errors across each of the separate memory systems, i.e. the total set of\n errors across the entire device.\n\n See \\ref nvmlMemoryErrorType_t for a description of available error types.\\n\n See \\ref nvmlEccCounterType_t for a description of available counter types.\n\n @param device                               The identifier of the target device\n @param errorType                            Flag that specifies the type of the errors.\n @param counterType                          Flag that specifies the counter-type of the errors.\n @param eccCounts                            Reference in which to return the specified ECC errors\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a eccCounts has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a errorType or \\a counterType is invalid, or \\a eccCounts is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceClearEccErrorCounts()"]
    pub fn nvmlDeviceGetTotalEccErrors(
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        eccCounts: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the detailed ECC error counts for the device.\n\n @deprecated   This API supports only a fixed set of ECC error locations\n               On different GPU architectures different locations are supported\n               See \\ref nvmlDeviceGetMemoryErrorCounter\n\n For Fermi &tm; or newer fully supported devices.\n Only applicable to devices with ECC.\n Requires \\a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based ECC counts.\n Requires \\a NVML_INFOROM_ECC version 1.0 or higher to report all other ECC counts.\n Requires ECC Mode to be enabled.\n\n Detailed errors provide separate ECC counts for specific parts of the memory system.\n\n Reports zero for unsupported ECC error counters when a subset of ECC error counters are supported.\n\n See \\ref nvmlMemoryErrorType_t for a description of available bit types.\\n\n See \\ref nvmlEccCounterType_t for a description of available counter types.\\n\n See \\ref nvmlEccErrorCounts_t for a description of provided detailed ECC counts.\n\n @param device                               The identifier of the target device\n @param errorType                            Flag that specifies the type of the errors.\n @param counterType                          Flag that specifies the counter-type of the errors.\n @param eccCounts                            Reference in which to return the specified ECC errors\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a eccCounts has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a errorType or \\a counterType is invalid, or \\a eccCounts is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceClearEccErrorCounts()"]
    pub fn nvmlDeviceGetDetailedEccErrors(
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        eccCounts: *mut nvmlEccErrorCounts_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the requested memory error counter for the device.\n\n For Fermi &tm; or newer fully supported devices.\n Requires \\a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based memory error counts.\n Requires \\a NVML_INFOROM_ECC version 1.0 or higher to report all other memory error counts.\n\n Only applicable to devices with ECC.\n\n Requires ECC Mode to be enabled.\n\n @note On MIG-enabled GPUs, per instance information can be queried using specific\n       MIG device handles. Per instance information is currently only supported for\n       non-DRAM uncorrectable volatile errors. Querying volatile errors using device\n       handles is currently not supported.\n\n See \\ref nvmlMemoryErrorType_t for a description of available memory error types.\\n\n See \\ref nvmlEccCounterType_t for a description of available counter types.\\n\n See \\ref nvmlMemoryLocation_t for a description of available counter locations.\\n\n\n @param device                               The identifier of the target device\n @param errorType                            Flag that specifies the type of error.\n @param counterType                          Flag that specifies the counter-type of the errors.\n @param locationType                         Specifies the location of the counter.\n @param count                                Reference in which to return the ECC counter\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a count has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a bitTyp,e \\a counterType or \\a locationType is\n                                             invalid, or \\a count is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support ECC error reporting in the specified memory\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMemoryErrorCounter(
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        locationType: nvmlMemoryLocation_t,
        count: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current utilization rates for the device's major subsystems.\n\n For Fermi &tm; or newer fully supported devices.\n\n See \\ref nvmlUtilization_t for details on available utilization rates.\n\n \\note During driver initialization when ECC is enabled one can see high GPU and Memory Utilization readings.\n       This is caused by ECC Memory Scrubbing mechanism that is performed during driver initialization.\n\n @note On MIG-enabled GPUs, querying device utilization rates is not currently supported.\n\n @param device                               The identifier of the target device\n @param utilization                          Reference in which to return the utilization information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a utilization has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a utilization is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetUtilizationRates(
        device: nvmlDevice_t,
        utilization: *mut nvmlUtilization_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current utilization and sampling size in microseconds for the Encoder\n\n For Kepler &tm; or newer fully supported devices.\n\n @note On MIG-enabled GPUs, querying encoder utilization is not currently supported.\n\n @param device                               The identifier of the target device\n @param utilization                          Reference to an unsigned int for encoder utilization info\n @param samplingPeriodUs                     Reference to an unsigned int for the sampling period in US\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a utilization has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a utilization is NULL, or \\a samplingPeriodUs is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetEncoderUtilization(
        device: nvmlDevice_t,
        utilization: *mut ::std::os::raw::c_uint,
        samplingPeriodUs: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current capacity of the device's encoder, as a percentage of maximum encoder capacity with valid values in the range 0-100.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param device                            The identifier of the target device\n @param encoderQueryType                  Type of encoder to query\n @param encoderCapacity                   Reference to an unsigned int for the encoder capacity\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a encoderCapacity is fetched\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a encoderCapacity is NULL, or \\a device or \\a encoderQueryType\n                                              are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED      if device does not support the encoder specified in \\a encodeQueryType\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetEncoderCapacity(
        device: nvmlDevice_t,
        encoderQueryType: nvmlEncoderType_t,
        encoderCapacity: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current encoder statistics for a given device.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param device                            The identifier of the target device\n @param sessionCount                      Reference to an unsigned int for count of active encoder sessions\n @param averageFps                        Reference to an unsigned int for trailing average FPS of all active sessions\n @param averageLatency                    Reference to an unsigned int for encode latency in microseconds\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a sessionCount, \\a averageFps and \\a averageLatency is fetched\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a sessionCount, or \\a device or \\a averageFps,\n                                              or \\a averageLatency is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetEncoderStats(
        device: nvmlDevice_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        averageFps: *mut ::std::os::raw::c_uint,
        averageLatency: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves information about active encoder sessions on a target device.\n\n An array of active encoder sessions is returned in the caller-supplied buffer pointed at by \\a sessionInfos. The\n array elememt count is passed in \\a sessionCount, and \\a sessionCount is used to return the number of sessions\n written to the buffer.\n\n If the supplied buffer is not large enough to accomodate the active session array, the function returns\n NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in \\a sessionCount.\n To query the number of active encoder sessions, call this function with *sessionCount = 0.  The code will return\n NVML_SUCCESS with number of active encoder sessions updated in *sessionCount.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param device                            The identifier of the target device\n @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions.\n @param sessionInfos                      Reference in which to return the session information\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a sessionInfos is fetched\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE  if \\a sessionCount is too small, array element count is returned in \\a sessionCount\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a sessionCount is NULL.\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_NOT_SUPPORTED      if this query is not supported by \\a device\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetEncoderSessions(
        device: nvmlDevice_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        sessionInfos: *mut nvmlEncoderSessionInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current utilization and sampling size in microseconds for the Decoder\n\n For Kepler &tm; or newer fully supported devices.\n\n @note On MIG-enabled GPUs, querying decoder utilization is not currently supported.\n\n @param device                               The identifier of the target device\n @param utilization                          Reference to an unsigned int for decoder utilization info\n @param samplingPeriodUs                     Reference to an unsigned int for the sampling period in US\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a utilization has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a utilization is NULL, or \\a samplingPeriodUs is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetDecoderUtilization(
        device: nvmlDevice_t,
        utilization: *mut ::std::os::raw::c_uint,
        samplingPeriodUs: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the active frame buffer capture sessions statistics for a given device.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param device                            The identifier of the target device\n @param fbcStats                          Reference to nvmlFBCStats_t structure contianing NvFBC stats\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a fbcStats is fetched\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a fbcStats is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetFBCStats(
        device: nvmlDevice_t,
        fbcStats: *mut nvmlFBCStats_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves information about active frame buffer capture sessions on a target device.\n\n An array of active FBC sessions is returned in the caller-supplied buffer pointed at by \\a sessionInfo. The\n array element count is passed in \\a sessionCount, and \\a sessionCount is used to return the number of sessions\n written to the buffer.\n\n If the supplied buffer is not large enough to accomodate the active session array, the function returns\n NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in \\a sessionCount.\n To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return\n NVML_SUCCESS with number of active FBC sessions updated in *sessionCount.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in \\a sessionInfo may\n       be zero if there are no new frames captured since the session started.\n\n @param device                            The identifier of the target device\n @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions.\n @param sessionInfo                       Reference in which to return the session information\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a sessionInfo is fetched\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE  if \\a sessionCount is too small, array element count is returned in \\a sessionCount\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a sessionCount is NULL.\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetFBCSessions(
        device: nvmlDevice_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        sessionInfo: *mut nvmlFBCSessionInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current and pending driver model for the device.\n\n For Fermi &tm; or newer fully supported devices.\n For windows only.\n\n On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached\n to the device it must run in WDDM mode. TCC mode is preferred if a display is not attached.\n\n See \\ref nvmlDriverModel_t for details on available driver models.\n\n @param device                               The identifier of the target device\n @param current                              Reference in which to return the current driver model\n @param pending                              Reference in which to return the pending driver model\n\n @return\n         - \\ref NVML_SUCCESS                 if either \\a current and/or \\a pending have been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or both \\a current and \\a pending are NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the platform is not windows\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceSetDriverModel()"]
    pub fn nvmlDeviceGetDriverModel(
        device: nvmlDevice_t,
        current: *mut nvmlDriverModel_t,
        pending: *mut nvmlDriverModel_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get VBIOS version of the device.\n\n For all products.\n\n The VBIOS version may change from time to time. It will not exceed 32 characters in length\n (including the NULL terminator).  See \\ref nvmlConstants::NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE.\n\n @param device                               The identifier of the target device\n @param version                              Reference to which to return the VBIOS version\n @param length                               The maximum allowed length of the string returned in \\a version\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a version has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a version is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetVbiosVersion(
        device: nvmlDevice_t,
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get Bridge Chip Information for all the bridge chips on the board.\n\n For all fully supported products.\n Only applicable to multi-GPU products.\n\n @param device                                The identifier of the target device\n @param bridgeHierarchy                       Reference to the returned bridge chip Hierarchy\n\n @return\n         - \\ref NVML_SUCCESS                 if bridge chip exists\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a bridgeInfo is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if bridge chip not supported on the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n"]
    pub fn nvmlDeviceGetBridgeChipInfo(
        device: nvmlDevice_t,
        bridgeHierarchy: *mut nvmlBridgeChipHierarchy_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get information about processes with a compute context on a device\n\n For Fermi &tm; or newer fully supported devices.\n\n This function returns information only about compute running processes (e.g. CUDA application which have\n active context). Any graphics applications (e.g. using OpenGL, DirectX) won't be listed by this function.\n\n To query the current number of running compute processes, call this function with *infoCount = 0. The\n return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call\n \\a infos is allowed to be NULL.\n\n The usedGpuMemory field returned is all of the memory used by the application.\n\n Keep in mind that information returned by this call is dynamic and the number of elements might change in\n time. Allocate more space for \\a infos table in case new compute processes are spawned.\n\n @note In MIG mode, if device handle is provided, the API returns aggregate information, only if\n       the caller has appropriate privileges. Per-instance information can be queried by using\n       specific MIG device handles.\n       Querying per-instance information using MIG device handles is not supported if the device is in vGPU Host virtualization mode.\n\n @param device                               The device handle or MIG device handle\n @param infoCount                            Reference in which to provide the \\a infos array size, and\n                                             to return the number of returned elements\n @param infos                                Reference in which to return the process information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a infoCount and \\a infos have been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a infoCount indicates that the \\a infos array is too small\n                                             \\a infoCount will contain minimal amount of space necessary for\n                                             the call to complete\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, either of \\a infoCount or \\a infos is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by \\a device\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see \\ref nvmlSystemGetProcessName"]
    pub fn nvmlDeviceGetComputeRunningProcesses_v3(
        device: nvmlDevice_t,
        infoCount: *mut ::std::os::raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get information about processes with a graphics context on a device\n\n For Kepler &tm; or newer fully supported devices.\n\n This function returns information only about graphics based processes\n (eg. applications using OpenGL, DirectX)\n\n To query the current number of running graphics processes, call this function with *infoCount = 0. The\n return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call\n \\a infos is allowed to be NULL.\n\n The usedGpuMemory field returned is all of the memory used by the application.\n\n Keep in mind that information returned by this call is dynamic and the number of elements might change in\n time. Allocate more space for \\a infos table in case new graphics processes are spawned.\n\n @note In MIG mode, if device handle is provided, the API returns aggregate information, only if\n       the caller has appropriate privileges. Per-instance information can be queried by using\n       specific MIG device handles.\n       Querying per-instance information using MIG device handles is not supported if the device is in vGPU Host virtualization mode.\n\n @param device                               The device handle or MIG device handle\n @param infoCount                            Reference in which to provide the \\a infos array size, and\n                                             to return the number of returned elements\n @param infos                                Reference in which to return the process information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a infoCount and \\a infos have been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a infoCount indicates that the \\a infos array is too small\n                                             \\a infoCount will contain minimal amount of space necessary for\n                                             the call to complete\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, either of \\a infoCount or \\a infos is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by \\a device\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see \\ref nvmlSystemGetProcessName"]
    pub fn nvmlDeviceGetGraphicsRunningProcesses_v3(
        device: nvmlDevice_t,
        infoCount: *mut ::std::os::raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get information about processes with a MPS compute context on a device\n\n For Volta &tm; or newer fully supported devices.\n\n This function returns information only about compute running processes (e.g. CUDA application which have\n active context) utilizing MPS. Any graphics applications (e.g. using OpenGL, DirectX) won't be listed by\n this function.\n\n To query the current number of running compute processes, call this function with *infoCount = 0. The\n return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call\n \\a infos is allowed to be NULL.\n\n The usedGpuMemory field returned is all of the memory used by the application.\n\n Keep in mind that information returned by this call is dynamic and the number of elements might change in\n time. Allocate more space for \\a infos table in case new compute processes are spawned.\n\n @note In MIG mode, if device handle is provided, the API returns aggregate information, only if\n       the caller has appropriate privileges. Per-instance information can be queried by using\n       specific MIG device handles.\n       Querying per-instance information using MIG device handles is not supported if the device is in vGPU Host virtualization mode.\n\n @param device                               The device handle or MIG device handle\n @param infoCount                            Reference in which to provide the \\a infos array size, and\n                                             to return the number of returned elements\n @param infos                                Reference in which to return the process information\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a infoCount and \\a infos have been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a infoCount indicates that the \\a infos array is too small\n                                             \\a infoCount will contain minimal amount of space necessary for\n                                             the call to complete\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, either of \\a infoCount or \\a infos is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by \\a device\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see \\ref nvmlSystemGetProcessName"]
    pub fn nvmlDeviceGetMPSComputeRunningProcesses_v3(
        device: nvmlDevice_t,
        infoCount: *mut ::std::os::raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Check if the GPU devices are on the same physical board.\n\n For all fully supported products.\n\n @param device1                               The first GPU device\n @param device2                               The second GPU device\n @param onSameBoard                           Reference in which to return the status.\n                                              Non-zero indicates that the GPUs are on the same board.\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a onSameBoard has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a dev1 or \\a dev2 are invalid or \\a onSameBoard is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this check is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the either GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceOnSameBoard(
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        onSameBoard: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the root/admin permissions on the target API. See \\a nvmlRestrictedAPI_t for the list of supported APIs.\n If an API is restricted only root users can call that API. See \\a nvmlDeviceSetAPIRestriction to change current permissions.\n\n For all fully supported products.\n\n @param device                               The identifier of the target device\n @param apiType                              Target API type for this operation\n @param isRestricted                         Reference in which to return the current restriction\n                                             NVML_FEATURE_ENABLED indicates that the API is root-only\n                                             NVML_FEATURE_DISABLED indicates that the API is accessible to all users\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a isRestricted has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a apiType incorrect or \\a isRestricted is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device or the device does not support\n                                                 the feature that is being queried (E.G. Enabling/disabling Auto Boosted clocks is\n                                                 not supported by the device)\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlRestrictedAPI_t"]
    pub fn nvmlDeviceGetAPIRestriction(
        device: nvmlDevice_t,
        apiType: nvmlRestrictedAPI_t,
        isRestricted: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets recent samples for the GPU.\n\n For Kepler &tm; or newer fully supported devices.\n\n Based on type, this method can be used to fetch the power, utilization or clock samples maintained in the buffer by\n the driver.\n\n Power, Utilization and Clock samples are returned as type \"unsigned int\" for the union nvmlValue_t.\n\n To get the size of samples that user needs to allocate, the method is invoked with samples set to NULL.\n The returned samplesCount will provide the number of samples that can be queried. The user needs to\n allocate the buffer with size as samplesCount * sizeof(nvmlSample_t).\n\n lastSeenTimeStamp represents CPU timestamp in microseconds. Set it to 0 to fetch all the samples maintained by the\n underlying buffer. Set lastSeenTimeStamp to one of the timeStamps retrieved from the date of the previous query\n to get more recent samples.\n\n This method fetches the number of entries which can be accommodated in the provided samples array, and the\n reference samplesCount is updated to indicate how many samples were actually retrieved. The advantage of using this\n method for samples in contrast to polling via existing methods is to get get higher frequency data at lower polling cost.\n\n @note On MIG-enabled GPUs, querying the following sample types, NVML_GPU_UTILIZATION_SAMPLES, NVML_MEMORY_UTILIZATION_SAMPLES\n       NVML_ENC_UTILIZATION_SAMPLES and NVML_DEC_UTILIZATION_SAMPLES, is not currently supported.\n\n @param device                        The identifier for the target device\n @param type                          Type of sampling event\n @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp.\n @param sampleValType                 Output parameter to represent the type of sample value as described in nvmlSampleVal_t\n @param sampleCount                   Reference to provide the number of elements which can be queried in samples array\n @param samples                       Reference in which samples are returned\n\n @return\n         - \\ref NVML_SUCCESS                 if samples are successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a samplesCount is NULL or\n                                             reference to \\a sampleCount is 0 for non null \\a samples\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_NOT_FOUND         if sample entries are not found\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetSamples(
        device: nvmlDevice_t,
        type_: nvmlSamplingType_t,
        lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
        sampleValType: *mut nvmlValueType_t,
        sampleCount: *mut ::std::os::raw::c_uint,
        samples: *mut nvmlSample_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets Total, Available and Used size of BAR1 memory.\n\n BAR1 is used to map the FB (device memory) so that it can be directly accessed by the CPU or by 3rd party\n devices (peer-to-peer on the PCIE bus).\n\n @note In MIG mode, if device handle is provided, the API returns aggregate\n       information, only if the caller has appropriate privileges. Per-instance\n       information can be queried by using specific MIG device handles.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param bar1Memory                           Reference in which BAR1 memory\n                                             information is returned.\n\n @return\n         - \\ref NVML_SUCCESS                 if BAR1 memory is successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a bar1Memory is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n"]
    pub fn nvmlDeviceGetBAR1MemoryInfo(
        device: nvmlDevice_t,
        bar1Memory: *mut nvmlBAR1Memory_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets the duration of time during which the device was throttled (lower than requested clocks) due to power\n or thermal constraints.\n\n The method is important to users who are tying to understand if their GPUs throttle at any point during their applications. The\n difference in violation times at two different reference times gives the indication of GPU throttling event.\n\n Violation for thermal capping is not supported at this time.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param perfPolicyType                       Represents Performance policy which can trigger GPU throttling\n @param violTime                             Reference to which violation time related information is returned\n\n\n @return\n         - \\ref NVML_SUCCESS                 if violation time is successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a perfPolicyType is invalid, or \\a violTime is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n"]
    pub fn nvmlDeviceGetViolationStatus(
        device: nvmlDevice_t,
        perfPolicyType: nvmlPerfPolicyType_t,
        violTime: *mut nvmlViolationTime_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets the device's interrupt number\n\n @param device                               The identifier of the target device\n @param irqNum                               The interrupt number associated with the specified device\n\n @return\n         - \\ref NVML_SUCCESS                 if irq number is successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a irqNum is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n"]
    pub fn nvmlDeviceGetIrqNum(
        device: nvmlDevice_t,
        irqNum: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets the device's core count\n\n @param device                               The identifier of the target device\n @param numCores                             The number of cores for the specified device\n\n @return\n         - \\ref NVML_SUCCESS                 if Gpu core count is successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a numCores is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n"]
    pub fn nvmlDeviceGetNumGpuCores(
        device: nvmlDevice_t,
        numCores: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets the devices power source\n\n @param device                               The identifier of the target device\n @param powerSource                          The power source of the device\n\n @return\n         - \\ref NVML_SUCCESS                 if the current power source was successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a powerSource is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n"]
    pub fn nvmlDeviceGetPowerSource(
        device: nvmlDevice_t,
        powerSource: *mut nvmlPowerSource_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets the device's memory bus width\n\n @param device                               The identifier of the target device\n @param maxSpeed                             The devices's memory bus width\n\n @return\n         - \\ref NVML_SUCCESS                 if the memory bus width is successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a busWidth is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n"]
    pub fn nvmlDeviceGetMemoryBusWidth(
        device: nvmlDevice_t,
        busWidth: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets the device's PCIE Max Link speed in MBPS\n\n @param device                               The identifier of the target device\n @param maxSpeed                             The devices's PCIE Max Link speed in MBPS\n\n @return\n         - \\ref NVML_SUCCESS                 if Pcie Max Link Speed is successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a maxSpeed is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n"]
    pub fn nvmlDeviceGetPcieLinkMaxSpeed(
        device: nvmlDevice_t,
        maxSpeed: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets the device's PCIe Link speed in Mbps\n\n @param device                               The identifier of the target device\n @param pcieSpeed                            The devices's PCIe Max Link speed in Mbps\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a pcieSpeed has been retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a pcieSpeed is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support PCIe speed getting\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPcieSpeed(
        device: nvmlDevice_t,
        pcieSpeed: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets the device's Adaptive Clock status\n\n @param device                               The identifier of the target device\n @param adaptiveClockStatus                  The current adaptive clocking status\n\n @return\n         - \\ref NVML_SUCCESS                 if the current adaptive clocking status is successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a adaptiveClockStatus is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n"]
    pub fn nvmlDeviceGetAdaptiveClockInfoStatus(
        device: nvmlDevice_t,
        adaptiveClockStatus: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries the state of per process accounting mode.\n\n For Kepler &tm; or newer fully supported devices.\n\n See \\ref nvmlDeviceGetAccountingStats for more details.\n See \\ref nvmlDeviceSetAccountingMode\n\n @param device                               The identifier of the target device\n @param mode                                 Reference in which to return the current accounting mode\n\n @return\n         - \\ref NVML_SUCCESS                 if the mode has been successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode are NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetAccountingMode(
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries process's accounting stats.\n\n For Kepler &tm; or newer fully supported devices.\n\n Accounting stats capture GPU utilization and other statistics across the lifetime of a process.\n Accounting stats can be queried during life time of the process and after its termination.\n The time field in \\ref nvmlAccountingStats_t is reported as 0 during the lifetime of the process and\n updated to actual running time after its termination.\n Accounting stats are kept in a circular buffer, newly created processes overwrite information about old\n processes.\n\n See \\ref nvmlAccountingStats_t for description of each returned metric.\n List of processes that can be queried can be retrieved from \\ref nvmlDeviceGetAccountingPids.\n\n @note Accounting Mode needs to be on. See \\ref nvmlDeviceGetAccountingMode.\n @note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be\n         queried since they don't contribute to GPU utilization.\n @note In case of pid collision stats of only the latest process (that terminated last) will be reported\n\n @warning On Kepler devices per process statistics are accurate only if there's one process running on a GPU.\n\n @param device                               The identifier of the target device\n @param pid                                  Process Id of the target process to query stats for\n @param stats                                Reference in which to return the process's accounting stats\n\n @return\n         - \\ref NVML_SUCCESS                 if stats have been successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a stats are NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if process stats were not found\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if \\a device doesn't support this feature or accounting mode is disabled\n                                              or on vGPU host.\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetAccountingBufferSize"]
    pub fn nvmlDeviceGetAccountingStats(
        device: nvmlDevice_t,
        pid: ::std::os::raw::c_uint,
        stats: *mut nvmlAccountingStats_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries list of processes that can be queried for accounting stats. The list of processes returned\n can be in running or terminated state.\n\n For Kepler &tm; or newer fully supported devices.\n\n To just query the number of processes ready to be queried, call this function with *count = 0 and\n pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty.\n\n For more details see \\ref nvmlDeviceGetAccountingStats.\n\n @note In case of PID collision some processes might not be accessible before the circular buffer is full.\n\n @param device                               The identifier of the target device\n @param count                                Reference in which to provide the \\a pids array size, and\n                                               to return the number of elements ready to be queried\n @param pids                                 Reference in which to return list of process ids\n\n @return\n         - \\ref NVML_SUCCESS                 if pids were successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a count is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if \\a device doesn't support this feature or accounting mode is disabled\n                                              or on vGPU host.\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a count is too small (\\a count is set to\n                                                 expected value)\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetAccountingBufferSize"]
    pub fn nvmlDeviceGetAccountingPids(
        device: nvmlDevice_t,
        count: *mut ::std::os::raw::c_uint,
        pids: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns the number of processes that the circular buffer with accounting pids can hold.\n\n For Kepler &tm; or newer fully supported devices.\n\n This is the maximum number of processes that accounting information will be stored for before information\n about oldest processes will get overwritten by information about new processes.\n\n @param device                               The identifier of the target device\n @param bufferSize                           Reference in which to provide the size (in number of elements)\n                                               of the circular buffer for accounting stats.\n\n @return\n         - \\ref NVML_SUCCESS                 if buffer size was successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a bufferSize is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetAccountingStats\n @see nvmlDeviceGetAccountingPids"]
    pub fn nvmlDeviceGetAccountingBufferSize(
        device: nvmlDevice_t,
        bufferSize: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns the list of retired pages by source, including pages that are pending retirement\n The address information provided from this API is the hardware address of the page that was retired.  Note\n that this does not match the virtual address used in CUDA, but will match the address information in XID 63\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                            The identifier of the target device\n @param cause                             Filter page addresses by cause of retirement\n @param pageCount                         Reference in which to provide the \\a addresses buffer size, and\n                                          to return the number of retired pages that match \\a cause\n                                          Set to 0 to query the size without allocating an \\a addresses buffer\n @param addresses                         Buffer to write the page addresses into\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a pageCount was populated and \\a addresses was filled\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a pageCount indicates the buffer is not large enough to store all the\n                                             matching page addresses.  \\a pageCount is set to the needed size.\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a pageCount is NULL, \\a cause is invalid, or\n                                             \\a addresses is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetRetiredPages(
        device: nvmlDevice_t,
        cause: nvmlPageRetirementCause_t,
        pageCount: *mut ::std::os::raw::c_uint,
        addresses: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns the list of retired pages by source, including pages that are pending retirement\n The address information provided from this API is the hardware address of the page that was retired.  Note\n that this does not match the virtual address used in CUDA, but will match the address information in XID 63\n\n \\note nvmlDeviceGetRetiredPages_v2 adds an additional timestamps paramter to return the time of each page's\n       retirement.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                            The identifier of the target device\n @param cause                             Filter page addresses by cause of retirement\n @param pageCount                         Reference in which to provide the \\a addresses buffer size, and\n                                          to return the number of retired pages that match \\a cause\n                                          Set to 0 to query the size without allocating an \\a addresses buffer\n @param addresses                         Buffer to write the page addresses into\n @param timestamps                        Buffer to write the timestamps of page retirement, additional for _v2\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a pageCount was populated and \\a addresses was filled\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a pageCount indicates the buffer is not large enough to store all the\n                                             matching page addresses.  \\a pageCount is set to the needed size.\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a pageCount is NULL, \\a cause is invalid, or\n                                             \\a addresses is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetRetiredPages_v2(
        device: nvmlDevice_t,
        cause: nvmlPageRetirementCause_t,
        pageCount: *mut ::std::os::raw::c_uint,
        addresses: *mut ::std::os::raw::c_ulonglong,
        timestamps: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Check if any pages are pending retirement and need a reboot to fully retire.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                            The identifier of the target device\n @param isPending                         Reference in which to return the pending status\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a isPending was populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a isPending is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetRetiredPagesPendingStatus(
        device: nvmlDevice_t,
        isPending: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get number of remapped rows. The number of rows reported will be based on\n the cause of the remapping. isPending indicates whether or not there are\n pending remappings. A reset will be required to actually remap the row.\n failureOccurred will be set if a row remapping ever failed in the past. A\n pending remapping won't affect future work on the GPU since\n error-containment and dynamic page blacklisting will take care of that.\n\n @note On MIG-enabled GPUs with active instances, querying the number of\n remapped rows is not supported\n\n For Ampere &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param corrRows                             Reference for number of rows remapped due to correctable errors\n @param uncRows                              Reference for number of rows remapped due to uncorrectable errors\n @param isPending                            Reference for whether or not remappings are pending\n @param failureOccurred                      Reference that is set when a remapping has failed in the past\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a corrRows, \\a uncRows, \\a isPending or \\a failureOccurred is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If MIG is enabled or if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           Unexpected error"]
    pub fn nvmlDeviceGetRemappedRows(
        device: nvmlDevice_t,
        corrRows: *mut ::std::os::raw::c_uint,
        uncRows: *mut ::std::os::raw::c_uint,
        isPending: *mut ::std::os::raw::c_uint,
        failureOccurred: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get the row remapper histogram. Returns the remap availability for each bank\n on the GPU.\n\n @param device                               Device handle\n @param values                               Histogram values\n\n @return\n        - \\ref NVML_SUCCESS                  On success\n        - \\ref NVML_ERROR_UNKNOWN            On any unexpected error"]
    pub fn nvmlDeviceGetRowRemapperHistogram(
        device: nvmlDevice_t,
        values: *mut nvmlRowRemapperHistogramValues_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get architecture for device\n\n @param device                               The identifier of the target device\n @param arch                                 Reference where architecture is returned, if call successful.\n                                             Set to NVML_DEVICE_ARCH_* upon success\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a device or \\a arch (output refererence) are invalid"]
    pub fn nvmlDeviceGetArchitecture(
        device: nvmlDevice_t,
        arch: *mut nvmlDeviceArchitecture_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the LED state for the unit. The LED can be either green (0) or amber (1).\n\n For S-class products.\n Requires root/admin permissions.\n\n This operation takes effect immediately.\n\n\n <b>Current S-Class products don't provide unique LEDs for each unit. As such, both front\n and back LEDs will be toggled in unison regardless of which unit is specified with this command.</b>\n\n See \\ref nvmlLedColor_t for available colors.\n\n @param unit                                 The identifier of the target unit\n @param color                                The target LED color\n\n @return\n         - \\ref NVML_SUCCESS                 if the LED color has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit or \\a color is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlUnitGetLedState()"]
    pub fn nvmlUnitSetLedState(unit: nvmlUnit_t, color: nvmlLedColor_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the persistence mode for the device.\n\n For all products.\n For Linux only.\n Requires root/admin permissions.\n\n The persistence mode determines whether the GPU driver software is torn down after the last client\n exits.\n\n This operation takes effect immediately. It is not persistent across reboots. After each reboot the\n persistence mode is reset to \"Disabled\".\n\n See \\ref nvmlEnableState_t for available modes.\n\n After calling this API with mode set to NVML_FEATURE_DISABLED on a device that has its own NUMA\n memory, the given device handle will no longer be valid, and to continue to interact with this\n device, a new handle should be obtained from one of the nvmlDeviceGetHandleBy*() APIs. This\n limitation is currently only applicable to devices that have a coherent NVLink connection to\n system memory.\n\n @param device                               The identifier of the target device\n @param mode                                 The target persistence mode\n\n @return\n         - \\ref NVML_SUCCESS                 if the persistence mode was set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetPersistenceMode()"]
    pub fn nvmlDeviceSetPersistenceMode(
        device: nvmlDevice_t,
        mode: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the compute mode for the device.\n\n For all products.\n Requires root/admin permissions.\n\n The compute mode determines whether a GPU can be used for compute operations and whether it can\n be shared across contexts.\n\n This operation takes effect immediately. Under Linux it is not persistent across reboots and\n always resets to \"Default\". Under windows it is persistent.\n\n Under windows compute mode may only be set to DEFAULT when running in WDDM\n\n @note On MIG-enabled GPUs, compute mode would be set to DEFAULT and changing it is not supported.\n\n See \\ref nvmlComputeMode_t for details on available compute modes.\n\n @param device                               The identifier of the target device\n @param mode                                 The target compute mode\n\n @return\n         - \\ref NVML_SUCCESS                 if the compute mode was set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetComputeMode()"]
    pub fn nvmlDeviceSetComputeMode(device: nvmlDevice_t, mode: nvmlComputeMode_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the ECC mode for the device.\n\n For Kepler &tm; or newer fully supported devices.\n Only applicable to devices with ECC.\n Requires \\a NVML_INFOROM_ECC version 1.0 or higher.\n Requires root/admin permissions.\n\n The ECC mode determines whether the GPU enables its ECC support.\n\n This operation takes effect after the next reboot.\n\n See \\ref nvmlEnableState_t for details on available modes.\n\n @param device                               The identifier of the target device\n @param ecc                                  The target ECC mode\n\n @return\n         - \\ref NVML_SUCCESS                 if the ECC mode was set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a ecc is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetEccMode()"]
    pub fn nvmlDeviceSetEccMode(device: nvmlDevice_t, ecc: nvmlEnableState_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Clear the ECC error and other memory error counts for the device.\n\n For Kepler &tm; or newer fully supported devices.\n Only applicable to devices with ECC.\n Requires \\a NVML_INFOROM_ECC version 2.0 or higher to clear aggregate location-based ECC counts.\n Requires \\a NVML_INFOROM_ECC version 1.0 or higher to clear all other ECC counts.\n Requires root/admin permissions.\n Requires ECC Mode to be enabled.\n\n Sets all of the specified ECC counters to 0, including both detailed and total counts.\n\n This operation takes effect immediately.\n\n See \\ref nvmlMemoryErrorType_t for details on available counter types.\n\n @param device                               The identifier of the target device\n @param counterType                          Flag that indicates which type of errors should be cleared.\n\n @return\n         - \\ref NVML_SUCCESS                 if the error counts were cleared\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a counterType is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see\n      - nvmlDeviceGetDetailedEccErrors()\n      - nvmlDeviceGetTotalEccErrors()"]
    pub fn nvmlDeviceClearEccErrorCounts(
        device: nvmlDevice_t,
        counterType: nvmlEccCounterType_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the driver model for the device.\n\n For Fermi &tm; or newer fully supported devices.\n For windows only.\n Requires root/admin permissions.\n\n On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached\n to the device it must run in WDDM mode.\n\n It is possible to force the change to WDM (TCC) while the display is still attached with a force flag (nvmlFlagForce).\n This should only be done if the host is subsequently powered down and the display is detached from the device\n before the next reboot.\n\n This operation takes effect after the next reboot.\n\n Windows driver model may only be set to WDDM when running in DEFAULT compute mode.\n\n Change driver model to WDDM is not supported when GPU doesn't support graphics acceleration or\n will not support it after reboot. See \\ref nvmlDeviceSetGpuOperationMode.\n\n See \\ref nvmlDriverModel_t for details on available driver models.\n See \\ref nvmlFlagDefault and \\ref nvmlFlagForce\n\n @param device                               The identifier of the target device\n @param driverModel                          The target driver model\n @param flags                                Flags that change the default behavior\n\n @return\n         - \\ref NVML_SUCCESS                 if the driver model has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a driverModel is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the platform is not windows or the device does not support this feature\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetDriverModel()"]
    pub fn nvmlDeviceSetDriverModel(
        device: nvmlDevice_t,
        driverModel: nvmlDriverModel_t,
        flags: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_RANGE_START: nvmlClockLimitId_enum = 4294967040;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_TDP: nvmlClockLimitId_enum = 4294967041;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_UNLIMITED: nvmlClockLimitId_enum = 4294967042;
pub type nvmlClockLimitId_enum = ::std::os::raw::c_uint;
pub use self::nvmlClockLimitId_enum as nvmlClockLimitId_t;
extern "C" {
    #[doc = " Set clocks that device will lock to.\n\n Sets the clocks that the device will be running at to the value in the range of minGpuClockMHz to maxGpuClockMHz.\n Setting this will supercede application clock values and take effect regardless if a cuda app is running.\n See /ref nvmlDeviceSetApplicationsClocks\n\n Can be used as a setting to request constant performance.\n\n This can be called with a pair of integer clock frequencies in MHz, or a pair of /ref nvmlClockLimitId_t values.\n See the table below for valid combinations of these values.\n\n minGpuClock | maxGpuClock | Effect\n ------------+-------------+--------------------------------------------------\n     tdp     |     tdp     | Lock clock to TDP\n  unlimited  |     tdp     | Upper bound is TDP but clock may drift below this\n     tdp     |  unlimited  | Lower bound is TDP but clock may boost above this\n  unlimited  |  unlimited  | Unlocked (== nvmlDeviceResetGpuLockedClocks)\n\n If one arg takes one of these values, the other must be one of these values as\n well. Mixed numeric and symbolic calls return NVML_ERROR_INVALID_ARGUMENT.\n\n Requires root/admin permissions.\n\n After system reboot or driver reload applications clocks go back to their default value.\n See \\ref nvmlDeviceResetGpuLockedClocks.\n\n For Volta &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param minGpuClockMHz                       Requested minimum gpu clock in MHz\n @param maxGpuClockMHz                       Requested maximum gpu clock in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if new settings were successfully set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a minGpuClockMHz and \\a maxGpuClockMHz\n                                                 is not a valid clock combination\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetGpuLockedClocks(
        device: nvmlDevice_t,
        minGpuClockMHz: ::std::os::raw::c_uint,
        maxGpuClockMHz: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Resets the gpu clock to the default value\n\n This is the gpu clock that will be used after system reboot or driver reload.\n Default values are idle clocks, but the current values can be changed using \\ref nvmlDeviceSetApplicationsClocks.\n\n @see nvmlDeviceSetGpuLockedClocks\n\n For Volta &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n\n @return\n         - \\ref NVML_SUCCESS                 if new settings were successfully set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceResetGpuLockedClocks(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set memory clocks that device will lock to.\n\n Sets the device's memory clocks to the value in the range of minMemClockMHz to maxMemClockMHz.\n Setting this will supersede application clock values and take effect regardless of whether a cuda app is running.\n See /ref nvmlDeviceSetApplicationsClocks\n\n Can be used as a setting to request constant performance.\n\n Requires root/admin permissions.\n\n After system reboot or driver reload applications clocks go back to their default value.\n See \\ref nvmlDeviceResetMemoryLockedClocks.\n\n For Ampere &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param minMemClockMHz                       Requested minimum memory clock in MHz\n @param maxMemClockMHz                       Requested maximum memory clock in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if new settings were successfully set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a minGpuClockMHz and \\a maxGpuClockMHz\n                                                 is not a valid clock combination\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetMemoryLockedClocks(
        device: nvmlDevice_t,
        minMemClockMHz: ::std::os::raw::c_uint,
        maxMemClockMHz: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Resets the memory clock to the default value\n\n This is the memory clock that will be used after system reboot or driver reload.\n Default values are idle clocks, but the current values can be changed using \\ref nvmlDeviceSetApplicationsClocks.\n\n @see nvmlDeviceSetMemoryLockedClocks\n\n For Ampere &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n\n @return\n         - \\ref NVML_SUCCESS                 if new settings were successfully set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceResetMemoryLockedClocks(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set clocks that applications will lock to.\n\n Sets the clocks that compute and graphics applications will be running at.\n e.g. CUDA driver requests these clocks during context creation which means this property\n defines clocks at which CUDA applications will be running unless some overspec event\n occurs (e.g. over power, over thermal or external HW brake).\n\n Can be used as a setting to request constant performance.\n\n On Pascal and newer hardware, this will automatically disable automatic boosting of clocks.\n\n On K80 and newer Kepler and Maxwell GPUs, users desiring fixed performance should also call\n \\ref nvmlDeviceSetAutoBoostedClocksEnabled to prevent clocks from automatically boosting\n above the clock value being set.\n\n For Kepler &tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.\n Requires root/admin permissions.\n\n See \\ref nvmlDeviceGetSupportedMemoryClocks and \\ref nvmlDeviceGetSupportedGraphicsClocks\n for details on how to list available clocks combinations.\n\n After system reboot or driver reload applications clocks go back to their default value.\n See \\ref nvmlDeviceResetApplicationsClocks.\n\n @param device                               The identifier of the target device\n @param memClockMHz                          Requested memory clock in MHz\n @param graphicsClockMHz                     Requested graphics clock in MHz\n\n @return\n         - \\ref NVML_SUCCESS                 if new settings were successfully set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a memClockMHz and \\a graphicsClockMHz\n                                                 is not a valid clock combination\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetApplicationsClocks(
        device: nvmlDevice_t,
        memClockMHz: ::std::os::raw::c_uint,
        graphicsClockMHz: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the frequency monitor fault status for the device.\n\n For Ampere &tm; or newer fully supported devices.\n Requires root user.\n\n See \\ref nvmlClkMonStatus_t for details on decoding the status output.\n\n @param device                               The identifier of the target device\n @param status                               Reference in which to return the clkmon fault status\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a status has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a status is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetClkMonStatus()"]
    pub fn nvmlDeviceGetClkMonStatus(
        device: nvmlDevice_t,
        status: *mut nvmlClkMonStatus_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set new power limit of this device.\n\n For Kepler &tm; or newer fully supported devices.\n Requires root/admin permissions.\n\n See \\ref nvmlDeviceGetPowerManagementLimitConstraints to check the allowed ranges of values.\n\n \\note Limit is not persistent across reboots or driver unloads.\n Enable persistent mode to prevent driver from unloading when no application is using the device.\n\n @param device                               The identifier of the target device\n @param limit                                Power management limit in milliwatts to set\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a limit has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a defaultLimit is out of range\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceGetPowerManagementLimitConstraints\n @see nvmlDeviceGetPowerManagementDefaultLimit"]
    pub fn nvmlDeviceSetPowerManagementLimit(
        device: nvmlDevice_t,
        limit: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Sets new GOM. See \\a nvmlGpuOperationMode_t for details.\n\n For GK110 M-class and X-class Tesla &tm; products from the Kepler family.\n Modes \\ref NVML_GOM_LOW_DP and \\ref NVML_GOM_ALL_ON are supported on fully supported GeForce products.\n Not supported on Quadro &reg; and Tesla &tm; C-class products.\n Requires root/admin permissions.\n\n Changing GOMs requires a reboot.\n The reboot requirement might be removed in the future.\n\n Compute only GOMs don't support graphics acceleration. Under windows switching to these GOMs when\n pending driver model is WDDM is not supported. See \\ref nvmlDeviceSetDriverModel.\n\n @param device                               The identifier of the target device\n @param mode                                 Target GOM\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a mode has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode incorrect\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support GOM or specific mode\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlGpuOperationMode_t\n @see nvmlDeviceGetGpuOperationMode"]
    pub fn nvmlDeviceSetGpuOperationMode(
        device: nvmlDevice_t,
        mode: nvmlGpuOperationMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Changes the root/admin restructions on certain APIs. See \\a nvmlRestrictedAPI_t for the list of supported APIs.\n This method can be used by a root/admin user to give non-root/admin access to certain otherwise-restricted APIs.\n The new setting lasts for the lifetime of the NVIDIA driver; it is not persistent. See \\a nvmlDeviceGetAPIRestriction\n to query the current restriction settings.\n\n For Kepler &tm; or newer fully supported devices.\n Requires root/admin permissions.\n\n @param device                               The identifier of the target device\n @param apiType                              Target API type for this operation\n @param isRestricted                         The target restriction\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a isRestricted has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a apiType incorrect\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support changing API restrictions or the device does not support\n                                                 the feature that api restrictions are being set for (E.G. Enabling/disabling auto\n                                                 boosted clocks is not supported by the device)\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlRestrictedAPI_t"]
    pub fn nvmlDeviceSetAPIRestriction(
        device: nvmlDevice_t,
        apiType: nvmlRestrictedAPI_t,
        isRestricted: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Enables or disables per process accounting.\n\n For Kepler &tm; or newer fully supported devices.\n Requires root/admin permissions.\n\n @note This setting is not persistent and will default to disabled after driver unloads.\n       Enable persistence mode to be sure the setting doesn't switch off to disabled.\n\n @note Enabling accounting mode has no negative impact on the GPU performance.\n\n @note Disabling accounting clears all accounting pids information.\n\n @note On MIG-enabled GPUs, accounting mode would be set to DISABLED and changing it is not supported.\n\n See \\ref nvmlDeviceGetAccountingMode\n See \\ref nvmlDeviceGetAccountingStats\n See \\ref nvmlDeviceClearAccountingPids\n\n @param device                               The identifier of the target device\n @param mode                                 The target accounting mode\n\n @return\n         - \\ref NVML_SUCCESS                 if the new mode has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a mode are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetAccountingMode(
        device: nvmlDevice_t,
        mode: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Clears accounting information about all processes that have already terminated.\n\n For Kepler &tm; or newer fully supported devices.\n Requires root/admin permissions.\n\n See \\ref nvmlDeviceGetAccountingMode\n See \\ref nvmlDeviceGetAccountingStats\n See \\ref nvmlDeviceSetAccountingMode\n\n @param device                               The identifier of the target device\n\n @return\n         - \\ref NVML_SUCCESS                 if accounting information has been cleared\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceClearAccountingPids(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the state of the device's NvLink for the link specified\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param link                                 Specifies the NvLink link to be queried\n @param isActive                             \\a nvmlEnableState_t where NVML_FEATURE_ENABLED indicates that\n                                             the link is active and NVML_FEATURE_DISABLED indicates it\n                                             is inactive\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a isActive has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a link is invalid or \\a isActive is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkState(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        isActive: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the version of the device's NvLink for the link specified\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param link                                 Specifies the NvLink link to be queried\n @param version                              Requested NvLink version\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a version has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a link is invalid or \\a version is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkVersion(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        version: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the requested capability from the device's NvLink for the link specified\n Please refer to the \\a nvmlNvLinkCapability_t structure for the specific caps that can be queried\n The return value should be treated as a boolean.\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param link                                 Specifies the NvLink link to be queried\n @param capability                           Specifies the \\a nvmlNvLinkCapability_t to be queried\n @param capResult                            A boolean for the queried capability indicating that feature is available\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a capResult has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a link, or \\a capability is invalid or \\a capResult is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkCapability(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        capability: nvmlNvLinkCapability_t,
        capResult: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the PCI information for the remote node on a NvLink link\n Note: pciSubSystemId is not filled in this function and is indeterminate\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param link                                 Specifies the NvLink link to be queried\n @param pci                                  \\a nvmlPciInfo_t of the remote node for the specified link\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a pci has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a link is invalid or \\a pci is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkRemotePciInfo_v2(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the specified error counter value\n Please refer to \\a nvmlNvLinkErrorCounter_t for error counters that are available\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param link                                 Specifies the NvLink link to be queried\n @param counter                              Specifies the NvLink counter to be queried\n @param counterValue                         Returned counter value\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a counter has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a link, or \\a counter is invalid or \\a counterValue is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkErrorCounter(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: nvmlNvLinkErrorCounter_t,
        counterValue: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Resets all error counters to zero\n Please refer to \\a nvmlNvLinkErrorCounter_t for the list of error counters that are reset\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param link                                 Specifies the NvLink link to be queried\n\n @return\n         - \\ref NVML_SUCCESS                 if the reset is successful\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a link is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceResetNvLinkErrorCounters(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Deprecated: Setting utilization counter control is no longer supported.\n\n Set the NVLINK utilization counter control information for the specified counter, 0 or 1.\n Please refer to \\a nvmlNvLinkUtilizationControl_t for the structure definition.  Performs a reset\n of the counters if the reset parameter is non-zero.\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param counter                              Specifies the counter that should be set (0 or 1).\n @param link                                 Specifies the NvLink link to be queried\n @param control                              A reference to the \\a nvmlNvLinkUtilizationControl_t to set\n @param reset                                Resets the counters on set if non-zero\n\n @return\n         - \\ref NVML_SUCCESS                 if the control has been set successfully\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a counter, \\a link, or \\a control is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetNvLinkUtilizationControl(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: ::std::os::raw::c_uint,
        control: *mut nvmlNvLinkUtilizationControl_t,
        reset: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Deprecated: Getting utilization counter control is no longer supported.\n\n Get the NVLINK utilization counter control information for the specified counter, 0 or 1.\n Please refer to \\a nvmlNvLinkUtilizationControl_t for the structure definition\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param counter                              Specifies the counter that should be set (0 or 1).\n @param link                                 Specifies the NvLink link to be queried\n @param control                              A reference to the \\a nvmlNvLinkUtilizationControl_t to place information\n\n @return\n         - \\ref NVML_SUCCESS                 if the control has been set successfully\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a counter, \\a link, or \\a control is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkUtilizationControl(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: ::std::os::raw::c_uint,
        control: *mut nvmlNvLinkUtilizationControl_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Deprecated: Use \\ref nvmlDeviceGetFieldValues with NVML_FI_DEV_NVLINK_THROUGHPUT_* as field values instead.\n\n Retrieve the NVLINK utilization counter based on the current control for a specified counter.\n In general it is good practice to use \\a nvmlDeviceSetNvLinkUtilizationControl\n  before reading the utilization counters as they have no default state\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param link                                 Specifies the NvLink link to be queried\n @param counter                              Specifies the counter that should be read (0 or 1).\n @param rxcounter                            Receive counter return value\n @param txcounter                            Transmit counter return value\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a rxcounter and \\a txcounter have been successfully set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a counter, or \\a link is invalid or \\a rxcounter or \\a txcounter are NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkUtilizationCounter(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: ::std::os::raw::c_uint,
        rxcounter: *mut ::std::os::raw::c_ulonglong,
        txcounter: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Deprecated: Freezing NVLINK utilization counters is no longer supported.\n\n Freeze the NVLINK utilization counters\n Both the receive and transmit counters are operated on by this function\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param link                                 Specifies the NvLink link to be queried\n @param counter                              Specifies the counter that should be frozen (0 or 1).\n @param freeze                               NVML_FEATURE_ENABLED = freeze the receive and transmit counters\n                                             NVML_FEATURE_DISABLED = unfreeze the receive and transmit counters\n\n @return\n         - \\ref NVML_SUCCESS                 if counters were successfully frozen or unfrozen\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a link, \\a counter, or \\a freeze is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceFreezeNvLinkUtilizationCounter(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: ::std::os::raw::c_uint,
        freeze: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Deprecated: Resetting NVLINK utilization counters is no longer supported.\n\n Reset the NVLINK utilization counters\n Both the receive and transmit counters are operated on by this function\n\n For Pascal &tm; or newer fully supported devices.\n\n @param device                               The identifier of the target device\n @param link                                 Specifies the NvLink link to be reset\n @param counter                              Specifies the counter that should be reset (0 or 1)\n\n @return\n         - \\ref NVML_SUCCESS                 if counters were successfully reset\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a link, or \\a counter is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceResetNvLinkUtilizationCounter(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get the NVLink device type of the remote device connected over the given link.\n\n @param device                                The device handle of the target GPU\n @param link                                  The NVLink link index on the target GPU\n @param pNvLinkDeviceType                     Pointer in which the output remote device type is returned\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a pNvLinkDeviceType has been set\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_NOT_SUPPORTED      if NVLink is not supported\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device or \\a link is invalid, or\n                                              \\a pNvLinkDeviceType is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is\n                                              otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkRemoteDeviceType(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        pNvLinkDeviceType: *mut nvmlIntNvLinkDeviceType_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Create an empty set of events.\n Event set should be freed by \\ref nvmlEventSetFree\n\n For Fermi &tm; or newer fully supported devices.\n @param set                                  Reference in which to return the event handle\n\n @return\n         - \\ref NVML_SUCCESS                 if the event has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a set is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlEventSetFree"]
    pub fn nvmlEventSetCreate(set: *mut nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Starts recording of events on a specified devices and add the events to specified \\ref nvmlEventSet_t\n\n For Fermi &tm; or newer fully supported devices.\n Ecc events are available only on ECC enabled devices (see \\ref nvmlDeviceGetTotalEccErrors)\n Power capping events are available only on Power Management enabled devices (see \\ref nvmlDeviceGetPowerManagementMode)\n\n For Linux only.\n\n \\b IMPORTANT: Operations on \\a set are not thread safe\n\n This call starts recording of events on specific device.\n All events that occurred before this call are not recorded.\n Checking if some event occurred can be done with \\ref nvmlEventSetWait_v2\n\n If function reports NVML_ERROR_UNKNOWN, event set is in undefined state and should be freed.\n If function reports NVML_ERROR_NOT_SUPPORTED, event set can still be used. None of the requested eventTypes\n     are registered in that case.\n\n @param device                               The identifier of the target device\n @param eventTypes                           Bitmask of \\ref nvmlEventType to record\n @param set                                  Set to which add new event types\n\n @return\n         - \\ref NVML_SUCCESS                 if the event has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a eventTypes is invalid or \\a set is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the platform does not support this feature or some of requested event types\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlEventType\n @see nvmlDeviceGetSupportedEventTypes\n @see nvmlEventSetWait\n @see nvmlEventSetFree"]
    pub fn nvmlDeviceRegisterEvents(
        device: nvmlDevice_t,
        eventTypes: ::std::os::raw::c_ulonglong,
        set: nvmlEventSet_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns information about events supported on device\n\n For Fermi &tm; or newer fully supported devices.\n\n Events are not supported on Windows. So this function returns an empty mask in \\a eventTypes on Windows.\n\n @param device                               The identifier of the target device\n @param eventTypes                           Reference in which to return bitmask of supported events\n\n @return\n         - \\ref NVML_SUCCESS                 if the eventTypes has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a eventType is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlEventType\n @see nvmlDeviceRegisterEvents"]
    pub fn nvmlDeviceGetSupportedEventTypes(
        device: nvmlDevice_t,
        eventTypes: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Waits on events and delivers events\n\n For Fermi &tm; or newer fully supported devices.\n\n If some events are ready to be delivered at the time of the call, function returns immediately.\n If there are no events ready to be delivered, function sleeps till event arrives\n but not longer than specified timeout. This function in certain conditions can return before\n specified timeout passes (e.g. when interrupt arrives)\n\n On Windows, in case of xid error, the function returns the most recent xid error type seen by the system.\n If there are multiple xid errors generated before nvmlEventSetWait is invoked then the last seen xid error\n type is returned for all xid error events.\n\n On Linux, every xid error event would return the associated event data and other information if applicable.\n\n In MIG mode, if device handle is provided, the API reports all the events for the available instances,\n only if the caller has appropriate privileges. In absence of required privileges, only the events which\n affect all the instances (i.e. whole device) are reported.\n\n This API does not currently support per-instance event reporting using MIG device handles.\n\n @param set                                  Reference to set of events to wait on\n @param data                                 Reference in which to return event data\n @param timeoutms                            Maximum amount of wait time in milliseconds for registered event\n\n @return\n         - \\ref NVML_SUCCESS                 if the data has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a data is NULL\n         - \\ref NVML_ERROR_TIMEOUT           if no event arrived in specified timeout or interrupt arrived\n         - \\ref NVML_ERROR_GPU_IS_LOST       if a GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlEventType\n @see nvmlDeviceRegisterEvents"]
    pub fn nvmlEventSetWait_v2(
        set: nvmlEventSet_t,
        data: *mut nvmlEventData_t,
        timeoutms: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Releases events in the set\n\n For Fermi &tm; or newer fully supported devices.\n\n @param set                                  Reference to events to be released\n\n @return\n         - \\ref NVML_SUCCESS                 if the event has been successfully released\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlDeviceRegisterEvents"]
    pub fn nvmlEventSetFree(set: nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Modify the drain state of a GPU.  This method forces a GPU to no longer accept new incoming requests.\n Any new NVML process will no longer see this GPU.  Persistence mode for this GPU must be turned off before\n this call is made.\n Must be called as administrator.\n For Linux only.\n\n For Pascal &tm; or newer fully supported devices.\n Some Kepler devices supported.\n\n @param pciInfo                              The PCI address of the GPU drain state to be modified\n @param newState                             The drain state that should be entered, see \\ref nvmlEnableState_t\n\n @return\n         - \\ref NVML_SUCCESS                 if counters were successfully reset\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a nvmlIndex or \\a newState is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation\n         - \\ref NVML_ERROR_IN_USE            if the device has persistence mode turned on\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceModifyDrainState(
        pciInfo: *mut nvmlPciInfo_t,
        newState: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Query the drain state of a GPU.  This method is used to check if a GPU is in a currently draining\n state.\n For Linux only.\n\n For Pascal &tm; or newer fully supported devices.\n Some Kepler devices supported.\n\n @param pciInfo                              The PCI address of the GPU drain state to be queried\n @param currentState                         The current drain state for this GPU, see \\ref nvmlEnableState_t\n\n @return\n         - \\ref NVML_SUCCESS                 if counters were successfully reset\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a nvmlIndex or \\a currentState is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceQueryDrainState(
        pciInfo: *mut nvmlPciInfo_t,
        currentState: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " This method will remove the specified GPU from the view of both NVML and the NVIDIA kernel driver\n as long as no other processes are attached. If other processes are attached, this call will return\n NVML_ERROR_IN_USE and the GPU will be returned to its original \"draining\" state. Note: the\n only situation where a process can still be attached after nvmlDeviceModifyDrainState() is called\n to initiate the draining state is if that process was using, and is still using, a GPU before the\n call was made. Also note, persistence mode counts as an attachment to the GPU thus it must be disabled\n prior to this call.\n\n For long-running NVML processes please note that this will change the enumeration of current GPUs.\n For example, if there are four GPUs present and GPU1 is removed, the new enumeration will be 0-2.\n Also, device handles after the removed GPU will not be valid and must be re-established.\n Must be run as administrator.\n For Linux only.\n\n For Pascal &tm; or newer fully supported devices.\n Some Kepler devices supported.\n\n @param pciInfo                              The PCI address of the GPU to be removed\n @param gpuState                             Whether the GPU is to be removed, from the OS\n                                             see \\ref nvmlDetachGpuState_t\n @param linkState                            Requested upstream PCIe link state, see \\ref nvmlPcieLinkState_t\n\n @return\n         - \\ref NVML_SUCCESS                 if counters were successfully reset\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a nvmlIndex is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature\n         - \\ref NVML_ERROR_IN_USE            if the device is still in use and cannot be removed"]
    pub fn nvmlDeviceRemoveGpu_v2(
        pciInfo: *mut nvmlPciInfo_t,
        gpuState: nvmlDetachGpuState_t,
        linkState: nvmlPcieLinkState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Request the OS and the NVIDIA kernel driver to rediscover a portion of the PCI subsystem looking for GPUs that\n were previously removed. The portion of the PCI tree can be narrowed by specifying a domain, bus, and device.\n If all are zeroes then the entire PCI tree will be searched.  Please note that for long-running NVML processes\n the enumeration will change based on how many GPUs are discovered and where they are inserted in bus order.\n\n In addition, all newly discovered GPUs will be initialized and their ECC scrubbed which may take several seconds\n per GPU. Also, all device handles are no longer guaranteed to be valid post discovery.\n\n Must be run as administrator.\n For Linux only.\n\n For Pascal &tm; or newer fully supported devices.\n Some Kepler devices supported.\n\n @param pciInfo                              The PCI tree to be searched.  Only the domain, bus, and device\n                                             fields are used in this call.\n\n @return\n         - \\ref NVML_SUCCESS                 if counters were successfully reset\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a pciInfo is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the operating system does not support this feature\n         - \\ref NVML_ERROR_OPERATING_SYSTEM  if the operating system is denying this feature\n         - \\ref NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceDiscoverGpus(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Request values for a list of fields for a device. This API allows multiple fields to be queried at once.\n If any of the underlying fieldIds are populated by the same driver call, the results for those field IDs\n will be populated from a single call rather than making a driver call for each fieldId.\n\n @param device                               The device handle of the GPU to request field values for\n @param valuesCount                          Number of entries in values that should be retrieved\n @param values                               Array of \\a valuesCount structures to hold field values.\n                                             Each value's fieldId must be populated prior to this call\n\n @return\n         - \\ref NVML_SUCCESS                 if any values in \\a values were populated. Note that you must\n                                             check the nvmlReturn field of each value for each individual\n                                             status\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a values is NULL"]
    pub fn nvmlDeviceGetFieldValues(
        device: nvmlDevice_t,
        valuesCount: ::std::os::raw::c_int,
        values: *mut nvmlFieldValue_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " This method is used to get the virtualization mode corresponding to the GPU.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                    Identifier of the target device\n @param pVirtualMode              Reference to virtualization mode. One of NVML_GPU_VIRTUALIZATION_?\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a pVirtualMode is fetched\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device is invalid or \\a pVirtualMode is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetVirtualizationMode(
        device: nvmlDevice_t,
        pVirtualMode: *mut nvmlGpuVirtualizationMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries if SR-IOV host operation is supported on a vGPU supported device.\n\n Checks whether SR-IOV host capability is supported by the device and the\n driver, and indicates device is in SR-IOV mode if both of these conditions\n are true.\n\n @param device                                The identifier of the target device\n @param pHostVgpuMode                         Reference in which to return the current vGPU mode\n\n @return\n         - \\ref NVML_SUCCESS                  if device's vGPU mode has been successfully retrieved\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device handle is 0 or \\a pVgpuMode is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED      if \\a device doesn't support this feature.\n         - \\ref NVML_ERROR_UNKNOWN            if any unexpected error occurred"]
    pub fn nvmlDeviceGetHostVgpuMode(
        device: nvmlDevice_t,
        pHostVgpuMode: *mut nvmlHostVgpuMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " This method is used to set the virtualization mode corresponding to the GPU.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                    Identifier of the target device\n @param virtualMode               virtualization mode. One of NVML_GPU_VIRTUALIZATION_?\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a pVirtualMode is set\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device is invalid or \\a pVirtualMode is NULL\n         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_NOT_SUPPORTED      if setting of virtualization mode is not supported.\n         - \\ref NVML_ERROR_NO_PERMISSION      if setting of virtualization mode is not allowed for this client."]
    pub fn nvmlDeviceSetVirtualizationMode(
        device: nvmlDevice_t,
        virtualMode: nvmlGpuVirtualizationMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the vGPU Software licensable features.\n\n Identifies whether the system supports vGPU Software Licensing. If it does, return the list of licensable feature(s)\n and their current license status.\n\n @param device                    Identifier of the target device\n @param pGridLicensableFeatures   Pointer to structure in which vGPU software licensable features are returned\n\n @return\n         - \\ref NVML_SUCCESS                 if licensable features are successfully retrieved\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a pGridLicensableFeatures is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetGridLicensableFeatures_v4(
        device: nvmlDevice_t,
        pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current utilization and process ID\n\n For Maxwell &tm; or newer fully supported devices.\n\n Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running.\n Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer pointed at\n by \\a utilization. One utilization sample structure is returned per process running, that had some non-zero utilization\n during the last sample period. It includes the CPU timestamp at which  the samples were recorded. Individual utilization values\n are returned as \"unsigned int\" values.\n\n To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with\n \\a utilization set to NULL. The caller should allocate a buffer of size\n processSamplesCount * sizeof(nvmlProcessUtilizationSample_t). Invoke the function again with the allocated buffer passed\n in \\a utilization, and \\a processSamplesCount set to the number of entries the buffer is sized for.\n\n On successful return, the function updates \\a processSamplesCount with the number of process utilization sample\n structures that were actually written. This may differ from a previously read value as instances are created or\n destroyed.\n\n lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0\n to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp\n to a timeStamp retrieved from a previous query to read utilization since the previous query.\n\n @note On MIG-enabled GPUs, querying process utilization is not currently supported.\n\n @param device                    The identifier of the target device\n @param utilization               Pointer to caller-supplied buffer in which guest process utilization samples are returned\n @param processSamplesCount       Pointer to caller-supplied array size, and returns number of processes running\n @param lastSeenTimeStamp         Return only samples with timestamp greater than lastSeenTimeStamp.\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a utilization has been populated\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a utilization is NULL, or \\a samplingPeriodUs is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_NOT_FOUND         if sample entries are not found\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetProcessUtilization(
        device: nvmlDevice_t,
        utilization: *mut nvmlProcessUtilizationSample_t,
        processSamplesCount: *mut ::std::os::raw::c_uint,
        lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve GSP firmware version.\n\n The caller passes in buffer via \\a version and corresponding GSP firmware numbered version\n is returned with the same parameter in string format.\n\n @param device                               Device handle\n @param version                              The retrieved GSP firmware version\n\n @return\n         - \\ref NVML_SUCCESS                 if GSP firmware version is sucessfully retrieved\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or GSP \\a version pointer is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if GSP firmware is not enabled for GPU\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetGspFirmwareVersion(
        device: nvmlDevice_t,
        version: *mut ::std::os::raw::c_char,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve GSP firmware mode.\n\n The caller passes in integer pointers. GSP firmware enablement and default mode information is returned with\n corresponding parameters. The return value in \\a isEnabled and \\a defaultMode should be treated as boolean.\n\n @param device                               Device handle\n @param isEnabled                            Pointer to specify if GSP firmware is enabled\n @param defaultMode                          Pointer to specify if GSP firmware is supported by default on \\a device\n\n @return\n         - \\ref NVML_SUCCESS                 if GSP firmware mode is sucessfully retrieved\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or any of \\a isEnabled or \\a defaultMode is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetGspFirmwareMode(
        device: nvmlDevice_t,
        isEnabled: *mut ::std::os::raw::c_uint,
        defaultMode: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the supported vGPU types on a physical GPU (device).\n\n An array of supported vGPU types for the physical GPU indicated by \\a device is returned in the caller-supplied buffer\n pointed at by \\a vgpuTypeIds. The element count of nvmlVgpuTypeId_t array is passed in \\a vgpuCount, and \\a vgpuCount\n is used to return the number of vGPU types written to the buffer.\n\n If the supplied buffer is not large enough to accomodate the vGPU type array, the function returns\n NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuTypeId_t array required in \\a vgpuCount.\n To query the number of vGPU types supported for the GPU, call this function with *vgpuCount = 0.\n The code will return NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU types are supported.\n\n @param device                   The identifier of the target device\n @param vgpuCount                Pointer to caller-supplied array size, and returns number of vGPU types\n @param vgpuTypeIds              Pointer to caller-supplied array in which to return list of vGPU types\n\n @return\n         - \\ref NVML_SUCCESS                      successful completion\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE      \\a vgpuTypeIds buffer is too small, array element count is returned in \\a vgpuCount\n         - \\ref NVML_ERROR_INVALID_ARGUMENT       if \\a vgpuCount is NULL or \\a device is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED          if vGPU is not supported by the device\n         - \\ref NVML_ERROR_UNKNOWN                on any unexpected error"]
    pub fn nvmlDeviceGetSupportedVgpus(
        device: nvmlDevice_t,
        vgpuCount: *mut ::std::os::raw::c_uint,
        vgpuTypeIds: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the currently creatable vGPU types on a physical GPU (device).\n\n An array of creatable vGPU types for the physical GPU indicated by \\a device is returned in the caller-supplied buffer\n pointed at by \\a vgpuTypeIds. The element count of nvmlVgpuTypeId_t array is passed in \\a vgpuCount, and \\a vgpuCount\n is used to return the number of vGPU types written to the buffer.\n\n The creatable vGPU types for a device may differ over time, as there may be restrictions on what type of vGPU types\n can concurrently run on a device.  For example, if only one vGPU type is allowed at a time on a device, then the creatable\n list will be restricted to whatever vGPU type is already running on the device.\n\n If the supplied buffer is not large enough to accomodate the vGPU type array, the function returns\n NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuTypeId_t array required in \\a vgpuCount.\n To query the number of vGPU types createable for the GPU, call this function with *vgpuCount = 0.\n The code will return NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU types are creatable.\n\n @param device                   The identifier of the target device\n @param vgpuCount                Pointer to caller-supplied array size, and returns number of vGPU types\n @param vgpuTypeIds              Pointer to caller-supplied array in which to return list of vGPU types\n\n @return\n         - \\ref NVML_SUCCESS                      successful completion\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE      \\a vgpuTypeIds buffer is too small, array element count is returned in \\a vgpuCount\n         - \\ref NVML_ERROR_INVALID_ARGUMENT       if \\a vgpuCount is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED          if vGPU is not supported by the device\n         - \\ref NVML_ERROR_UNKNOWN                on any unexpected error"]
    pub fn nvmlDeviceGetCreatableVgpus(
        device: nvmlDevice_t,
        vgpuCount: *mut ::std::os::raw::c_uint,
        vgpuTypeIds: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the class of a vGPU type. It will not exceed 64 characters in length (including the NUL terminator).\n See \\ref nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuTypeId               Handle to vGPU type\n @param vgpuTypeClass            Pointer to string array to return class in\n @param size                     Size of string\n\n @return\n         - \\ref NVML_SUCCESS                   successful completion\n         - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a vgpuTypeId is invalid, or \\a vgpuTypeClass is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE   if \\a size is too small\n         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlVgpuTypeGetClass(
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeClass: *mut ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the vGPU type name.\n\n The name is an alphanumeric string that denotes a particular vGPU, e.g. GRID M60-2Q. It will not\n exceed 64 characters in length (including the NUL terminator).  See \\ref\n nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuTypeId               Handle to vGPU type\n @param vgpuTypeName             Pointer to buffer to return name\n @param size                     Size of buffer\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a name is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a size is too small\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetName(
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeName: *mut ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the GPU Instance Profile ID for the given vGPU type ID.\n The API will return a valid GPU Instance Profile ID for the MIG capable vGPU types, else INVALID_GPU_INSTANCE_PROFILE_ID is\n returned.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuTypeId               Handle to vGPU type\n @param gpuInstanceProfileId     GPU Instance Profile ID\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if \\a device is not in vGPU Host virtualization mode\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a gpuInstanceProfileId is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetGpuInstanceProfileId(
        vgpuTypeId: nvmlVgpuTypeId_t,
        gpuInstanceProfileId: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the device ID of a vGPU type.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuTypeId               Handle to vGPU type\n @param deviceID                 Device ID and vendor ID of the device contained in single 32 bit value\n @param subsystemID              Subsytem ID and subsytem vendor ID of the device contained in single 32 bit value\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a deviceId or \\a subsystemID are NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetDeviceID(
        vgpuTypeId: nvmlVgpuTypeId_t,
        deviceID: *mut ::std::os::raw::c_ulonglong,
        subsystemID: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the vGPU framebuffer size in bytes.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuTypeId               Handle to vGPU type\n @param fbSize                   Pointer to framebuffer size in bytes\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a fbSize is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetFramebufferSize(
        vgpuTypeId: nvmlVgpuTypeId_t,
        fbSize: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve count of vGPU's supported display heads.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuTypeId               Handle to vGPU type\n @param numDisplayHeads          Pointer to number of display heads\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a numDisplayHeads is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetNumDisplayHeads(
        vgpuTypeId: nvmlVgpuTypeId_t,
        numDisplayHeads: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve vGPU display head's maximum supported resolution.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuTypeId               Handle to vGPU type\n @param displayIndex             Zero-based index of display head\n @param xdim                     Pointer to maximum number of pixels in X dimension\n @param ydim                     Pointer to maximum number of pixels in Y dimension\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a xdim or \\a ydim are NULL, or \\a displayIndex\n                                             is out of range.\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetResolution(
        vgpuTypeId: nvmlVgpuTypeId_t,
        displayIndex: ::std::os::raw::c_uint,
        xdim: *mut ::std::os::raw::c_uint,
        ydim: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve license requirements for a vGPU type\n\n The license type and version required to run the specified vGPU type is returned as an alphanumeric string, in the form\n \"<license name>,<version>\", for example \"GRID-Virtual-PC,2.0\". If a vGPU is runnable with* more than one type of license,\n the licenses are delimited by a semicolon, for example \"GRID-Virtual-PC,2.0;GRID-Virtual-WS,2.0;GRID-Virtual-WS-Ext,2.0\".\n\n The total length of the returned string will not exceed 128 characters, including the NUL terminator.\n See \\ref nvmlVgpuConstants::NVML_GRID_LICENSE_BUFFER_SIZE.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuTypeId               Handle to vGPU type\n @param vgpuTypeLicenseString    Pointer to buffer to return license info\n @param size                     Size of \\a vgpuTypeLicenseString buffer\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a vgpuTypeLicenseString is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a size is too small\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetLicense(
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeLicenseString: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the static frame rate limit value of the vGPU type\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuTypeId               Handle to vGPU type\n @param frameRateLimit           Reference to return the frame rate limit value\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a frameRateLimit is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetFrameRateLimit(
        vgpuTypeId: nvmlVgpuTypeId_t,
        frameRateLimit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the maximum number of vGPU instances creatable on a device for given vGPU type\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                   The identifier of the target device\n @param vgpuTypeId               Handle to vGPU type\n @param vgpuInstanceCount        Pointer to get the max number of vGPU instances\n                                 that can be created on a deicve for given vgpuTypeId\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid or is not supported on target device,\n                                             or \\a vgpuInstanceCount is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetMaxInstances(
        device: nvmlDevice_t,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuInstanceCount: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the maximum number of vGPU instances supported per VM for given vGPU type\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuTypeId               Handle to vGPU type\n @param vgpuInstanceCountPerVm   Pointer to get the max number of vGPU instances supported per VM for given \\a vgpuTypeId\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a vgpuInstanceCountPerVm is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetMaxInstancesPerVm(
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuInstanceCountPerVm: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the active vGPU instances on a device.\n\n An array of active vGPU instances is returned in the caller-supplied buffer pointed at by \\a vgpuInstances. The\n array elememt count is passed in \\a vgpuCount, and \\a vgpuCount is used to return the number of vGPU instances\n written to the buffer.\n\n If the supplied buffer is not large enough to accomodate the vGPU instance array, the function returns\n NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuInstance_t array required in \\a vgpuCount.\n To query the number of active vGPU instances, call this function with *vgpuCount = 0.  The code will return\n NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU Types are supported.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param device                   The identifier of the target device\n @param vgpuCount                Pointer which passes in the array size as well as get\n                                 back the number of types\n @param vgpuInstances            Pointer to array in which to return list of vGPU instances\n\n @return\n         - \\ref NVML_SUCCESS                  successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device is invalid, or \\a vgpuCount is NULL\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE  if \\a size is too small\n         - \\ref NVML_ERROR_NOT_SUPPORTED      if vGPU is not supported by the device\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetActiveVgpus(
        device: nvmlDevice_t,
        vgpuCount: *mut ::std::os::raw::c_uint,
        vgpuInstances: *mut nvmlVgpuInstance_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the VM ID associated with a vGPU instance.\n\n The VM ID is returned as a string, not exceeding 80 characters in length (including the NUL terminator).\n See \\ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.\n\n The format of the VM ID varies by platform, and is indicated by the type identifier returned in \\a vmIdType.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuInstance             Identifier of the target vGPU instance\n @param vmId                     Pointer to caller-supplied buffer to hold VM ID\n @param size                     Size of buffer in bytes\n @param vmIdType                 Pointer to hold VM ID type\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vmId or \\a vmIdType is NULL, or \\a vgpuInstance is 0\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a size is too small\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetVmID(
        vgpuInstance: nvmlVgpuInstance_t,
        vmId: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
        vmIdType: *mut nvmlVgpuVmIdType_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the UUID of a vGPU instance.\n\n The UUID is a globally unique identifier associated with the vGPU, and is returned as a 5-part hexadecimal string,\n not exceeding 80 characters in length (including the NULL terminator).\n See \\ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuInstance             Identifier of the target vGPU instance\n @param uuid                     Pointer to caller-supplied buffer to hold vGPU UUID\n @param size                     Size of buffer in bytes\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a uuid is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a size is too small\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetUUID(
        vgpuInstance: nvmlVgpuInstance_t,
        uuid: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the NVIDIA driver version installed in the VM associated with a vGPU.\n\n The version is returned as an alphanumeric string in the caller-supplied buffer \\a version. The length of the version\n string will not exceed 80 characters in length (including the NUL terminator).\n See \\ref nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE.\n\n nvmlVgpuInstanceGetVmDriverVersion() may be called at any time for a vGPU instance. The guest VM driver version is\n returned as \"Not Available\" if no NVIDIA driver is installed in the VM, or the VM has not yet booted to the point where the\n NVIDIA driver is loaded and initialized.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuInstance             Identifier of the target vGPU instance\n @param version                  Caller-supplied buffer to return driver version string\n @param length                   Size of \\a version buffer\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a version has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetVmDriverVersion(
        vgpuInstance: nvmlVgpuInstance_t,
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the framebuffer usage in bytes.\n\n Framebuffer usage is the amont of vGPU framebuffer memory that is currently in use by the VM.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuInstance             The identifier of the target instance\n @param fbUsage                  Pointer to framebuffer usage in bytes\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a fbUsage is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetFbUsage(
        vgpuInstance: nvmlVgpuInstance_t,
        fbUsage: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " @deprecated Use \\ref nvmlVgpuInstanceGetLicenseInfo_v2.\n\n Retrieve the current licensing state of the vGPU instance.\n\n If the vGPU is currently licensed, \\a licensed is set to 1, otherwise it is set to 0.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuInstance             Identifier of the target vGPU instance\n @param licensed                 Reference to return the licensing status\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a licensed has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a licensed is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetLicenseStatus(
        vgpuInstance: nvmlVgpuInstance_t,
        licensed: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the vGPU type of a vGPU instance.\n\n Returns the vGPU type ID of vgpu assigned to the vGPU instance.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuInstance             Identifier of the target vGPU instance\n @param vgpuTypeId               Reference to return the vgpuTypeId\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a vgpuTypeId has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a vgpuTypeId is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetType(
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuTypeId: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the frame rate limit set for the vGPU instance.\n\n Returns the value of the frame rate limit set for the vGPU instance\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuInstance             Identifier of the target vGPU instance\n @param frameRateLimit           Reference to return the frame rate limit\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a frameRateLimit has been set\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a frameRateLimit is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetFrameRateLimit(
        vgpuInstance: nvmlVgpuInstance_t,
        frameRateLimit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the current ECC mode of vGPU instance.\n\n @param vgpuInstance            The identifier of the target vGPU instance\n @param eccMode                 Reference in which to return the current ECC mode\n\n @return\n         - \\ref NVML_SUCCESS                 if the vgpuInstance's ECC mode has been successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a mode is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetEccMode(
        vgpuInstance: nvmlVgpuInstance_t,
        eccMode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param vgpuInstance             Identifier of the target vGPU instance\n @param encoderCapacity          Reference to an unsigned int for the encoder capacity\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a encoderCapacity has been retrived\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a encoderQueryType is invalid\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetEncoderCapacity(
        vgpuInstance: nvmlVgpuInstance_t,
        encoderCapacity: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param vgpuInstance             Identifier of the target vGPU instance\n @param encoderCapacity          Unsigned int for the encoder capacity value\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a encoderCapacity has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a encoderCapacity is out of range of 0-100.\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceSetEncoderCapacity(
        vgpuInstance: nvmlVgpuInstance_t,
        encoderCapacity: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current encoder statistics of a vGPU Instance\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param vgpuInstance                      Identifier of the target vGPU instance\n @param sessionCount                      Reference to an unsigned int for count of active encoder sessions\n @param averageFps                        Reference to an unsigned int for trailing average FPS of all active sessions\n @param averageLatency                    Reference to an unsigned int for encode latency in microseconds\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a sessionCount, \\a averageFps and \\a averageLatency is fetched\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a sessionCount , or \\a averageFps or \\a averageLatency is NULL\n                                              or \\a vgpuInstance is 0.\n         - \\ref NVML_ERROR_NOT_FOUND          if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlVgpuInstanceGetEncoderStats(
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        averageFps: *mut ::std::os::raw::c_uint,
        averageLatency: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves information about all active encoder sessions on a vGPU Instance.\n\n An array of active encoder sessions is returned in the caller-supplied buffer pointed at by \\a sessionInfo. The\n array element count is passed in \\a sessionCount, and \\a sessionCount is used to return the number of sessions\n written to the buffer.\n\n If the supplied buffer is not large enough to accomodate the active session array, the function returns\n NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in \\a sessionCount.\n To query the number of active encoder sessions, call this function with *sessionCount = 0. The code will return\n NVML_SUCCESS with number of active encoder sessions updated in *sessionCount.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param vgpuInstance                      Identifier of the target vGPU instance\n @param sessionCount                      Reference to caller supplied array size, and returns\n                                          the number of sessions.\n @param sessionInfo                       Reference to caller supplied array in which the list\n                                          of session information us returned.\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a sessionInfo is fetched\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE  if \\a sessionCount is too small, array element count is\nreturned in \\a sessionCount\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a sessionCount is NULL, or \\a vgpuInstance is 0.\n         - \\ref NVML_ERROR_NOT_FOUND          if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlVgpuInstanceGetEncoderSessions(
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        sessionInfo: *mut nvmlEncoderSessionInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the active frame buffer capture sessions statistics of a vGPU Instance\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param vgpuInstance                      Identifier of the target vGPU instance\n @param fbcStats                          Reference to nvmlFBCStats_t structure contianing NvFBC stats\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a fbcStats is fetched\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a vgpuInstance is 0, or \\a fbcStats is NULL\n         - \\ref NVML_ERROR_NOT_FOUND          if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlVgpuInstanceGetFBCStats(
        vgpuInstance: nvmlVgpuInstance_t,
        fbcStats: *mut nvmlFBCStats_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves information about active frame buffer capture sessions on a vGPU Instance.\n\n An array of active FBC sessions is returned in the caller-supplied buffer pointed at by \\a sessionInfo. The\n array element count is passed in \\a sessionCount, and \\a sessionCount is used to return the number of sessions\n written to the buffer.\n\n If the supplied buffer is not large enough to accomodate the active session array, the function returns\n NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in \\a sessionCount.\n To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return\n NVML_SUCCESS with number of active FBC sessions updated in *sessionCount.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in \\a sessionInfo may\n       be zero if there are no new frames captured since the session started.\n\n @param vgpuInstance                      Identifier of the target vGPU instance\n @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions.\n @param sessionInfo                       Reference in which to return the session information\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a sessionInfo is fetched\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a vgpuInstance is 0, or \\a sessionCount is NULL.\n         - \\ref NVML_ERROR_NOT_FOUND          if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE  if \\a sessionCount is too small, array element count is returned in \\a sessionCount\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlVgpuInstanceGetFBCSessions(
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        sessionInfo: *mut nvmlFBCSessionInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the GPU Instance ID for the given vGPU Instance.\n The API will return a valid GPU Instance ID for MIG backed vGPU Instance, else INVALID_GPU_INSTANCE_ID is returned.\n\n For Kepler &tm; or newer fully supported devices.\n\n @param vgpuInstance                      Identifier of the target vGPU instance\n @param gpuInstanceId                     GPU Instance ID\n\n @return\n         - \\ref NVML_SUCCESS                  successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a vgpuInstance is 0, or \\a gpuInstanceId is NULL.\n         - \\ref NVML_ERROR_NOT_FOUND          if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlVgpuInstanceGetGpuInstanceId(
        vgpuInstance: nvmlVgpuInstance_t,
        gpuInstanceId: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the PCI Id of the given vGPU Instance i.e. the PCI Id of the GPU as seen inside the VM.\n\n The vGPU PCI id is returned as \"00000000:00:00.0\" if NVIDIA driver is not installed on the vGPU instance.\n\n @param vgpuInstance                         Identifier of the target vGPU instance\n @param vgpuPciId                            Caller-supplied buffer to return vGPU PCI Id string\n @param length                               Size of the vgpuPciId buffer\n\n @return\n         - \\ref NVML_SUCCESS                 if vGPU PCI Id is sucessfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a vgpuPciId is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_DRIVER_NOT_LOADED if NVIDIA driver is not running on the vGPU instance\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small, \\a length is set to required length\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetGpuPciId(
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuPciId: *mut ::std::os::raw::c_char,
        length: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the requested capability for a given vGPU type. Refer to the \\a nvmlVgpuCapability_t structure\n for the specific capabilities that can be queried. The return value in \\a capResult should be treated as\n a boolean, with a non-zero value indicating that the capability is supported.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param vgpuTypeId                           Handle to vGPU type\n @param capability                           Specifies the \\a nvmlVgpuCapability_t to be queried\n @param capResult                            A boolean for the queried capability indicating that feature is supported\n\n @return\n         - \\ref NVML_SUCCESS                 successful completion\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a capability is invalid, or \\a capResult is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetCapabilities(
        vgpuTypeId: nvmlVgpuTypeId_t,
        capability: nvmlVgpuCapability_t,
        capResult: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
#[doc = " Structure representing range of vGPU versions."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlVgpuVersion_st {
    #[doc = "!< Minimum vGPU version."]
    pub minVersion: ::std::os::raw::c_uint,
    #[doc = "!< Maximum vGPU version."]
    pub maxVersion: ::std::os::raw::c_uint,
}
#[doc = " Structure representing range of vGPU versions."]
pub type nvmlVgpuVersion_t = nvmlVgpuVersion_st;
#[doc = " vGPU metadata structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlVgpuMetadata_st {
    #[doc = "!< Current version of the structure"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Current revision of the structure"]
    pub revision: ::std::os::raw::c_uint,
    #[doc = "!< Current state of Guest-dependent fields"]
    pub guestInfoState: nvmlVgpuGuestInfoState_t,
    #[doc = "!< Version of driver installed in guest"]
    pub guestDriverVersion: [::std::os::raw::c_char; 80usize],
    #[doc = "!< Version of driver installed in host"]
    pub hostDriverVersion: [::std::os::raw::c_char; 80usize],
    #[doc = "!< Reserved for internal use"]
    pub reserved: [::std::os::raw::c_uint; 6usize],
    #[doc = "!< vGPU virtualizaion capabilities bitfileld"]
    pub vgpuVirtualizationCaps: ::std::os::raw::c_uint,
    #[doc = "!< vGPU version of guest driver"]
    pub guestVgpuVersion: ::std::os::raw::c_uint,
    #[doc = "!< Size of opaque data field in bytes"]
    pub opaqueDataSize: ::std::os::raw::c_uint,
    #[doc = "!< Opaque data"]
    pub opaqueData: [::std::os::raw::c_char; 4usize],
}
#[doc = " vGPU metadata structure."]
pub type nvmlVgpuMetadata_t = nvmlVgpuMetadata_st;
#[doc = " Physical GPU metadata structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlVgpuPgpuMetadata_st {
    #[doc = "!< Current version of the structure"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Current revision of the structure"]
    pub revision: ::std::os::raw::c_uint,
    #[doc = "!< Host driver version"]
    pub hostDriverVersion: [::std::os::raw::c_char; 80usize],
    #[doc = "!< Pgpu virtualizaion capabilities bitfileld"]
    pub pgpuVirtualizationCaps: ::std::os::raw::c_uint,
    #[doc = "!< Reserved for internal use"]
    pub reserved: [::std::os::raw::c_uint; 5usize],
    #[doc = "!< vGPU version range supported by host driver"]
    pub hostSupportedVgpuRange: nvmlVgpuVersion_t,
    #[doc = "!< Size of opaque data field in bytes"]
    pub opaqueDataSize: ::std::os::raw::c_uint,
    #[doc = "!< Opaque data"]
    pub opaqueData: [::std::os::raw::c_char; 4usize],
}
#[doc = " Physical GPU metadata structure"]
pub type nvmlVgpuPgpuMetadata_t = nvmlVgpuPgpuMetadata_st;
#[doc = "!< vGPU is not runnable"]
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_NONE:
    nvmlVgpuVmCompatibility_enum = 0;
#[doc = "!< vGPU is runnable from a cold / powered-off state (ACPI S5)"]
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_COLD:
    nvmlVgpuVmCompatibility_enum = 1;
#[doc = "!< vGPU is runnable from a hibernated state (ACPI S4)"]
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_HIBERNATE:
    nvmlVgpuVmCompatibility_enum = 2;
#[doc = "!< vGPU is runnable from a sleeped state (ACPI S3)"]
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_SLEEP:
    nvmlVgpuVmCompatibility_enum = 4;
#[doc = "!< vGPU is runnable from a live/paused (ACPI S0)"]
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_LIVE:
    nvmlVgpuVmCompatibility_enum = 8;
#[doc = " vGPU VM compatibility codes"]
pub type nvmlVgpuVmCompatibility_enum = ::std::os::raw::c_uint;
#[doc = " vGPU VM compatibility codes"]
pub use self::nvmlVgpuVmCompatibility_enum as nvmlVgpuVmCompatibility_t;
#[doc = "!< Compatibility is not limited."]
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_NONE:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 0;
#[doc = "!< ompatibility is limited by host driver version."]
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 1;
#[doc = "!< Compatibility is limited by guest driver version."]
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 2;
#[doc = "!< Compatibility is limited by GPU hardware."]
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_GPU:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 4;
#[doc = "!< Compatibility is limited by an undefined factor."]
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_OTHER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 2147483648;
#[doc = "  vGPU-pGPU compatibility limit codes"]
pub type nvmlVgpuPgpuCompatibilityLimitCode_enum = ::std::os::raw::c_uint;
#[doc = "  vGPU-pGPU compatibility limit codes"]
pub use self::nvmlVgpuPgpuCompatibilityLimitCode_enum as nvmlVgpuPgpuCompatibilityLimitCode_t;
#[doc = " vGPU-pGPU compatibility structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlVgpuPgpuCompatibility_st {
    #[doc = "!< Compatibility of vGPU VM. See \\ref nvmlVgpuVmCompatibility_t"]
    pub vgpuVmCompatibility: nvmlVgpuVmCompatibility_t,
    #[doc = "!< Limiting factor for vGPU-pGPU compatibility. See \\ref nvmlVgpuPgpuCompatibilityLimitCode_t"]
    pub compatibilityLimitCode: nvmlVgpuPgpuCompatibilityLimitCode_t,
}
#[doc = " vGPU-pGPU compatibility structure"]
pub type nvmlVgpuPgpuCompatibility_t = nvmlVgpuPgpuCompatibility_st;
extern "C" {
    #[doc = " Returns vGPU metadata structure for a running vGPU. The structure contains information about the vGPU and its associated VM\n such as the currently installed NVIDIA guest driver version, together with host driver version and an opaque data section\n containing internal state.\n\n nvmlVgpuInstanceGetMetadata() may be called at any time for a vGPU instance. Some fields in the returned structure are\n dependent on information obtained from the guest VM, which may not yet have reached a state where that information\n is available. The current state of these dependent fields is reflected in the info structure's \\ref nvmlVgpuGuestInfoState_t field.\n\n The VMM may choose to read and save the vGPU's VM info as persistent metadata associated with the VM, and provide\n it to Virtual GPU Manager when creating a vGPU for subsequent instances of the VM.\n\n The caller passes in a buffer via \\a vgpuMetadata, with the size of the buffer in \\a bufferSize. If the vGPU Metadata structure\n is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed\n in \\a bufferSize.\n\n @param vgpuInstance             vGPU instance handle\n @param vgpuMetadata             Pointer to caller-supplied buffer into which vGPU metadata is written\n @param bufferSize               Size of vgpuMetadata buffer\n\n @return\n         - \\ref NVML_SUCCESS                   vGPU metadata structure was successfully returned\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE   vgpuMetadata buffer is too small, required size is returned in \\a bufferSize\n         - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a bufferSize is NULL or \\a vgpuInstance is 0; if \\a vgpuMetadata is NULL and the value of \\a bufferSize is not 0.\n         - \\ref NVML_ERROR_NOT_FOUND           if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlVgpuInstanceGetMetadata(
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuMetadata: *mut nvmlVgpuMetadata_t,
        bufferSize: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns a vGPU metadata structure for the physical GPU indicated by \\a device. The structure contains information about\n the GPU and the currently installed NVIDIA host driver version that's controlling it, together with an opaque data section\n containing internal state.\n\n The caller passes in a buffer via \\a pgpuMetadata, with the size of the buffer in \\a bufferSize. If the \\a pgpuMetadata\n structure is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed\n in \\a bufferSize.\n\n @param device                The identifier of the target device\n @param pgpuMetadata          Pointer to caller-supplied buffer into which \\a pgpuMetadata is written\n @param bufferSize            Pointer to size of \\a pgpuMetadata buffer\n\n @return\n         - \\ref NVML_SUCCESS                   GPU metadata structure was successfully returned\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE   pgpuMetadata buffer is too small, required size is returned in \\a bufferSize\n         - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a bufferSize is NULL or \\a device is invalid; if \\a pgpuMetadata is NULL and the value of \\a bufferSize is not 0.\n         - \\ref NVML_ERROR_NOT_SUPPORTED       vGPU is not supported by the system\n         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlDeviceGetVgpuMetadata(
        device: nvmlDevice_t,
        pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
        bufferSize: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Takes a vGPU instance metadata structure read from \\ref nvmlVgpuInstanceGetMetadata(), and a vGPU metadata structure for a\n physical GPU read from \\ref nvmlDeviceGetVgpuMetadata(), and returns compatibility information of the vGPU instance and the\n physical GPU.\n\n The caller passes in a buffer via \\a compatibilityInfo, into which a compatibility information structure is written. The\n structure defines the states in which the vGPU / VM may be booted on the physical GPU. If the vGPU / VM compatibility\n with the physical GPU is limited, a limit code indicates the factor limiting compability.\n (see \\ref nvmlVgpuPgpuCompatibilityLimitCode_t for details).\n\n Note: vGPU compatibility does not take into account dynamic capacity conditions that may limit a system's ability to\n       boot a given vGPU or associated VM.\n\n @param vgpuMetadata          Pointer to caller-supplied vGPU metadata structure\n @param pgpuMetadata          Pointer to caller-supplied GPU metadata structure\n @param compatibilityInfo     Pointer to caller-supplied buffer to hold compatibility info\n\n @return\n         - \\ref NVML_SUCCESS                   vGPU metadata structure was successfully returned\n         - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a vgpuMetadata or \\a pgpuMetadata or \\a bufferSize are NULL\n         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlGetVgpuCompatibility(
        vgpuMetadata: *mut nvmlVgpuMetadata_t,
        pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
        compatibilityInfo: *mut nvmlVgpuPgpuCompatibility_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns the properties of the physical GPU indicated by the device in an ascii-encoded string format.\n\n The caller passes in a buffer via \\a pgpuMetadata, with the size of the buffer in \\a bufferSize. If the\n string is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed\n in \\a bufferSize.\n\n @param device                The identifier of the target device\n @param pgpuMetadata          Pointer to caller-supplied buffer into which \\a pgpuMetadata is written\n @param bufferSize            Pointer to size of \\a pgpuMetadata buffer\n\n @return\n         - \\ref NVML_SUCCESS                   GPU metadata structure was successfully returned\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE   \\a pgpuMetadata buffer is too small, required size is returned in \\a bufferSize\n         - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a bufferSize is NULL or \\a device is invalid; if \\a pgpuMetadata is NULL and the value of \\a bufferSize is not 0.\n         - \\ref NVML_ERROR_NOT_SUPPORTED       if vGPU is not supported by the system\n         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlDeviceGetPgpuMetadataString(
        device: nvmlDevice_t,
        pgpuMetadata: *mut ::std::os::raw::c_char,
        bufferSize: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Query the ranges of supported vGPU versions.\n\n This function gets the linear range of supported vGPU versions that is preset for the NVIDIA vGPU Manager and the range set by an administrator.\n If the preset range has not been overridden by \\ref nvmlSetVgpuVersion, both ranges are the same.\n\n The caller passes pointers to the following \\ref nvmlVgpuVersion_t structures, into which the NVIDIA vGPU Manager writes the ranges:\n 1. \\a supported structure that represents the preset range of vGPU versions supported by the NVIDIA vGPU Manager.\n 2. \\a current structure that represents the range of supported vGPU versions set by an administrator. By default, this range is the same as the preset range.\n\n @param supported  Pointer to the structure in which the preset range of vGPU versions supported by the NVIDIA vGPU Manager is written\n @param current    Pointer to the structure in which the range of supported vGPU versions set by an administrator is written\n\n @return\n - \\ref NVML_SUCCESS                 The vGPU version range structures were successfully obtained.\n - \\ref NVML_ERROR_NOT_SUPPORTED     The API is not supported.\n - \\ref NVML_ERROR_INVALID_ARGUMENT  The \\a supported parameter or the \\a current parameter is NULL.\n - \\ref NVML_ERROR_UNKNOWN           An error occurred while the data was being fetched."]
    pub fn nvmlGetVgpuVersion(
        supported: *mut nvmlVgpuVersion_t,
        current: *mut nvmlVgpuVersion_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Override the preset range of vGPU versions supported by the NVIDIA vGPU Manager with a range set by an administrator.\n\n This function configures the NVIDIA vGPU Manager with a range of supported vGPU versions set by an administrator. This range must be a subset of the\n preset range that the NVIDIA vGPU Manager supports. The custom range set by an administrator takes precedence over the preset range and is advertised to\n the guest VM for negotiating the vGPU version. See \\ref nvmlGetVgpuVersion for details of how to query the preset range of versions supported.\n\n This function takes a pointer to vGPU version range structure \\ref nvmlVgpuVersion_t as input to override the preset vGPU version range that the NVIDIA vGPU Manager supports.\n\n After host system reboot or driver reload, the range of supported versions reverts to the range that is preset for the NVIDIA vGPU Manager.\n\n @note 1. The range set by the administrator must be a subset of the preset range that the NVIDIA vGPU Manager supports. Otherwise, an error is returned.\n       2. If the range of supported guest driver versions does not overlap the range set by the administrator, the guest driver fails to load.\n       3. If the range of supported guest driver versions overlaps the range set by the administrator, the guest driver will load with a negotiated\n          vGPU version that is the maximum value in the overlapping range.\n       4. No VMs must be running on the host when this function is called. If a VM is running on the host, the call to this function fails.\n\n @param vgpuVersion   Pointer to a caller-supplied range of supported vGPU versions.\n\n @return\n - \\ref NVML_SUCCESS                 The preset range of supported vGPU versions was successfully overridden.\n - \\ref NVML_ERROR_NOT_SUPPORTED     The API is not supported.\n - \\ref NVML_ERROR_IN_USE            The range was not overridden because a VM is running on the host.\n - \\ref NVML_ERROR_INVALID_ARGUMENT  The \\a vgpuVersion parameter specifies a range that is outside the range supported by the NVIDIA vGPU Manager or if \\a vgpuVersion is NULL."]
    pub fn nvmlSetVgpuVersion(vgpuVersion: *mut nvmlVgpuVersion_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves current utilization for vGPUs on a physical GPU (device).\n\n For Kepler &tm; or newer fully supported devices.\n\n Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for vGPU instances running\n on a device. Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer\n pointed at by \\a utilizationSamples. One utilization sample structure is returned per vGPU instance, and includes the\n CPU timestamp at which the samples were recorded. Individual utilization values are returned as \"unsigned int\" values\n in nvmlValue_t unions. The function sets the caller-supplied \\a sampleValType to NVML_VALUE_TYPE_UNSIGNED_INT to\n indicate the returned value type.\n\n To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with\n \\a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance\n count in \\a vgpuInstanceSamplesCount, or NVML_SUCCESS if the current vGPU instance count is zero. The caller should allocate\n a buffer of size vgpuInstanceSamplesCount * sizeof(nvmlVgpuInstanceUtilizationSample_t). Invoke the function again with\n the allocated buffer passed in \\a utilizationSamples, and \\a vgpuInstanceSamplesCount set to the number of entries the\n buffer is sized for.\n\n On successful return, the function updates \\a vgpuInstanceSampleCount with the number of vGPU utilization sample\n structures that were actually written. This may differ from a previously read value as vGPU instances are created or\n destroyed.\n\n lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0\n to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp\n to a timeStamp retrieved from a previous query to read utilization since the previous query.\n\n @param device                        The identifier for the target device\n @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp.\n @param sampleValType                 Pointer to caller-supplied buffer to hold the type of returned sample values\n @param vgpuInstanceSamplesCount      Pointer to caller-supplied array size, and returns number of vGPU instances\n @param utilizationSamples            Pointer to caller-supplied buffer in which vGPU utilization samples are returned\n\n @return\n         - \\ref NVML_SUCCESS                 if utilization samples are successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a vgpuInstanceSamplesCount or \\a sampleValType is\n                                             NULL, or a sample count of 0 is passed with a non-NULL \\a utilizationSamples\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if supplied \\a vgpuInstanceSamplesCount is too small to return samples for all\n                                             vGPU instances currently executing on the device\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_NOT_FOUND         if sample entries are not found\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetVgpuUtilization(
        device: nvmlDevice_t,
        lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
        sampleValType: *mut nvmlValueType_t,
        vgpuInstanceSamplesCount: *mut ::std::os::raw::c_uint,
        utilizationSamples: *mut nvmlVgpuInstanceUtilizationSample_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves current utilization for processes running on vGPUs on a physical GPU (device).\n\n For Maxwell &tm; or newer fully supported devices.\n\n Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running on\n vGPU instances active on a device. Utilization values are returned as an array of utilization sample structures in the\n caller-supplied buffer pointed at by \\a utilizationSamples. One utilization sample structure is returned per process running\n on vGPU instances, that had some non-zero utilization during the last sample period. It includes the CPU timestamp at which\n the samples were recorded. Individual utilization values are returned as \"unsigned int\" values.\n\n To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with\n \\a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance\n count in \\a vgpuProcessSamplesCount. The caller should allocate a buffer of size\n vgpuProcessSamplesCount * sizeof(nvmlVgpuProcessUtilizationSample_t). Invoke the function again with\n the allocated buffer passed in \\a utilizationSamples, and \\a vgpuProcessSamplesCount set to the number of entries the\n buffer is sized for.\n\n On successful return, the function updates \\a vgpuSubProcessSampleCount with the number of vGPU sub process utilization sample\n structures that were actually written. This may differ from a previously read value depending on the number of processes that are active\n in any given sample period.\n\n lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0\n to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp\n to a timeStamp retrieved from a previous query to read utilization since the previous query.\n\n @param device                        The identifier for the target device\n @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp.\n @param vgpuProcessSamplesCount       Pointer to caller-supplied array size, and returns number of processes running on vGPU instances\n @param utilizationSamples            Pointer to caller-supplied buffer in which vGPU sub process utilization samples are returned\n\n @return\n         - \\ref NVML_SUCCESS                 if utilization samples are successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a vgpuProcessSamplesCount or a sample count of 0 is\n                                             passed with a non-NULL \\a utilizationSamples\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if supplied \\a vgpuProcessSamplesCount is too small to return samples for all\n                                             vGPU instances currently executing on the device\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_NOT_FOUND         if sample entries are not found\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetVgpuProcessUtilization(
        device: nvmlDevice_t,
        lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
        vgpuProcessSamplesCount: *mut ::std::os::raw::c_uint,
        utilizationSamples: *mut nvmlVgpuProcessUtilizationSample_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries the state of per process accounting mode on vGPU.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param vgpuInstance            The identifier of the target vGPU instance\n @param mode                    Reference in which to return the current accounting mode\n\n @return\n         - \\ref NVML_SUCCESS                 if the mode has been successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a mode is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature\n         - \\ref NVML_ERROR_DRIVER_NOT_LOADED if NVIDIA driver is not running on the vGPU instance\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetAccountingMode(
        vgpuInstance: nvmlVgpuInstance_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries list of processes running on vGPU that can be queried for accounting stats. The list of processes\n returned can be in running or terminated state.\n\n For Maxwell &tm; or newer fully supported devices.\n\n To just query the maximum number of processes that can be queried, call this function with *count = 0 and\n pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty.\n\n For more details see \\ref nvmlVgpuInstanceGetAccountingStats.\n\n @note In case of PID collision some processes might not be accessible before the circular buffer is full.\n\n @param vgpuInstance            The identifier of the target vGPU instance\n @param count                   Reference in which to provide the \\a pids array size, and\n                                to return the number of elements ready to be queried\n @param pids                    Reference in which to return list of process ids\n\n @return\n         - \\ref NVML_SUCCESS                 if pids were successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a count is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a count is too small (\\a count is set to expected value)\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error\n\n @see nvmlVgpuInstanceGetAccountingPids"]
    pub fn nvmlVgpuInstanceGetAccountingPids(
        vgpuInstance: nvmlVgpuInstance_t,
        count: *mut ::std::os::raw::c_uint,
        pids: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries process's accounting stats.\n\n For Maxwell &tm; or newer fully supported devices.\n\n Accounting stats capture GPU utilization and other statistics across the lifetime of a process, and\n can be queried during life time of the process or after its termination.\n The time field in \\ref nvmlAccountingStats_t is reported as 0 during the lifetime of the process and\n updated to actual running time after its termination.\n Accounting stats are kept in a circular buffer, newly created processes overwrite information about old\n processes.\n\n See \\ref nvmlAccountingStats_t for description of each returned metric.\n List of processes that can be queried can be retrieved from \\ref nvmlVgpuInstanceGetAccountingPids.\n\n @note Accounting Mode needs to be on. See \\ref nvmlVgpuInstanceGetAccountingMode.\n @note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be\n         queried since they don't contribute to GPU utilization.\n @note In case of pid collision stats of only the latest process (that terminated last) will be reported\n\n @param vgpuInstance            The identifier of the target vGPU instance\n @param pid                     Process Id of the target process to query stats for\n @param stats                   Reference in which to return the process's accounting stats\n\n @return\n         - \\ref NVML_SUCCESS                 if stats have been successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a stats is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n                                             or \\a stats is not found\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetAccountingStats(
        vgpuInstance: nvmlVgpuInstance_t,
        pid: ::std::os::raw::c_uint,
        stats: *mut nvmlAccountingStats_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Clears accounting information of the vGPU instance that have already terminated.\n\n For Maxwell &tm; or newer fully supported devices.\n Requires root/admin permissions.\n\n @note Accounting Mode needs to be on. See \\ref nvmlVgpuInstanceGetAccountingMode.\n @note Only compute and graphics applications stats are reported and can be cleared since monitoring applications\n         stats don't contribute to GPU utilization.\n\n @param vgpuInstance            The identifier of the target vGPU instance\n\n @return\n         - \\ref NVML_SUCCESS                 if accounting information has been cleared\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is invalid\n         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceClearAccountingPids(vgpuInstance: nvmlVgpuInstance_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Query the license information of the vGPU instance.\n\n For Maxwell &tm; or newer fully supported devices.\n\n @param vgpuInstance              Identifier of the target vGPU instance\n @param licenseInfo               Pointer to vGPU license information structure\n\n @return\n         - \\ref NVML_SUCCESS                 if information is successfully retrieved\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a licenseInfo is NULL\n         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system\n         - \\ref NVML_ERROR_DRIVER_NOT_LOADED if NVIDIA driver is not running on the vGPU instance\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetLicenseInfo_v2(
        vgpuInstance: nvmlVgpuInstance_t,
        licenseInfo: *mut nvmlVgpuLicenseInfo_t,
    ) -> nvmlReturn_t;
}
#[doc = " Excluded GPU device information"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlExcludedDeviceInfo_st {
    #[doc = "!< The PCI information for the excluded GPU"]
    pub pciInfo: nvmlPciInfo_t,
    #[doc = "!< The ASCII string UUID for the excluded GPU"]
    pub uuid: [::std::os::raw::c_char; 80usize],
}
#[doc = " Excluded GPU device information"]
pub type nvmlExcludedDeviceInfo_t = nvmlExcludedDeviceInfo_st;
extern "C" {
    #[doc = " Retrieves the number of excluded GPU devices in the system.\n\n For all products.\n\n @param deviceCount                          Reference in which to return the number of excluded devices\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a deviceCount has been set\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a deviceCount is NULL"]
    pub fn nvmlGetExcludedDeviceCount(deviceCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Acquire the device information for an excluded GPU device, based on its index.\n\n For all products.\n\n Valid indices are derived from the \\a deviceCount returned by\n   \\ref nvmlGetExcludedDeviceCount(). For example, if \\a deviceCount is 2 the valid indices\n   are 0 and 1, corresponding to GPU 0 and GPU 1.\n\n @param index                                The index of the target GPU, >= 0 and < \\a deviceCount\n @param info                                 Reference in which to return the device information\n\n @return\n         - \\ref NVML_SUCCESS                  if \\a device has been set\n         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a index is invalid or \\a info is NULL\n\n @see nvmlGetExcludedDeviceCount"]
    pub fn nvmlGetExcludedDeviceInfoByIndex(
        index: ::std::os::raw::c_uint,
        info: *mut nvmlExcludedDeviceInfo_t,
    ) -> nvmlReturn_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGpuInstancePlacement_st {
    #[doc = "!< Index of first occupied memory slice"]
    pub start: ::std::os::raw::c_uint,
    #[doc = "!< Number of memory slices occupied"]
    pub size: ::std::os::raw::c_uint,
}
pub type nvmlGpuInstancePlacement_t = nvmlGpuInstancePlacement_st;
#[doc = " GPU instance profile information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGpuInstanceProfileInfo_st {
    #[doc = "!< Unique profile ID within the device"]
    pub id: ::std::os::raw::c_uint,
    #[doc = "!< Peer-to-Peer support"]
    pub isP2pSupported: ::std::os::raw::c_uint,
    #[doc = "!< GPU Slice count"]
    pub sliceCount: ::std::os::raw::c_uint,
    #[doc = "!< GPU instance count"]
    pub instanceCount: ::std::os::raw::c_uint,
    #[doc = "!< Streaming Multiprocessor count"]
    pub multiprocessorCount: ::std::os::raw::c_uint,
    #[doc = "!< Copy Engine count"]
    pub copyEngineCount: ::std::os::raw::c_uint,
    #[doc = "!< Decoder Engine count"]
    pub decoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Encoder Engine count"]
    pub encoderCount: ::std::os::raw::c_uint,
    #[doc = "!< JPEG Engine count"]
    pub jpegCount: ::std::os::raw::c_uint,
    #[doc = "!< OFA Engine count"]
    pub ofaCount: ::std::os::raw::c_uint,
    #[doc = "!< Memory size in MBytes"]
    pub memorySizeMB: ::std::os::raw::c_ulonglong,
}
#[doc = " GPU instance profile information."]
pub type nvmlGpuInstanceProfileInfo_t = nvmlGpuInstanceProfileInfo_st;
#[doc = " GPU instance profile information (v2).\n\n Version 2 adds the \\ref nvmlGpuInstanceProfileInfo_v2_t.version field\n to the start of the structure, and the \\ref nvmlGpuInstanceProfileInfo_v2_t.name\n field to the end. This structure is not backwards-compatible with\n \\ref nvmlGpuInstanceProfileInfo_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGpuInstanceProfileInfo_v2_st {
    #[doc = "!< Structure version identifier (set to \\ref nvmlGpuInstanceProfileInfo_v2)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Unique profile ID within the device"]
    pub id: ::std::os::raw::c_uint,
    #[doc = "!< Peer-to-Peer support"]
    pub isP2pSupported: ::std::os::raw::c_uint,
    #[doc = "!< GPU Slice count"]
    pub sliceCount: ::std::os::raw::c_uint,
    #[doc = "!< GPU instance count"]
    pub instanceCount: ::std::os::raw::c_uint,
    #[doc = "!< Streaming Multiprocessor count"]
    pub multiprocessorCount: ::std::os::raw::c_uint,
    #[doc = "!< Copy Engine count"]
    pub copyEngineCount: ::std::os::raw::c_uint,
    #[doc = "!< Decoder Engine count"]
    pub decoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Encoder Engine count"]
    pub encoderCount: ::std::os::raw::c_uint,
    #[doc = "!< JPEG Engine count"]
    pub jpegCount: ::std::os::raw::c_uint,
    #[doc = "!< OFA Engine count"]
    pub ofaCount: ::std::os::raw::c_uint,
    #[doc = "!< Memory size in MBytes"]
    pub memorySizeMB: ::std::os::raw::c_ulonglong,
    #[doc = "!< Profile name"]
    pub name: [::std::os::raw::c_char; 96usize],
}
#[doc = " GPU instance profile information (v2).\n\n Version 2 adds the \\ref nvmlGpuInstanceProfileInfo_v2_t.version field\n to the start of the structure, and the \\ref nvmlGpuInstanceProfileInfo_v2_t.name\n field to the end. This structure is not backwards-compatible with\n \\ref nvmlGpuInstanceProfileInfo_t."]
pub type nvmlGpuInstanceProfileInfo_v2_t = nvmlGpuInstanceProfileInfo_v2_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGpuInstanceInfo_st {
    #[doc = "!< Parent device"]
    pub device: nvmlDevice_t,
    #[doc = "!< Unique instance ID within the device"]
    pub id: ::std::os::raw::c_uint,
    #[doc = "!< Unique profile ID within the device"]
    pub profileId: ::std::os::raw::c_uint,
    #[doc = "!< Placement for this instance"]
    pub placement: nvmlGpuInstancePlacement_t,
}
pub type nvmlGpuInstanceInfo_t = nvmlGpuInstanceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstance_st {
    _unused: [u8; 0],
}
pub type nvmlGpuInstance_t = *mut nvmlGpuInstance_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlComputeInstancePlacement_st {
    #[doc = "!< Index of first occupied compute slice"]
    pub start: ::std::os::raw::c_uint,
    #[doc = "!< Number of compute slices occupied"]
    pub size: ::std::os::raw::c_uint,
}
pub type nvmlComputeInstancePlacement_t = nvmlComputeInstancePlacement_st;
#[doc = " Compute instance profile information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlComputeInstanceProfileInfo_st {
    #[doc = "!< Unique profile ID within the GPU instance"]
    pub id: ::std::os::raw::c_uint,
    #[doc = "!< GPU Slice count"]
    pub sliceCount: ::std::os::raw::c_uint,
    #[doc = "!< Compute instance count"]
    pub instanceCount: ::std::os::raw::c_uint,
    #[doc = "!< Streaming Multiprocessor count"]
    pub multiprocessorCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Copy Engine count"]
    pub sharedCopyEngineCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Decoder Engine count"]
    pub sharedDecoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Encoder Engine count"]
    pub sharedEncoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared JPEG Engine count"]
    pub sharedJpegCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared OFA Engine count"]
    pub sharedOfaCount: ::std::os::raw::c_uint,
}
#[doc = " Compute instance profile information."]
pub type nvmlComputeInstanceProfileInfo_t = nvmlComputeInstanceProfileInfo_st;
#[doc = " Compute instance profile information (v2).\n\n Version 2 adds the \\ref nvmlComputeInstanceProfileInfo_v2_t.version field\n to the start of the structure, and the \\ref nvmlComputeInstanceProfileInfo_v2_t.name\n field to the end. This structure is not backwards-compatible with\n \\ref nvmlComputeInstanceProfileInfo_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlComputeInstanceProfileInfo_v2_st {
    #[doc = "!< Structure version identifier (set to \\ref nvmlComputeInstanceProfileInfo_v2)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Unique profile ID within the GPU instance"]
    pub id: ::std::os::raw::c_uint,
    #[doc = "!< GPU Slice count"]
    pub sliceCount: ::std::os::raw::c_uint,
    #[doc = "!< Compute instance count"]
    pub instanceCount: ::std::os::raw::c_uint,
    #[doc = "!< Streaming Multiprocessor count"]
    pub multiprocessorCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Copy Engine count"]
    pub sharedCopyEngineCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Decoder Engine count"]
    pub sharedDecoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Encoder Engine count"]
    pub sharedEncoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared JPEG Engine count"]
    pub sharedJpegCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared OFA Engine count"]
    pub sharedOfaCount: ::std::os::raw::c_uint,
    #[doc = "!< Profile name"]
    pub name: [::std::os::raw::c_char; 96usize],
}
#[doc = " Compute instance profile information (v2).\n\n Version 2 adds the \\ref nvmlComputeInstanceProfileInfo_v2_t.version field\n to the start of the structure, and the \\ref nvmlComputeInstanceProfileInfo_v2_t.name\n field to the end. This structure is not backwards-compatible with\n \\ref nvmlComputeInstanceProfileInfo_t."]
pub type nvmlComputeInstanceProfileInfo_v2_t = nvmlComputeInstanceProfileInfo_v2_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlComputeInstanceInfo_st {
    #[doc = "!< Parent device"]
    pub device: nvmlDevice_t,
    #[doc = "!< Parent GPU instance"]
    pub gpuInstance: nvmlGpuInstance_t,
    #[doc = "!< Unique instance ID within the GPU instance"]
    pub id: ::std::os::raw::c_uint,
    #[doc = "!< Unique profile ID within the GPU instance"]
    pub profileId: ::std::os::raw::c_uint,
    #[doc = "!< Placement for this instance within the GPU instance's compute slice range {0, sliceCount}"]
    pub placement: nvmlComputeInstancePlacement_t,
}
pub type nvmlComputeInstanceInfo_t = nvmlComputeInstanceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstance_st {
    _unused: [u8; 0],
}
pub type nvmlComputeInstance_t = *mut nvmlComputeInstance_st;
extern "C" {
    #[doc = " Set MIG mode for the device.\n\n For Ampere &tm; or newer fully supported devices.\n Requires root user.\n\n This mode determines whether a GPU instance can be created.\n\n This API may unbind or reset the device to activate the requested mode. Thus, the attributes associated with the\n device, such as minor number, might change. The caller of this API is expected to query such attributes again.\n\n On certain platforms like pass-through virtualization, where reset functionality may not be exposed directly, VM\n reboot is required. \\a activationStatus would return \\ref NVML_ERROR_RESET_REQUIRED for such cases.\n\n \\a activationStatus would return the appropriate error code upon unsuccessful activation. For example, if device\n unbind fails because the device isn't idle, \\ref NVML_ERROR_IN_USE would be returned. The caller of this API\n is expected to idle the device and retry setting the \\a mode.\n\n @note On Windows, only disabling MIG mode is supported. \\a activationStatus would return \\ref\n       NVML_ERROR_NOT_SUPPORTED as GPU reset is not supported on Windows through this API.\n\n @param device                               The identifier of the target device\n @param mode                                 The mode to be set, \\ref NVML_DEVICE_MIG_DISABLE or\n                                             \\ref NVML_DEVICE_MIG_ENABLE\n @param activationStatus                     The activationStatus status\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a device,\\a mode or \\a activationStatus are invalid\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a device doesn't support MIG mode"]
    pub fn nvmlDeviceSetMigMode(
        device: nvmlDevice_t,
        mode: ::std::os::raw::c_uint,
        activationStatus: *mut nvmlReturn_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get MIG mode for the device.\n\n For Ampere &tm; or newer fully supported devices.\n\n Changing MIG modes may require device unbind or reset. The \"pending\" MIG mode refers to the target mode following the\n next activation trigger.\n\n @param device                               The identifier of the target device\n @param currentMode                          Returns the current mode, \\ref NVML_DEVICE_MIG_DISABLE or\n                                             \\ref NVML_DEVICE_MIG_ENABLE\n @param pendingMode                          Returns the pending mode, \\ref NVML_DEVICE_MIG_DISABLE or\n                                             \\ref NVML_DEVICE_MIG_ENABLE\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a device, \\a currentMode or \\a pendingMode are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a device doesn't support MIG mode"]
    pub fn nvmlDeviceGetMigMode(
        device: nvmlDevice_t,
        currentMode: *mut ::std::os::raw::c_uint,
        pendingMode: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get GPU instance profile information.\n\n Information provided by this API is immutable throughout the lifetime of a MIG mode.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               The identifier of the target device\n @param profile                              One of the NVML_GPU_INSTANCE_PROFILE_*\n @param info                                 Returns detailed profile information\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a device, \\a profile or \\a info are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a device doesn't have MIG mode enabled or \\a profile isn't supported\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlDeviceGetGpuInstanceProfileInfo(
        device: nvmlDevice_t,
        profile: ::std::os::raw::c_uint,
        info: *mut nvmlGpuInstanceProfileInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Versioned wrapper around \\ref nvmlDeviceGetGpuInstanceProfileInfo that accepts a versioned\n \\ref nvmlGpuInstanceProfileInfo_v2_t or later output structure.\n\n @note The caller must set the \\ref nvmlGpuInstanceProfileInfo_v2_t.version field to the\n appropriate version prior to calling this function. For example:\n \\code\n     nvmlGpuInstanceProfileInfo_v2_t profileInfo =\n         { .version = nvmlGpuInstanceProfileInfo_v2 };\n     nvmlReturn_t result = nvmlDeviceGetGpuInstanceProfileInfoV(device,\n                                                                profile,\n                                                                &profileInfo);\n \\endcode\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               The identifier of the target device\n @param profile                              One of the NVML_GPU_INSTANCE_PROFILE_*\n @param info                                 Returns detailed profile information\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a device, \\a profile, \\a info, or \\a info->version are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a device doesn't have MIG mode enabled or \\a profile isn't supported\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlDeviceGetGpuInstanceProfileInfoV(
        device: nvmlDevice_t,
        profile: ::std::os::raw::c_uint,
        info: *mut nvmlGpuInstanceProfileInfo_v2_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get GPU instance placements.\n\n A placement represents the location of a GPU instance within a device. This API only returns all the possible\n placements for the given profile.\n A created GPU instance occupies memory slices described by its placement. Creation of new GPU instance will\n fail if there is overlap with the already occupied memory slices.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n @param device                               The identifier of the target device\n @param profileId                            The GPU instance profile ID. See \\ref nvmlDeviceGetGpuInstanceProfileInfo\n @param placements                           Returns placements allowed for the profile. Can be NULL to discover number\n                                             of allowed placements for this profile. If non-NULL must be large enough\n                                             to accommodate the placements supported by the profile.\n @param count                                Returns number of allowed placemenets for the profile.\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a device, \\a profileId or \\a count are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a device doesn't have MIG mode enabled or \\a profileId isn't supported\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlDeviceGetGpuInstancePossiblePlacements_v2(
        device: nvmlDevice_t,
        profileId: ::std::os::raw::c_uint,
        placements: *mut nvmlGpuInstancePlacement_t,
        count: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get GPU instance profile capacity.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n @param device                               The identifier of the target device\n @param profileId                            The GPU instance profile ID. See \\ref nvmlDeviceGetGpuInstanceProfileInfo\n @param count                                Returns remaining instance count for the profile ID\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a device, \\a profileId or \\a count are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a device doesn't have MIG mode enabled or \\a profileId isn't supported\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlDeviceGetGpuInstanceRemainingCapacity(
        device: nvmlDevice_t,
        profileId: ::std::os::raw::c_uint,
        count: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Create GPU instance.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n If the parent device is unbound, reset or the GPU instance is destroyed explicitly, the GPU instance handle would\n become invalid. The GPU instance must be recreated to acquire a valid handle.\n\n @param device                               The identifier of the target device\n @param profileId                            The GPU instance profile ID. See \\ref nvmlDeviceGetGpuInstanceProfileInfo\n @param gpuInstance                          Returns the GPU instance handle\n\n @return\n         - \\ref NVML_SUCCESS                       Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED           If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT        If \\a device, \\a profile, \\a profileId or \\a gpuInstance are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED           If \\a device doesn't have MIG mode enabled or in vGPU guest\n         - \\ref NVML_ERROR_NO_PERMISSION           If user doesn't have permission to perform the operation\n         - \\ref NVML_ERROR_INSUFFICIENT_RESOURCES  If the requested GPU instance could not be created"]
    pub fn nvmlDeviceCreateGpuInstance(
        device: nvmlDevice_t,
        profileId: ::std::os::raw::c_uint,
        gpuInstance: *mut nvmlGpuInstance_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Create GPU instance with the specified placement.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n If the parent device is unbound, reset or the GPU instance is destroyed explicitly, the GPU instance handle would\n become invalid. The GPU instance must be recreated to acquire a valid handle.\n\n @param device                               The identifier of the target device\n @param profileId                            The GPU instance profile ID. See \\ref nvmlDeviceGetGpuInstanceProfileInfo\n @param placement                            The requested placement. See \\ref nvmlDeviceGetGpuInstancePossiblePlacements_v2\n @param gpuInstance                          Returns the GPU instance handle\n\n @return\n         - \\ref NVML_SUCCESS                       Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED           If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT        If \\a device, \\a profile, \\a profileId, \\a placement or \\a gpuInstance\n                                                   are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED           If \\a device doesn't have MIG mode enabled or in vGPU guest\n         - \\ref NVML_ERROR_NO_PERMISSION           If user doesn't have permission to perform the operation\n         - \\ref NVML_ERROR_INSUFFICIENT_RESOURCES  If the requested GPU instance could not be created"]
    pub fn nvmlDeviceCreateGpuInstanceWithPlacement(
        device: nvmlDevice_t,
        profileId: ::std::os::raw::c_uint,
        placement: *const nvmlGpuInstancePlacement_t,
        gpuInstance: *mut nvmlGpuInstance_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Destroy GPU instance.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n @param gpuInstance                          The GPU instance handle\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a gpuInstance is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a device doesn't have MIG mode enabled or in vGPU guest\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation\n         - \\ref NVML_ERROR_IN_USE            If the GPU instance is in use. This error would be returned if processes\n                                             (e.g. CUDA application) or compute instances are active on the\n                                             GPU instance."]
    pub fn nvmlGpuInstanceDestroy(gpuInstance: nvmlGpuInstance_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get GPU instances for given profile ID.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n @param device                               The identifier of the target device\n @param profileId                            The GPU instance profile ID. See \\ref nvmlDeviceGetGpuInstanceProfileInfo\n @param gpuInstances                         Returns pre-exiting GPU instances, the buffer must be large enough to\n                                             accommodate the instances supported by the profile.\n                                             See \\ref nvmlDeviceGetGpuInstanceProfileInfo\n @param count                                The count of returned GPU instances\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a device, \\a profileId, \\a gpuInstances or \\a count are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a device doesn't have MIG mode enabled\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlDeviceGetGpuInstances(
        device: nvmlDevice_t,
        profileId: ::std::os::raw::c_uint,
        gpuInstances: *mut nvmlGpuInstance_t,
        count: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get GPU instances for given instance ID.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n @param device                               The identifier of the target device\n @param id                                   The GPU instance ID\n @param gpuInstance                          Returns GPU instance\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a device, \\a id or \\a gpuInstance are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a device doesn't have MIG mode enabled\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation\n         - \\ref NVML_ERROR_NOT_FOUND         If the GPU instance is not found."]
    pub fn nvmlDeviceGetGpuInstanceById(
        device: nvmlDevice_t,
        id: ::std::os::raw::c_uint,
        gpuInstance: *mut nvmlGpuInstance_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get GPU instance information.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param gpuInstance                          The GPU instance handle\n @param info                                 Return GPU instance information\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a gpuInstance or \\a info are invalid\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlGpuInstanceGetInfo(
        gpuInstance: nvmlGpuInstance_t,
        info: *mut nvmlGpuInstanceInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get compute instance profile information.\n\n Information provided by this API is immutable throughout the lifetime of a MIG mode.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param gpuInstance                          The identifier of the target GPU instance\n @param profile                              One of the NVML_COMPUTE_INSTANCE_PROFILE_*\n @param engProfile                           One of the NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_*\n @param info                                 Returns detailed profile information\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a gpuInstance, \\a profile, \\a engProfile or \\a info are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a profile isn't supported\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlGpuInstanceGetComputeInstanceProfileInfo(
        gpuInstance: nvmlGpuInstance_t,
        profile: ::std::os::raw::c_uint,
        engProfile: ::std::os::raw::c_uint,
        info: *mut nvmlComputeInstanceProfileInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Versioned wrapper around \\ref nvmlGpuInstanceGetComputeInstanceProfileInfo that accepts a versioned\n \\ref nvmlComputeInstanceProfileInfo_v2_t or later output structure.\n\n @note The caller must set the \\ref nvmlGpuInstanceProfileInfo_v2_t.version field to the\n appropriate version prior to calling this function. For example:\n \\code\n     nvmlComputeInstanceProfileInfo_v2_t profileInfo =\n         { .version = nvmlComputeInstanceProfileInfo_v2 };\n     nvmlReturn_t result = nvmlGpuInstanceGetComputeInstanceProfileInfoV(gpuInstance,\n                                                                         profile,\n                                                                         engProfile,\n                                                                         &profileInfo);\n \\endcode\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param gpuInstance                          The identifier of the target GPU instance\n @param profile                              One of the NVML_COMPUTE_INSTANCE_PROFILE_*\n @param engProfile                           One of the NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_*\n @param info                                 Returns detailed profile information\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a gpuInstance, \\a profile, \\a engProfile, \\a info, or \\a info->version are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a profile isn't supported\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlGpuInstanceGetComputeInstanceProfileInfoV(
        gpuInstance: nvmlGpuInstance_t,
        profile: ::std::os::raw::c_uint,
        engProfile: ::std::os::raw::c_uint,
        info: *mut nvmlComputeInstanceProfileInfo_v2_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get compute instance profile capacity.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n @param gpuInstance                          The identifier of the target GPU instance\n @param profileId                            The compute instance profile ID.\n                                             See \\ref nvmlGpuInstanceGetComputeInstanceProfileInfo\n @param count                                Returns remaining instance count for the profile ID\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a gpuInstance, \\a profileId or \\a availableCount are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a profileId isn't supported\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlGpuInstanceGetComputeInstanceRemainingCapacity(
        gpuInstance: nvmlGpuInstance_t,
        profileId: ::std::os::raw::c_uint,
        count: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Create compute instance.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n If the parent device is unbound, reset or the parent GPU instance is destroyed or the compute instance is destroyed\n explicitly, the compute instance handle would become invalid. The compute instance must be recreated to acquire\n a valid handle.\n\n @param gpuInstance                          The identifier of the target GPU instance\n @param profileId                            The compute instance profile ID.\n                                             See \\ref nvmlGpuInstanceGetComputeInstanceProfileInfo\n @param computeInstance                      Returns the compute instance handle\n\n @return\n         - \\ref NVML_SUCCESS                       Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED           If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT        If \\a gpuInstance, \\a profile, \\a profileId or \\a computeInstance\n                                                   are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED           If \\a profileId isn't supported\n         - \\ref NVML_ERROR_NO_PERMISSION           If user doesn't have permission to perform the operation\n         - \\ref NVML_ERROR_INSUFFICIENT_RESOURCES  If the requested compute instance could not be created"]
    pub fn nvmlGpuInstanceCreateComputeInstance(
        gpuInstance: nvmlGpuInstance_t,
        profileId: ::std::os::raw::c_uint,
        computeInstance: *mut nvmlComputeInstance_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Destroy compute instance.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n @param computeInstance                      The compute instance handle\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a computeInstance is invalid\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation\n         - \\ref NVML_ERROR_IN_USE            If the compute instance is in use. This error would be returned if\n                                             processes (e.g. CUDA application) are active on the compute instance."]
    pub fn nvmlComputeInstanceDestroy(computeInstance: nvmlComputeInstance_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get compute instances for given profile ID.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n @param gpuInstance                          The identifier of the target GPU instance\n @param profileId                            The compute instance profile ID.\n                                             See \\ref nvmlGpuInstanceGetComputeInstanceProfileInfo\n @param computeInstances                     Returns pre-exiting compute instances, the buffer must be large enough to\n                                             accommodate the instances supported by the profile.\n                                             See \\ref nvmlGpuInstanceGetComputeInstanceProfileInfo\n @param count                                The count of returned compute instances\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a gpuInstance, \\a profileId, \\a computeInstances or \\a count\n                                             are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a profileId isn't supported\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlGpuInstanceGetComputeInstances(
        gpuInstance: nvmlGpuInstance_t,
        profileId: ::std::os::raw::c_uint,
        computeInstances: *mut nvmlComputeInstance_t,
        count: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get compute instance for given instance ID.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n Requires privileged user.\n\n @param gpuInstance                          The identifier of the target GPU instance\n @param id                                   The compute instance ID\n @param computeInstance                      Returns compute instance\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a device, \\a ID or \\a computeInstance are invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     If \\a device doesn't have MIG mode enabled\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation\n         - \\ref NVML_ERROR_NOT_FOUND         If the compute instance is not found."]
    pub fn nvmlGpuInstanceGetComputeInstanceById(
        gpuInstance: nvmlGpuInstance_t,
        id: ::std::os::raw::c_uint,
        computeInstance: *mut nvmlComputeInstance_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get compute instance information.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param computeInstance                      The compute instance handle\n @param info                                 Return compute instance information\n\n @return\n         - \\ref NVML_SUCCESS                 Upon success\n         - \\ref NVML_ERROR_UNINITIALIZED     If library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  If \\a computeInstance or \\a info are invalid\n         - \\ref NVML_ERROR_NO_PERMISSION     If user doesn't have permission to perform the operation"]
    pub fn nvmlComputeInstanceGetInfo_v2(
        computeInstance: nvmlComputeInstance_t,
        info: *mut nvmlComputeInstanceInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Test if the given handle refers to a MIG device.\n\n A MIG device handle is an NVML abstraction which maps to a MIG compute instance.\n These overloaded references can be used (with some restrictions) interchangeably\n with a GPU device handle to execute queries at a per-compute instance granularity.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               NVML handle to test\n @param isMigDevice                          True when handle refers to a MIG device\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a device status was successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device handle or \\a isMigDevice reference is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this check is not supported by the device\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceIsMigDeviceHandle(
        device: nvmlDevice_t,
        isMigDevice: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get GPU instance ID for the given MIG device handle.\n\n GPU instance IDs are unique per device and remain valid until the GPU instance is destroyed.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               Target MIG device handle\n @param id                                   GPU instance ID\n\n @return\n         - \\ref NVML_SUCCESS                 if instance ID was successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a id reference is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetGpuInstanceId(
        device: nvmlDevice_t,
        id: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get compute instance ID for the given MIG device handle.\n\n Compute instance IDs are unique per GPU instance and remain valid until the compute instance\n is destroyed.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               Target MIG device handle\n @param id                                   Compute instance ID\n\n @return\n         - \\ref NVML_SUCCESS                 if instance ID was successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a id reference is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetComputeInstanceId(
        device: nvmlDevice_t,
        id: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get the maximum number of MIG devices that can exist under a given parent NVML device.\n\n Returns zero if MIG is not supported or enabled.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               Target device handle\n @param count                                Count of MIG devices\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a count was successfully retrieved\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a count reference is invalid\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMaxMigDeviceCount(
        device: nvmlDevice_t,
        count: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get MIG device handle for the given index under its parent NVML device.\n\n If the compute instance is destroyed either explicitly or by destroying,\n resetting or unbinding the parent GPU instance or the GPU device itself\n the MIG device handle would remain invalid and must be requested again\n using this API. Handles may be reused and their properties can change in\n the process.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param device                               Reference to the parent GPU device handle\n @param index                                Index of the MIG device\n @param migDevice                            Reference to the MIG device handle\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a migDevice handle was successfully created\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a index or \\a migDevice reference is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_NOT_FOUND         if no valid MIG device was found at \\a index\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMigDeviceHandleByIndex(
        device: nvmlDevice_t,
        index: ::std::os::raw::c_uint,
        migDevice: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get parent device handle from a MIG device handle.\n\n For Ampere &tm; or newer fully supported devices.\n Supported on Linux only.\n\n @param migDevice                            MIG device handle\n @param device                               Device handle\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a device handle was successfully created\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a migDevice or \\a device is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetDeviceHandleFromMigDeviceHandle(
        migDevice: nvmlDevice_t,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get the type of the GPU Bus (PCIe, PCI, ...)\n\n @param device                               The identifier of the target device\n @param type                                 The PCI Bus type\n\n return\n         - \\ref NVML_SUCCESS                 if the bus \\a type is successfully retreived\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\device is invalid or \\type is NULL\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetBusType(device: nvmlDevice_t, type_: *mut nvmlBusType_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve performance monitor samples from the associated subdevice.\n\n @param device\n @param pDynamicPstatesInfo\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a pDynamicPstatesInfo has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a pDynamicPstatesInfo is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetDynamicPstatesInfo(
        device: nvmlDevice_t,
        pDynamicPstatesInfo: *mut nvmlGpuDynamicPstatesInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Sets the speed of a specified fan.\n\n WARNING: This function changes the fan control policy to manual. It means that YOU have to monitor\n          the temperature and adjust the fan speed accordingly.\n          If you set the fan speed too low you can burn your GPU!\n          Use nvmlDeviceSetDefaultFanSpeed_v2 to restore default control policy.\n\n For all cuda-capable discrete products with fans that are Maxwell or Newer.\n\n device                                The identifier of the target device\n fan                                   The index of the fan, starting at zero\n speed                                 The target speed of the fan [0-100] in % of max speed\n\n return\n        NVML_SUCCESS                   if the fan speed has been set\n        NVML_ERROR_UNINITIALIZED       if the library has not been successfully initialized\n        NVML_ERROR_INVALID_ARGUMENT    if the device is not valid, or the speed is outside acceptable ranges,\n                                              or if the fan index doesn't reference an actual fan.\n        NVML_ERROR_NOT_SUPPORTED       if the device is older than Maxwell.\n        NVML_ERROR_UNKNOWN             if there was an unexpected error."]
    pub fn nvmlDeviceSetFanSpeed_v2(
        device: nvmlDevice_t,
        fan: ::std::os::raw::c_uint,
        speed: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the GPCCLK VF offset value\n @param[in]   device                         The identifier of the target device\n @param[out]  offset                         The retrieved GPCCLK VF offset value\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a offset has been successfully queried\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a offset is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetGpcClkVfOffset(
        device: nvmlDevice_t,
        offset: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the GPCCLK VF offset value\n @param[in]   device                         The identifier of the target device\n @param[in]   offset                         The GPCCLK VF offset value to set\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a offset has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a offset is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetGpcClkVfOffset(
        device: nvmlDevice_t,
        offset: ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the MemClk (Memory Clock) VF offset value.\n @param[in]   device                         The identifier of the target device\n @param[out]  offset                         The retrieved MemClk VF offset value\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a offset has been successfully queried\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a offset is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMemClkVfOffset(
        device: nvmlDevice_t,
        offset: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the MemClk (Memory Clock) VF offset value. It requires elevated privileges.\n @param[in]   device                         The identifier of the target device\n @param[in]   offset                         The MemClk VF offset value to set\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a offset has been set\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a offset is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetMemClkVfOffset(
        device: nvmlDevice_t,
        offset: ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve min and max clocks of some clock domain for a given PState\n\n @param device                               The identifier of the target device\n @param type                                 Clock domain\n @param pstate                               PState to query\n @param minClockMHz                          Reference in which to return min clock frequency\n @param maxClockMHz                          Reference in which to return max clock frequency\n\n @return\n         - \\ref NVML_SUCCESS                 if everything worked\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a type or \\a pstate are invalid or both\n                                                  \\a minClockMHz and \\a maxClockMHz are NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    pub fn nvmlDeviceGetMinMaxClockOfPState(
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        pstate: nvmlPstates_t,
        minClockMHz: *mut ::std::os::raw::c_uint,
        maxClockMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get all supported Performance States (P-States) for the device.\n\n The returned array would contain a contiguous list of valid P-States supported by\n the device. If the number of supported P-States is fewer than the size of the array\n supplied missing elements would contain \\a NVML_PSTATE_UNKNOWN.\n\n The number of elements in the returned list will never exceed \\a NVML_MAX_GPU_PERF_PSTATES.\n\n @param device                               The identifier of the target device\n @param pstates                              Container to return the list of performance states\n                                             supported by device\n @param size                                 Size of the supplied \\a pstates array in bytes\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a pstates array has been retrieved\n         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if the the container supplied was not large enough to\n                                             hold the resulting list\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a pstates is invalid\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support performance state readings\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetSupportedPerformanceStates(
        device: nvmlDevice_t,
        pstates: *mut nvmlPstates_t,
        size: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the GPCCLK min max VF offset value.\n @param[in]   device                         The identifier of the target device\n @param[out]  minOffset                      The retrieved GPCCLK VF min offset value\n @param[out]  maxOffset                      The retrieved GPCCLK VF max offset value\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a offset has been successfully queried\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a offset is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetGpcClkMinMaxVfOffset(
        device: nvmlDevice_t,
        minOffset: *mut ::std::os::raw::c_int,
        maxOffset: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the MemClk (Memory Clock) min max VF offset value.\n @param[in]   device                         The identifier of the target device\n @param[out]  minOffset                      The retrieved MemClk VF min offset value\n @param[out]  maxOffset                      The retrieved MemClk VF max offset value\n\n @return\n         - \\ref NVML_SUCCESS                 if \\a offset has been successfully queried\n         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized\n         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a offset is NULL\n         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature\n         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMemClkMinMaxVfOffset(
        device: nvmlDevice_t,
        minOffset: *mut ::std::os::raw::c_int,
        maxOffset: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_GRAPHICS_UTIL: nvmlGpmMetricId_t = 1;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_SM_UTIL: nvmlGpmMetricId_t = 2;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_SM_OCCUPANCY: nvmlGpmMetricId_t = 3;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_INTEGER_UTIL: nvmlGpmMetricId_t = 4;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_ANY_TENSOR_UTIL: nvmlGpmMetricId_t = 5;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_DFMA_TENSOR_UTIL: nvmlGpmMetricId_t = 6;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_HMMA_TENSOR_UTIL: nvmlGpmMetricId_t = 7;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_IMMA_TENSOR_UTIL: nvmlGpmMetricId_t = 9;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_DRAM_BW_UTIL: nvmlGpmMetricId_t = 10;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_FP64_UTIL: nvmlGpmMetricId_t = 11;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_FP32_UTIL: nvmlGpmMetricId_t = 12;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_FP16_UTIL: nvmlGpmMetricId_t = 13;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_PCIE_TX_PER_SEC: nvmlGpmMetricId_t = 20;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_PCIE_RX_PER_SEC: nvmlGpmMetricId_t = 21;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_0_UTIL: nvmlGpmMetricId_t = 30;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_1_UTIL: nvmlGpmMetricId_t = 31;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_2_UTIL: nvmlGpmMetricId_t = 32;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_3_UTIL: nvmlGpmMetricId_t = 33;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_4_UTIL: nvmlGpmMetricId_t = 34;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_5_UTIL: nvmlGpmMetricId_t = 35;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_6_UTIL: nvmlGpmMetricId_t = 36;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_7_UTIL: nvmlGpmMetricId_t = 37;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_0_UTIL: nvmlGpmMetricId_t = 40;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_1_UTIL: nvmlGpmMetricId_t = 41;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_2_UTIL: nvmlGpmMetricId_t = 42;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_3_UTIL: nvmlGpmMetricId_t = 43;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_4_UTIL: nvmlGpmMetricId_t = 44;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_5_UTIL: nvmlGpmMetricId_t = 45;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_6_UTIL: nvmlGpmMetricId_t = 46;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_7_UTIL: nvmlGpmMetricId_t = 47;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVOFA_0_UTIL: nvmlGpmMetricId_t = 50;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_TOTAL_RX_PER_SEC: nvmlGpmMetricId_t = 60;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_TOTAL_TX_PER_SEC: nvmlGpmMetricId_t = 61;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L0_RX_PER_SEC: nvmlGpmMetricId_t = 62;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L0_TX_PER_SEC: nvmlGpmMetricId_t = 63;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L1_RX_PER_SEC: nvmlGpmMetricId_t = 64;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L1_TX_PER_SEC: nvmlGpmMetricId_t = 65;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L2_RX_PER_SEC: nvmlGpmMetricId_t = 66;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L2_TX_PER_SEC: nvmlGpmMetricId_t = 67;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L3_RX_PER_SEC: nvmlGpmMetricId_t = 68;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L3_TX_PER_SEC: nvmlGpmMetricId_t = 69;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L4_RX_PER_SEC: nvmlGpmMetricId_t = 70;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L4_TX_PER_SEC: nvmlGpmMetricId_t = 71;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L5_RX_PER_SEC: nvmlGpmMetricId_t = 72;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L5_TX_PER_SEC: nvmlGpmMetricId_t = 73;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L6_RX_PER_SEC: nvmlGpmMetricId_t = 74;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L6_TX_PER_SEC: nvmlGpmMetricId_t = 75;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L7_RX_PER_SEC: nvmlGpmMetricId_t = 76;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L7_TX_PER_SEC: nvmlGpmMetricId_t = 77;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L8_RX_PER_SEC: nvmlGpmMetricId_t = 78;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L8_TX_PER_SEC: nvmlGpmMetricId_t = 79;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L9_RX_PER_SEC: nvmlGpmMetricId_t = 80;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L9_TX_PER_SEC: nvmlGpmMetricId_t = 81;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L10_RX_PER_SEC: nvmlGpmMetricId_t = 82;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L10_TX_PER_SEC: nvmlGpmMetricId_t = 83;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L11_RX_PER_SEC: nvmlGpmMetricId_t = 84;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L11_TX_PER_SEC: nvmlGpmMetricId_t = 85;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L12_RX_PER_SEC: nvmlGpmMetricId_t = 86;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L12_TX_PER_SEC: nvmlGpmMetricId_t = 87;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L13_RX_PER_SEC: nvmlGpmMetricId_t = 88;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L13_TX_PER_SEC: nvmlGpmMetricId_t = 89;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L14_RX_PER_SEC: nvmlGpmMetricId_t = 90;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L14_TX_PER_SEC: nvmlGpmMetricId_t = 91;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L15_RX_PER_SEC: nvmlGpmMetricId_t = 92;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L15_TX_PER_SEC: nvmlGpmMetricId_t = 93;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L16_RX_PER_SEC: nvmlGpmMetricId_t = 94;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L16_TX_PER_SEC: nvmlGpmMetricId_t = 95;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L17_RX_PER_SEC: nvmlGpmMetricId_t = 96;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L17_TX_PER_SEC: nvmlGpmMetricId_t = 97;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_MAX: nvmlGpmMetricId_t = 98;
#[doc = "/\n/** @defgroup GPM NVML GPM\n  @{\n/\n/***************************************************************************************************/\n/** @defgroup nvmlGpmEnums GPM Enums\n  @{\n/\n/"]
pub type nvmlGpmMetricId_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpmSample_st {
    _unused: [u8; 0],
}
#[doc = "/\n/** @defgroup nvmlGpmStructs GPM Structs\n  @{\n/\n/"]
pub type nvmlGpmSample_t = *mut nvmlGpmSample_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct nvmlGpmMetric_t {
    pub metricId: ::std::os::raw::c_uint,
    pub nvmlReturn: nvmlReturn_t,
    pub value: f64,
    pub metricInfo: nvmlGpmMetric_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGpmMetric_t__bindgen_ty_1 {
    pub shortName: *mut ::std::os::raw::c_char,
    pub longName: *mut ::std::os::raw::c_char,
    pub unit: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct nvmlGpmMetricsGet_t {
    pub version: ::std::os::raw::c_uint,
    pub numMetrics: ::std::os::raw::c_uint,
    pub sample1: nvmlGpmSample_t,
    pub sample2: nvmlGpmSample_t,
    pub metrics: [nvmlGpmMetric_t; 98usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvmlGpmSupport_t {
    pub version: ::std::os::raw::c_uint,
    pub isSupportedDevice: ::std::os::raw::c_uint,
}
extern "C" {
    #[doc = " Calculate GPM metrics from two samples.\n\n\n @param metricsGet             IN/OUT: populated nvmlGpmMetricsGet_t struct\n\n %HOPPER_OR_NEWER%\n\n @return\n         - \\ref NVML_SUCCESS on success\n         - Nonzero NVML_ERROR_? enum on error"]
    pub fn nvmlGpmMetricsGet(metricsGet: *mut nvmlGpmMetricsGet_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Free an allocated sample buffer that was allocated with \\ref nvmlGpmSampleAlloc()\n\n %HOPPER_OR_NEWER%\n\n @param gpmSample              Sample to free\n\n @return\n         - \\ref NVML_SUCCESS                on success\n         - \\ref NVML_ERROR_INVALID_ARGUMENT if an invalid pointer is provided"]
    pub fn nvmlGpmSampleFree(gpmSample: nvmlGpmSample_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Allocate a sample buffer to be used with NVML GPM . You will need to allocate\n at least two of these buffers to use with the NVML GPM feature\n\n %HOPPER_OR_NEWER%\n\n @param gpmSample             Where  the allocated sample will be stored\n\n @return\n         - \\ref NVML_SUCCESS                on success\n         - \\ref NVML_ERROR_INVALID_ARGUMENT if an invalid pointer is provided\n         - \\ref NVML_ERROR_MEMORY           if system memory is insufficient"]
    pub fn nvmlGpmSampleAlloc(gpmSample: *mut nvmlGpmSample_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Read a sample of GPM metrics into the provided \\a gpmSample buffer. After\n two samples are gathered, you can call nvmlGpmMetricGet on those samples to\n retrive metrics\n\n %HOPPER_OR_NEWER%\n\n @param device                Device to get samples for\n @param gpmSample             Buffer to read samples into\n\n @return\n         - \\ref NVML_SUCCESS on success\n         - Nonzero NVML_ERROR_? enum on error"]
    pub fn nvmlGpmSampleGet(device: nvmlDevice_t, gpmSample: nvmlGpmSample_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Indicate whether the supplied device supports GPM\n\n @param device                NVML device to query for\n @param gpmSupport            Structure to indicate GPM support. Indicates\n                              GPM support per system for the supplied device\n\n @return\n         - NVML_SUCCESS on success\n         - Nonzero NVML_ERROR_? enum if there is an error in processing the query"]
    pub fn nvmlGpmQueryDeviceSupport(
        device: nvmlDevice_t,
        gpmSupport: *mut nvmlGpmSupport_t,
    ) -> nvmlReturn_t;
}
