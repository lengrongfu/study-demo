#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use api;
use futures::executor::block_on;
use std::borrow::BorrowMut;
use std::sync::{Mutex, Once};
use tarpc::{client, context, tokio_serde::formats::Json};
use tokio::runtime;

pub type CUresult = ::std::os::raw::c_uint;
pub type CUdeviceptr_v2 = ::std::os::raw::c_ulonglong;
pub type CUdeviceptr = CUdeviceptr_v2;
pub type CUdevice_v1 = ::std::os::raw::c_int;
pub type CUdevice = CUdevice_v1;

static mut CUDA_CLIENT: Option<Mutex<api::nvm_api::NvmlClient>> = None;
static mut RPC_RUNTIME: Option<Mutex<runtime::Runtime>> = None;
static CUDA_INIT: Once = Once::new();
static RPC_INIT: Once = Once::new();

fn cudaClient<'a>() -> &'a Mutex<api::nvm_api::NvmlClient> {
    CUDA_INIT.call_once(|| {
        // Since this access is inside a call_once, before any other accesses, it is safe
        unsafe {
            let transport = block_on(tarpc::serde_transport::tcp::connect(
                "192.168.0.1:50051",
                Json::default,
            ))
            .unwrap();
            // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
            // config and any Transport as input.
            let client =
                api::nvm_api::NvmlClient::new(client::Config::default(), transport).spawn();
            *CUDA_CLIENT.borrow_mut() = Some(Mutex::new(client));
        }
    });

    // As long as this function is the only place with access to the static variable,
    // giving out a read-only borrow here is safe because it is guaranteed no more mutable
    // references will exist at this point or in the future.
    unsafe { CUDA_CLIENT.as_ref().unwrap() }
}

fn buildRuntime<'a>() -> &'a Mutex<runtime::Runtime> {
    RPC_INIT.call_once(|| {
        unsafe {
            // let rt = runtime::Runtime::new().unwrap();
            let rt = tokio::runtime::Builder::new_multi_thread()
                .worker_threads(8) // 8个工作线程
                .enable_io() // 可在runtime中使用异步IO
                .enable_time() // 可在runtime中使用异步计时器(timer)
                .build() // 创建runtime
                .unwrap();
            *RPC_RUNTIME.borrow_mut() = Some(Mutex::new(rt));
        }
    });
    unsafe { RPC_RUNTIME.as_ref().unwrap() }
}

#[no_mangle]
pub extern "C" fn nvmlInit() -> CUresult {
    println!("this is nvml-so, call nvmlInit");
    nvmlInit_v2()
}

#[no_mangle]
pub extern "C" fn nvmlInit_v2() -> CUresult {
    println!("this is nvml-so, call nvmlInit_v2");
    buildRuntime().lock().unwrap().block_on(async {
        let ret = block_on(cudaClient().lock().unwrap().nvmlInitV2(context::current())).unwrap();
        ret
    })
}

#[no_mangle]
pub unsafe extern "C" fn nvmlDeviceGetCount_v2(
    deviceCount: *mut ::std::os::raw::c_uint,
) -> CUresult {
    println!("this is nvml-so, call nvmlDeviceGetCount_v2");
    buildRuntime().lock().unwrap().block_on(async {
        let (deviceCountPtr, res) = block_on(
            cudaClient()
                .lock()
                .unwrap()
                .nvmlDeviceGetCountV2(context::current()),
        )
        .unwrap();
        *deviceCount = deviceCountPtr;
        res
    })
}

#[no_mangle]
pub extern "C" fn nvmlShutdown() -> CUresult {
    println!("this is nvml-so, call nvmlShutdown");
    buildRuntime().lock().unwrap().block_on(async {
        let ret = block_on(
            cudaClient()
                .lock()
                .unwrap()
                .nvmlShutdown(context::current()),
        )
        .unwrap();
        ret
    })
}
